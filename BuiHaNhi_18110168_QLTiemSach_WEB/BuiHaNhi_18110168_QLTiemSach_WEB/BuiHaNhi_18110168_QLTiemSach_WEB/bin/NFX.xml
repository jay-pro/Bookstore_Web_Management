<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NFX</name>
    </assembly>
    <members>
        <member name="T:NFX.AbsentValue">
            <summary>
            Represents a special value that signifies the absence of any entity/state/value/data.
            The instances may be stored in a cache to indicate that the key exists, but points to a non-existing "absent" entity.
            This is usefull for DB lookups, not to touch the backend for values that dont exist.
            Use AbsentValue.Instance singleton
            </summary>
        </member>
        <member name="T:NFX.App">
            <summary>
            Provides a shortcut access to app-global context NFX.ApplicationModel.ExecutionContext.Application.*
            </summary>
        </member>
        <member name="M:NFX.App.SetMemoryModel(NFX.App.MemoryUtilizationModel)">
            <summary>
            Sets the memory utilization model for the whole app.
            This setting is NOT configurable. It may be set at process entrypoint via a call to
            App.SetMemoryModel() before the app contrainer spawns.
            Typical applications should not change the defaults.
            Some system service providers may examine this property to allocate less cache and temp buffers
            in the memory-constrained environments
            </summary>
        </member>
        <member name="M:NFX.App.UniversalTimeToLocalizedTime(System.DateTime)">
            <summary>
            Converts universal time to local time as of TimeLocation property
            </summary>
        </member>
        <member name="M:NFX.App.LocalizedTimeToUniversalTime(System.DateTime)">
            <summary>
            Converts localized time to universal time as of TimeLocation property
            </summary>
        </member>
        <member name="P:NFX.App.MemoryModel">
            <summary>
            Returns the memory utilization model for the application.
            This property is NOT configurable. It may be set at process entrypoint via a call to
            App.SetMemoryModel() before the app contrainer spawns.
            Typical applications should not change the defaults.
            Some system service providers examine this property to allocate less cache and temp buffers
            in the memory-constrained environments
            </summary>
        </member>
        <member name="P:NFX.App.Session">
            <summary>
            Returns current session, this is a shortuct to ExecutionContext.Session
            </summary>
        </member>
        <member name="P:NFX.App.InstanceID">
            <summary>
            Returns unique identifier of this running instance
            </summary>
        </member>
        <member name="P:NFX.App.StartTime">
            <summary>
            Returns timestamp when application started as localized app time
            </summary>
        </member>
        <member name="P:NFX.App.Available">
            <summary>
            Returns true when application container is active non-NOPApplication instance
            </summary>
        </member>
        <member name="P:NFX.App.Active">
            <summary>
            Returns true when application instance is active and working. This property returns false as soon as application finalization starts on shutdown
            Use to exit long-running loops and such
            </summary>
        </member>
        <member name="P:NFX.App.Log">
            <summary>
            References app log
            </summary>
        </member>
        <member name="P:NFX.App.Instrumentation">
            <summary>
            References instrumentation for this application instance
            </summary>
        </member>
        <member name="P:NFX.App.Throttling">
            <summary>
            References throttling for this application instance
            </summary>
        </member>
        <member name="P:NFX.App.ConfigRoot">
            <summary>
            References application configuration root
            </summary>
        </member>
        <member name="P:NFX.App.DataStore">
            <summary>
            References application data store
            </summary>
        </member>
        <member name="P:NFX.App.ObjectStore">
            <summary>
            References object store that may be used to persist object graphs between volatile application shutdown cycles
            </summary>
        </member>
        <member name="P:NFX.App.Glue">
            <summary>
            References glue implementation that may be used to "glue" remote instances/processes/contracts together
            </summary>
        </member>
        <member name="P:NFX.App.SecurityManager">
            <summary>
            References security manager that performs user authentication based on passed credentials and other security-related global tasks
            </summary>
        </member>
        <member name="P:NFX.App.TimeSource">
            <summary>
            References time source - an entity that supplies local and UTC times. The concrete implementation
             may elect to get accurate times from the network or other external precision time sources (i.e. NASA atomic clock)
            </summary>
        </member>
        <member name="P:NFX.App.EventTimer">
            <summary>
            References event timer that maintains and runs scheduled Event instances
            </summary>
        </member>
        <member name="P:NFX.App.Name">
            <summary>
            Returns application name
            </summary>
        </member>
        <member name="P:NFX.App.EnvironmentName">
            <summary>
            Returns environment name
            </summary>
        </member>
        <member name="P:NFX.App.TimeLocation">
            <summary>
            Returns the location
            </summary>
        </member>
        <member name="P:NFX.App.LocalizedTime">
            <summary>
            Returns current time localized per TimeLocation
            </summary>
        </member>
        <member name="P:NFX.App.CurrentCallUser">
            <summary>
            Returns the current call context user
            </summary>
        </member>
        <member name="T:NFX.App.MemoryUtilizationModel">
            <summary>
            Denotes memory utilization modes
            </summary>
        </member>
        <member name="F:NFX.App.MemoryUtilizationModel.Regular">
            <summary>
            The application may use memory in a regular way without restraints
            </summary>
        </member>
        <member name="F:NFX.App.MemoryUtilizationModel.Compact">
            <summary>
            The application must try to use memory sparingly and not allocate large cache and buffers.
            This mode is typically used in a constrained 32bit apps and smaller servers
            </summary>
        </member>
        <member name="F:NFX.App.MemoryUtilizationModel.Tiny">
            <summary>
            The application must try not to use extra memory for caches and temp buffers.
            This mode is typically used in a constrained 32bit apps and smaller servers.
            Thsi mode is stricter than Compact
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.BaseSession">
            <summary>
            Implements base ISession  functionality
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.ISession">
            <summary>
            Describes user session
            </summary>
        </member>
        <member name="T:NFX.IEndableInstance">
            <summary>
            Describes an entity that can request some hosting container to end its lifetime by calling End() method
            </summary>
        </member>
        <member name="M:NFX.IEndableInstance.End">
            <summary>
            Requests container that hosts.runs this entity to end its instance
            </summary>
        </member>
        <member name="P:NFX.IEndableInstance.IsEnded">
            <summary>
            Indicates whether this instance was requested to be ended and will get destoyed by the hosting container
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ISession.Acquire">
            <summary>
            Acquires session for use
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ISession.Release">
            <summary>
            Releases session after use
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ISession.HasJustLoggedIn(NFX.ApplicationModel.SessionLoginType)">
            <summary>
            Sets IsJustLoggedIn to true to indicate that user has supplied credentials/got checked via security manager.
            The caller of this method is implementation-specific and depends on what is considered to be "proof of users' identity"
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ISession.RegenerateID">
            <summary>
            Generates new GUID and stores it in ID storing old ID value in OldID property which is not serializable.
            The implementations may elect to re-stow the existing session under the new ID.
            This method is usefull for security, i.e. when user logs-in we may want to re-generate ID
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ISession.ID">
            <summary>
            Gets unique session identifier
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ISession.User">
            <summary>
            References a user this session is for
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ISession.LanguageISOCode">
            <summary>
            Returns user's language preference or null
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ISession.IsNew">
            <summary>
            Indicates that session object was just created with current request processing cycle
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ISession.IsJustLoggedIn">
            <summary>
            Indicates that user login happened in current request processing cycle. This flag is
            useful for long term token assignment on release
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ISession.LastLoginUTC">
            <summary>
            Returns the UTC DateTime of the last login/when HasJustLoggedIn() was called for the last time within the lifetime of this session object or NULL
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ISession.LastLoginType">
            <summary>
            Returns last login type
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ISession.Items">
            <summary>
            References item dictionary that may be used to persist object graphs per session
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ISession.Item(System.Object)">
            <summary>
            Shortcut to this.Items.TryGetValue(...). Returns null if key is not found
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ISession.OldID">
            <summary>
            When this parameter is not null then RegenerateID() was called and session provider may need to re-stow session object under a new ID
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.BaseSession.HasJustLoggedIn(NFX.ApplicationModel.SessionLoginType)">
            <summary>
            Called from business code when user supplies login credentals and/or performs another action
            that can be qualified as a reliable user identity proof
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.BaseSession.RegenerateID">
            <summary>
            Generates new GUID and stores it in ID storing old ID value in OldID property which is not serializable.
            The implementations may elect to re-stow the existing session under the new ID.
            This method is usefull for security, i.e. when user logs-in we may want to re-generate ID
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.BaseSession.End">
            <summary>
            Ends session
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.ID">
            <summary>
            Returns Session ID
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.IDSecret">
            <summary>
            Returns Session ID secret - the ulong that identifies this session.
            This property is needed for cross-check upon GUID id lookup, so that
            Session ID GUID can not be forged by the client - a form of a "password"
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.OldID">
            <summary>
            When this parameter is not null then RegenerateID() was called and session provider may need to re-stow session object under a new ID
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.IsNew">
            <summary>
            Indicates that session object was just created with current request processing cycle
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.IsJustLoggedIn">
            <summary>
            Indicates that user login happened in current request processing cycle. This flag is
            useful for long term token assignment on release
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.LastLoginUTC">
            <summary>
            Returns the UTC DateTime of the last login/when HasJustLoggedIn() was called for the last time within the lifetime of this session object or NULL
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.LastLoginType">
            <summary>
            Returns the last login type
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.IsEnded">
            <summary>
            Indicates whether this session was ended and will be destroyed after current request processing cycle
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.User">
            <summary>
            Returns session user
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.LanguageISOCode">
            <summary>
            Returns user language preference or null
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.Items">
            <summary>
            Provides a thread-safe dictionary of items
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.BaseSession.Item(System.Object)">
            <summary>
            Shortcut to .Items. Getter return null instead of throwing if key is not found
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.CommonApplicationLogic">
            <summary>
            Provides base implementation of IApplication for various application kinds
            </summary>
        </member>
        <member name="T:NFX.DisposableObject">
            <summary>
            General-purpose base class for objects that need to be disposed
            </summary>
        </member>
        <member name="M:NFX.DisposableObject.DisposeAndNull``1(``0@)">
            <summary>
            Checks to see if the IDisposable reference is not null and sets it to null in a thread-safe way then calls Dispose().
            Returns false if it is already null or not the original reference
            </summary>
        </member>
        <member name="M:NFX.DisposableObject.Destructor">
            <summary>
            Override this method to do actual destructor work
            </summary>
        </member>
        <member name="M:NFX.DisposableObject.EnsureObjectNotDisposed">
            <summary>
            Checks to see whether object dispose started or has already been disposed and throws an exception if Dispose() was called
            </summary>
        </member>
        <member name="M:NFX.DisposableObject.Dispose">
            <summary>
            Deterministically disposes object. DO NOT OVERRIDE this method, override Destructor() instead
            </summary>
        </member>
        <member name="P:NFX.DisposableObject.DisposeStarted">
            <summary>
            Indicates whether this object Dispose() has been called and dispose started but not finished yet
            </summary>
        </member>
        <member name="P:NFX.DisposableObject.Disposed">
            <summary>
            Indicates whether this object was already disposed - the Dispose() has finished
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.IApplication">
            <summary>
            Describes general application model - usually a dependency injection container
             that governs application initialization, state management, logging etc...
            An applications is usually implemented with a singleton class that has static
             conduits to instance properties. Applications may be passed by reference (hence this interface)
              to simplify mocking that otherwise (in case of static-only class) would have been impossible
            </summary>
        </member>
        <member name="T:NFX.INamed">
            <summary>
            Denotes an entity that has a Name property.
            This interface is primarily used with Registry[INamed] class that allows for
             string-based addressing (getting instances by object instance name).
            The names are ideal for many system functions, like naming components in configs and admin tools
            </summary>
        </member>
        <member name="T:NFX.Time.ILocalizedTimeProvider">
            <summary>
            Describes an entity that provides the localized time
            </summary>
        </member>
        <member name="M:NFX.Time.ILocalizedTimeProvider.UniversalTimeToLocalizedTime(System.DateTime)">
            <summary>
            Converts universal time to local time as of TimeLocation property
            </summary>
        </member>
        <member name="M:NFX.Time.ILocalizedTimeProvider.LocalizedTimeToUniversalTime(System.DateTime)">
            <summary>
            Converts localized time to UTC time as of TimeLocation property
            </summary>
        </member>
        <member name="P:NFX.Time.ILocalizedTimeProvider.TimeLocation">
            <summary>
            Returns the location
            </summary>
        </member>
        <member name="P:NFX.Time.ILocalizedTimeProvider.LocalizedTime">
            <summary>
            Returns current time localized per TimeLocation
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.IApplication.Stop">
            <summary>
            Initiates the stop of the application by setting its Stopping to true and Active to false so dependent services may start to terminate
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.IApplication.MakeNewSessionInstance(System.Guid,NFX.Security.User)">
            <summary>
            Factory method that creates new session object suitable for partcular application type
            </summary>
            <param name="sessionID">Session identifier</param>
            <param name="user">Optional user object that the session is for</param>
            <returns>New session object</returns>
        </member>
        <member name="M:NFX.ApplicationModel.IApplication.RegisterConfigSettings(NFX.Environment.IConfigSettings)">
            <summary>
            Registers an instance of IConfigSettings with application container to receive a call when
             underlying app configuration changes
            </summary>
            <returns>True if settings instance was not found and was added</returns>
        </member>
        <member name="M:NFX.ApplicationModel.IApplication.UnregisterConfigSettings(NFX.Environment.IConfigSettings)">
            <summary>
            Removes the registration of IConfigSettings from application container
            </summary>
            <returns>True if settings instance was found and removed</returns>
        </member>
        <member name="M:NFX.ApplicationModel.IApplication.NotifyAllConfigSettingsAboutChange">
            <summary>
            Forces notification of all registered IConfigSettings-implementers about configuration change
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.IApplication.RegisterAppFinishNotifiable(NFX.ApplicationModel.IApplicationFinishNotifiable)">
            <summary>
            Registers an instance of IApplicationFinishNotifiable with application container to receive a call when
             underlying application instance will finish its lifecycle.
            </summary>
            <returns>True if notifiable instance was not found and was added</returns>
        </member>
        <member name="M:NFX.ApplicationModel.IApplication.UnregisterAppFinishNotifiable(NFX.ApplicationModel.IApplicationFinishNotifiable)">
            <summary>
            Removes the registration of IApplicationFinishNotifiable from application container
            </summary>
            <returns>True if notifiable instance was found and removed</returns>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.IsUnitTest">
            <summary>
            True if app is launched as a unit test as set by the app config "unit-test=true"
            The general use of this flag is discouraged as code cnstructs should not form special cases just for unit testing,
            however in some cases this flag is usefull. It is not exposed via App. static accessors
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.EnvironmentName">
            <summary>
            Provides access to "environment-name" attribute
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.InstanceID">
            <summary>
            Returns unique identifier of this running instance
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.StartTime">
            <summary>
            Returns timestamp when application started as localized app time
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.Active">
            <summary>
            Returns true when application instance is active and working. This property returns false as soon as application finalization starts on shutdown or Stop() was called
            Use to exit long-running loops and such
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.Stopping">
            <summary>
            Returns true after Stop() was called
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.ShutdownStarted">
            <summary>
            Returns true after Dispose() was called to indicate that application is shutting down
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.Log">
            <summary>
            References app log
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.Instrumentation">
            <summary>
            References instrumentation for this application instance
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.Throttling">
            <summary>
            References throttling for this application instance
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.ConfigRoot">
            <summary>
            References application configuration root
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.DataStore">
            <summary>
            References application data store
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.ObjectStore">
            <summary>
            References object store that may be used to persist object graphs between volatile application shutdown cycles
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.Glue">
            <summary>
            References glue implementation that may be used to "glue" remote instances/processes/contracts together
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.SecurityManager">
            <summary>
            References security manager that performs user authentication based on passed credentials and other security-related global tasks
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.TimeSource">
            <summary>
            References time source - an entity that supplies local and UTC times. The concrete implementation
             may elect to get accurate times from the network or other external precision time sources (i.e. NASA atomic clock)
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplication.EventTimer">
            <summary>
            References event timer - an entity that maintains and runs scheduled instances of Event
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.Stop">
            <summary>
            Initiates the stop of the application by setting its Stopping to true and Active to false so dependent services may start to terminate
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.UniversalTimeToLocalizedTime(System.DateTime)">
            <summary>
            Converts universal time to local time as of TimeLocation property
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.LocalizedTimeToUniversalTime(System.DateTime)">
            <summary>
            Converts localized time to UTC time as of TimeLocation property
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.MakeNewSessionInstance(System.Guid,NFX.Security.User)">
            <summary>
            Makes BaseSession instance
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.RegisterConfigSettings(NFX.Environment.IConfigSettings)">
            <summary>
            Registers an instance of IConfigSettings with application container to receive a call when
             underlying app configuration changes
            </summary>
            <returns>True if settings instance was not found and was added</returns>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.UnregisterConfigSettings(NFX.Environment.IConfigSettings)">
            <summary>
            Removes the registration of IConfigSettings from application container
            </summary>
            <returns>True if settings instance was found and removed</returns>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.NotifyAllConfigSettingsAboutChange">
            <summary>
            Forces notification of all registered IConfigSettings-implementers about configuration change
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.RegisterAppFinishNotifiable(NFX.ApplicationModel.IApplicationFinishNotifiable)">
            <summary>
            Registers an instance of IApplicationFinishNotifiable with application container to receive a call when
             underlying application instance will finish its lifecycle
            </summary>
            <returns>True if notifiable instance was not found and was added</returns>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.UnregisterAppFinishNotifiable(NFX.ApplicationModel.IApplicationFinishNotifiable)">
            <summary>
            Removes the registration of IConfigSettings from application container
            </summary>
            <returns>True if notifiable instance was found and removed</returns>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.PreloadAssemblies(System.Boolean)">
            <summary>
            RESERVED for future use. Loads assemblies specified in 'preload-assemblies' section from disk optionally checking the 'enabled' flag.
            This method is called on application startup by the framework
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.GetDefaultEntryPointConfigFileName">
            <summary>
            Tries to find a configuration file name looping through various supported estensions
            </summary>
            <returns>File name that exists or empty string</returns>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.NotifyAllConfigSettingsAboutChange(NFX.Environment.IConfigSectionNode)">
            <summary>
            Forces notification of all registered IConfigSettings-implementers about configuration change
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.BeforeLogStart(NFX.Log.ILogImplementation)">
            <summary>
            Override to prep log implementation i.e. inject log destinations programmaticaly
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.BeforeInstrumentationStart(NFX.Instrumentation.IInstrumentationImplementation)">
            <summary>
            Override to prep instr implementation i.e. inject something programmaticaly
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.BeforeThrottlingStart(NFX.Throttling.IThrottlingImplementation)">
            <summary>
            Override to prep throttling implementation i.e. inject something programmaticaly
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.BeforeDataStoreStart(NFX.DataAccess.IDataStoreImplementation)">
            <summary>
            Override to prep data store implementation i.e. inject something programmaticaly
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.BeforeObjectStoreStart(NFX.ApplicationModel.Volatile.IObjectStoreImplementation)">
            <summary>
            Override to prep object store implementation i.e. inject something programmaticaly
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.BeforeGlueStart(NFX.Glue.IGlueImplementation)">
            <summary>
            Override to prep glue implementation i.e. inject something programmaticaly
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.BeforeSecurityManagerStart(NFX.Security.ISecurityManagerImplementation)">
            <summary>
            Override to prep security manager implementation i.e. inject something programmaticaly
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.BeforeTimeSourceStart(NFX.Time.ITimeSourceImplementation)">
            <summary>
            Override to prep time source implementation i.e. inject something programmaticaly
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.CommonApplicationLogic.BeforeEventTimerStart(NFX.Time.IEventTimerImplementation)">
            <summary>
            Override to prep event timer implementation i.e. inject something programmaticaly
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.InstanceID">
            <summary>
            Returns unique identifier of this running instance
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.StartTime">
            <summary>
            Returns timestamp when application started as localized app time
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.Name">
            <summary>
            Returns the name of this application
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.Active">
            <summary>
            Returns true when application instance is active and working. This property returns false as soon as application finalization starts on shutdown
            Use to exit long-running loops and such
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.Stopping">
            <summary>
            Returns true to indicate that Stop() was called
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.ShutdownStarted">
            <summary>
            Returns true to indicate that Dispose() has been called and shutdown has started
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.Log">
            <summary>
            References application logger
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.Instrumentation">
            <summary>
            References application instrumentation
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.Throttling">
            <summary>
            References application throttling
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.ConfigRoot">
            <summary>
            Provides access to configuration root for the whole application
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.DataStore">
            <summary>
            References application data store
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.ObjectStore">
            <summary>
            References application object store. Objects will survive application termination
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.Glue">
            <summary>
            References glue that can be used to interconnect remote instances
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.SecurityManager">
            <summary>
            References security manager that performs user authentication based on passed credentials and other security-related global tasks
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.TimeSource">
            <summary>
            References time source - an entity that supplies local and UTC times. The concrete implementation
             may elect to get accurate times from the network or other external precision time sources (i.e. NASA atomic clock)
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.EventTimer">
            <summary>
            References event timer which maintains and runs scheduled Event instances
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.TimeLocation">
            <summary>
            Returns time location of this LocalizedTimeProvider implementation
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.CommonApplicationLogic.LocalizedTime">
            <summary>
            Returns current time localized per TimeLocation
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.IApplicationComponent">
            <summary>
            Provides marker contract requirement for an ApplicationComponent.
            This interface must be implemented only by ApplicationComponent class
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplicationComponent.ComponentSID">
            <summary>
            Returns process/instance unique app component system id
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplicationComponent.ComponentDirector">
            <summary>
            Returns a reference to an object that this app component services/operates under, or null
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplicationComponent.ComponentCommonName">
            <summary>
            Returns the common name used to identify the component, for example "Glue" for various IGlue implementations.
            This name is searched-by some management tools that allow to find component by this name that does not change between
            application restarts like ComponentSID does. Subordinate (non-root) components return null
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.ApplicationComponent">
            <summary>
            An abstraction of a disposable application component - major implementation/functionality part of an app.
            Components logically subdivide application container so their instances may be discovered
             by other parties, for example: one may iterate over all components in an application that support instrumentation and logging.
             Services are sub-types of components.
            Use "ApplicationComponent.AllComponents" to access all components in the container
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ApplicationComponent.GetAppComponentBySID(System.UInt64)">
            <summary>
            Looks-up an existing application component instance by its ComponentSID or null
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ApplicationComponent.GetAppComponentByCommonName(System.String)">
            <summary>
            Looks-up an existing application component instance by its ComponentCommonName or null. The search is case-insensitive
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ApplicationComponent.AllComponents">
            <summary>
            Returns a thread-safe enumerable( a snapshot) of all known component instances
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ApplicationComponent.ComponentSID">
            <summary>
            Returns process/instance unique app component system id
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ApplicationComponent.ComponentStartTime">
            <summary>
            Returns local computer time of component start (not from application container time)
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ApplicationComponent.ComponentCommonName">
            <summary>
            Returns the common name used to identify the component, for example "Glue" for various IGlue implementations.
            This name is searched-by some management tools that allow to find component by this name that does not change between
            application restarts like ComponentSID does. Subordinate (non-root) components return null
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ApplicationComponent.ComponentDirector">
            <summary>
            Returns a reference to an object that this app component services/operates under, or null
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.ExecutionContext">
            <summary>
            Provides access to execution context - an entity that groups Request, Response and Session object.
            This class has nothing to do with Web. Execution contexts are supported as easily in console, service, web,  and Windows forms apps.
             All objects may be either application-global or thread level. This class is useful for technology-agnostic implementations
            of Record Models i.e. in a Record class one may write:  " if (ExecutionContext.Session.User.Kind==UserKind.Administrator)..."
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ExecutionContext.__SetApplicationLevelContext(NFX.ApplicationModel.IApplication,System.Object,System.Object,NFX.ApplicationModel.ISession)">
            <summary>
            Internal framework-only method to bind application-level context
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ExecutionContext.__SetThreadLevelContext(System.Object,System.Object,NFX.ApplicationModel.ISession)">
            <summary>
            Internal framework-only method to bind thread-level context
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ExecutionContext.__SetThreadLevelSessionContext(NFX.ApplicationModel.ISession)">
            <summary>
            Internal framework-only method to bind thread-level context
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ExecutionContext.Application">
            <summary>
            Returns global application context
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ExecutionContext.Request">
            <summary>
            Returns Request object for current thread, or if it is null, app-global-level object is returned
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ExecutionContext.Response">
            <summary>
            Returns Response object for current thread, or if it is null, app-global-level object is returned
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ExecutionContext.Session">
            <summary>
            Returns Session object for current thread, or if it is null, app-global-level object is returned
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ExecutionContext.HasThreadContextSession">
            <summary>
            Returns true when thread-level session object is available and not a NOPSession instance
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.IApplicationStarter">
            <summary>
            Represents an entity that performs work on application start.
            This entity must be either invoked directly or declared in config file under "starters" section
            </summary>
        </member>
        <member name="T:NFX.Environment.IConfigurable">
            <summary>
            Designates entities that may be configured
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigurable.Configure(NFX.Environment.IConfigSectionNode)">
            <summary>
            Configures an entity from supplied config node
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.IApplicationStarter.ApplicationStartBreakOnException">
            <summary>
            Indicates whether an exception that leaks from starter method invocation should break the application start,
             or just get logged
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.IApplicationFinishNotifiable">
            <summary>
            Represents an entity that can get notified about application finish
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.NOPSession">
            <summary>
            Represents a session that does nothing and returns fake user
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.NOPSession.Instance">
            <summary>
            Returns a singlelton instance of the NOPSession
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.CacheExtensions">
            <summary>
            Provides read/write-through extensions
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.CacheExtensions.FetchFrom``2(NFX.ApplicationModel.Pile.ICache,``0,System.String,NFX.DataAccess.CRUD.ICacheParams,System.Boolean@)">
            <summary>
            Fetches an existing item from cache or null. IsAbsent is true when data was read from cache as an AbsentValue
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.CacheExtensions.FetchThrough``2(NFX.ApplicationModel.Pile.ICache,``0,System.String,NFX.DataAccess.CRUD.ICacheParams,System.Func{``0,``1},System.Func{``0,``1,``1})">
            <summary>
            Fetches an item through cache
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Piled`1">
            <summary>
            Represents a PilePointer scoped by PileID. PileID uniquelly identifies the pile on the pointed-to machine.
            Piled is used for deferred load/deserialization from pile. This is a useful optimization technique for tree serialization,
            on deserialization Piled is returned, without having to deserialize the whole sub-graph of objects.
            Upon the first access to Pile.Value the Get from pile takes place transparently.
            When writing to pile, the Piled instance is written as a separate Pile entity with a distinct pointer
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.Piled`1.#ctor(System.Int32,NFX.ApplicationModel.Pile.PilePointer)">
            <summary>
            Creates distributed pointer
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.Piled`1.PileID">
            <summary>
            PileID uniquely identifies Pile instance on this or remote machine (if Pointer is distributed)
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.Piled`1.Pointer">
            <summary>
            Pointer within the pile identoified by PileID
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.Piled`1.Invalid">
            <summary>
            Returns a -1:-1 non-valid pointer (either local or distributed)
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.Piled`1.Valid">
            <summary>
            Returns true if PileID and Pointer hold values, however this does not mean that pointed-to data exists
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.MMFPile">
            <summary>
            Provides default implementation of IPile which stores objects in Memory Mapped Files
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.DefaultPileBase">
            <summary>
            Provides base for default implementation of IPile which stores objects on a local machine in memory or in the MMF
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.ServiceWithInstrumentationBase`1">
            <summary>
            Provides base implementation for Service with IInstrumentable logic
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.Service`1">
            <summary>
            Represents service with typed ComponentDirector property
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.Service">
            <summary>
            Represents a lightweight service that can be controlled by Start/SignalStop-like commands.
            This class serves a a base for various implementations (i.e. LogService) including their composites.
            This class is thread-safe
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.IService">
            <summary>
            Defines abstraction for an entity that is controlled by Start/Stop commands and has a status
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.IService.Start">
            <summary>
            Blocking call that starts the service instance
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.IService.SignalStop">
            <summary>
            Non-blocking call that initiates the stopping of the service
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.IService.CheckForCompleteStop">
            <summary>
            Non-blocking call that returns true when the service instance has completely stopped after SignalStop()
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.IService.WaitForCompleteStop">
            <summary>
            Blocks execution of current thread until this service has completely stopped
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.IService.Status">
            <summary>
            Current service status
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.IService.Running">
            <summary>
            Returns true when service is active or about to become active.
            Check in service implementation loops/threads/tasks
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.Configure(NFX.Environment.IConfigSectionNode)">
            <summary>
            Configures service from configuration node (and possibly it's sub-nodes)
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.StartByApplication">
            <summary>
            Blocking call that starts the service instance
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.Start">
            <summary>
            Blocking call that starts the service instance
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.SignalStop">
            <summary>
            Non-blocking call that initiates the stopping of the service
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.CheckForCompleteStop">
            <summary>
            Non-blocking call that returns true when the service instance has completely stopped after SignalStop()
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.WaitForCompleteStop">
            <summary>
            Blocks execution of current thread until this service has completely stopped.
            This call must be performed by only 1 thread otherwise exception is thrown
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.AcceptManagerVisit(System.Object,System.DateTime)">
            <summary>
            Accepts a visit of a manager entity - this call is useful for periodic updates of service status,
            i.e.  when service does not have a thread of its own it can be periodically managed by some other service through this method.
            The default implementation of DoAcceptManagerVisit(object, DateTime) does nothing
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.UniversalTimeToLocalizedTime(System.DateTime)">
            <summary>
            Converts universal time to local time as of TimeLocation property
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.LocalizedTimeToUniversalTime(System.DateTime)">
            <summary>
            Converts localized time to UTC time as of TimeLocation property
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.AbortStart">
            <summary>
            Allows to abort unsuccessful DoStart() overridden implementation.
            This method must be called from within DoStart()
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.DoStart">
            <summary>
            Provides implementation that starts the service
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.DoSignalStop">
            <summary>
            Provides implementation that signals service to stop. This is expected not to block
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.DoCheckForCompleteStop">
            <summary>
            Provides implementation for checking whether the service has completely stopped
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.DoWaitForCompleteStop">
            <summary>
            Provides implementation for a blocking call that returns only after a complete service stop
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.DoConfigure(NFX.Environment.IConfigSectionNode)">
            <summary>
            Provides implementation that configures service from configuration node (and possibly it's sub-nodes)
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.CheckServiceInactive">
            <summary>
            Checks for service inactivity and throws exception if service is running (started, starting or stopping)
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.CheckServiceActive">
            <summary>
            Checks for service activity and throws exception if service is not in ControlStatus.Active state
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.CheckServiceActiveOrStarting">
            <summary>
            Checks for service activity and throws exception if service is not in ControlStatus.Active state
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.DoAcceptManagerVisit(System.Object,System.DateTime)">
            <summary>
            Accepts a visit from external manager. Base implementation does nothing.
             Override in services that need external management calls
              to update their state periodically, i.e. when they don't have a thread on their own
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.Service.____ObtainPrivateServiceStatusLockObject">
            <summary>
            WARNING: Developers never call this method!!!
            It is used by advanced derived implementations that need to synchronize status updates.
            We do not want to make statuslock protected as it is almost never needed, hence this accessor
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.Service.ApplicationDontAutoStartService">
            <summary>
            Checks whether the class is decorated with ApplicationDontAutoStartServiceAttribute
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.Service.Status">
            <summary>
            Current service status
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.Service.Running">
            <summary>
            Returns true when service is active or about to become active.
            Check in service implementation loops/threads/tasks
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.Service.Name">
            <summary>
            Provides textual name for the service
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.Service.TimeLocation">
            <summary>
            Returns time location of this LocalizedTimeProvider implementation
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.Service.LocalizedTime">
            <summary>
            Returns current time localized per TimeLocation
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IInstrumentable">
            <summary>
            Denotes an entity that can be instrumented
            </summary>
        </member>
        <member name="T:NFX.IExternallyParameterized">
            <summary>
            Denotes an entity that has external parameters that can be get/set
            </summary>
        </member>
        <member name="M:NFX.IExternallyParameterized.ExternalParametersForGroups(System.String[])">
            <summary>
            Gets names of supported external parameters or null if parameters are not supported in principle
            </summary>
        </member>
        <member name="M:NFX.IExternallyParameterized.ExternalGetParameter(System.String,System.Object@,System.String[])">
            <summary>
            Gets external parameter value returning true if parameter was found
            </summary>
        </member>
        <member name="M:NFX.IExternallyParameterized.ExternalSetParameter(System.String,System.Object,System.String[])">
            <summary>
            Sets external parameter value, true if parameter name was found and set succeeded
            </summary>
        </member>
        <member name="P:NFX.IExternallyParameterized.ExternalParameters">
            <summary>
            Gets names/types of supported external parameters or null if parameters are not supported in principle
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.IInstrumentable.InstrumentationEnabled">
            <summary>
            Turns on/off instrumentation
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.ServiceWithInstrumentationBase`1.ExternalParametersForGroups(System.String[])">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.ServiceWithInstrumentationBase`1.ExternalGetParameter(System.String,System.Object@,System.String[])">
            <summary>
            Gets external parameter value returning true if parameter was found
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.ServiceWithInstrumentationBase`1.ExternalSetParameter(System.String,System.Object,System.String[])">
            <summary>
            Sets external parameter value returning true if parameter was found and set
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.ServiceWithInstrumentationBase`1.InstrumentationEnabled">
            <summary>
            Turns instrumentation on/off
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.ServiceWithInstrumentationBase`1.ExternalParameters">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.IPile">
            <summary>
            Represents a pile of objects - a custom memory heap that can store native CLR objects in a tightly-serialized form.
            Piles can be either local (allocate local RAM on the server), or distributed (allocate RAM on many servers).
            This class is designed primarily for applications that need to store/cache very many
            (100s of millions on local, billions on distributed) of objects in RAM (and/or possibly on disk) without causing
            the local CLR's GC scans of huge object graphs.
            Implementors of this interface are custom memory managers that favor the GC performance in apps with many objects at
            the cost of higher CPU usage. The implementor must be thread-safe for all operations unless stated otherwise on a member level.
            The memory represented by this class as a whole is not synchronizable, that is - it does not support functions like
            Interlocked-family, Lock, MemoryBarriers and the like that regular RAM supports. Should a need arise to interlock within the pile -
            a custom CLR-based lock must be used to syncronize access to pile as a whole, for example:
              a Get does not impose a lock on ALL concurrent writes throught the pile (a write does not block all gets either).
            The enumeration of the pile is thread-safe, however it does not guarantee the snapshot stability as parallel mutations may happen while enumeration takes place.
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.IPileStatus">
            <summary>
            Provides information about the pile - number of objects, allocated bytes, etc.
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.Identity">
            <summary>
            Returns a node-global ID of this pile instance
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.Locality">
            <summary>
            Returns whether pile is local or distributed
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.Persistence">
            <summary>
            Returns the model of object persistence that this pile supports
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.SupportsObjectExpiration">
            <summary>
            Returns whether this instance supports object expiration
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.ObjectCount">
            <summary>
            Returns the number of allocated objects in this pile
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.ObjectLinkCount">
            <summary>
            Returns the number of allocated object links in this pile.
            Links are used to chain existing location to another one when larger payload does not fit
            at the progonal location
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.AllocatedMemoryBytes">
            <summary>
            Returns the number of bytes allocated by this pile from system memory
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.MemoryCapacityBytes">
            <summary>
            Returns an approximate capacity of free memory that the system has left
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.UtilizedBytes">
            <summary>
            Returns the number of bytes allocated for object storage within AllocatedMemoryBytes
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.OverheadBytes">
            <summary>
            Returns the number of extra bytes used by pile metadata currently occupied by object stored in this pile
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.SegmentCount">
            <summary>
            Returns the number of segments allocated
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileStatus.NodeCount">
            <summary>
            Returns the number of nodes(servers) that service this distributed pile.
            If this pile locality is local then returns 1
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.IPile.Put(System.Object,System.UInt32,System.Int32)">
            <summary>
            Puts a CLR object into the pile and returns a newly-allocated pointer.
            Throws out-of-space if there is not enough space in the pile and limits are set.
            Optionally takes lifeSpan (if Pile supports it) and extra preallocation bytes
            </summary>
            <param name="obj">CLR object to put into the Pile</param>
            <param name="lifeSpanSec">
             Optional lifeSpanSec will auto-delete object after the interval elapses if
             the pile SupportsObjectExpiration and SweepExpiredObjects is set to true
            </param>
            <param name="preallocateBlockSize">
            When specified, adds extra space to the allocated block so that the object can be changed in-place
            without creating the link. Specifies the total size of the block in bytes. If this size is less than
            actual object payload then allocates the block of the payload size
            </param>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.IPile.Put(NFX.ApplicationModel.Pile.PilePointer,System.Object,System.UInt32,System.Boolean)">
            <summary>
            Tries to put the new object over an existing one at the pre-define position.
            The pointer has to reference a valid allocated block.
            If object fits in the allocated block returns true, otherwise tries to create an internal link
            to the new pointer which is completely transparent to the caller. The linking may be explicitly disabled
            in which case the method returns false when the new object does not fit into the existing block
            </summary>
            <param name="obj">A new/modified CLR object to put into the Pile over an existing one</param>
            <param name="lifeSpanSec">
             Optional lifeSpanSec will auto-delete object after the interval elapses if
             the pile SupportsObjectExpiration and SweepExpiredObjects is set to true
            </param>
            <param name="ptr">The pointer to the existing valid allocated block</param>
            <param name="link">False to prohibit internal pointer linking</param>
            <returns>True if object was inserted, false otherwise (i.e. when linking is false)</returns>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.IPile.Get(NFX.ApplicationModel.Pile.PilePointer)">
            <summary>
            Returns a CLR object by its pointer or throws access violation if pointer is invalid
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.IPile.GetRawBuffer(NFX.ApplicationModel.Pile.PilePointer,System.Byte@)">
            <summary>
            Returns a raw byte[] occupied by the object payload, only payload is returned along with serializer flag
            which tells what kind of serializer was used.
            This method is rarely used, it is needed for debugging and special-case "direct" memory access on read
            to bypass the de-serialization process altogether
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.IPile.Delete(NFX.ApplicationModel.Pile.PilePointer,System.Boolean)">
            <summary>
            Deletes object from pile by its pointer returning true if there is no access violation
            and pointer is pointing to the valid object, throws otherwise unless
            throwInvalid is set to false
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.IPile.Rejuvenate(NFX.ApplicationModel.Pile.PilePointer)">
            <summary>
            If pile supports expiration, resets object age to zero.
            Returns true if object was found and reset. N/A for pile that do not support expiration
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.IPile.SizeOf(NFX.ApplicationModel.Pile.PilePointer)">
            <summary>
            Returns the size of pointed-to object in bytes or throws access violation if pointer is invalid.
            The serialized object size is returned, not the CLR object size.
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.IPile.Purge">
            <summary>
            Deletes all objects freeing all segment memory buffers.
            This method may require the caller to have special rights
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.IPile.Compact">
            <summary>
            Tries to delete extra capacity which is allocated but not currently needed.
            Returns the number of bytes freed back to the system
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileImplementation.AllocMode">
            <summary>
            Defines modes of allocation: space/time tradeoff
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileImplementation.SweepExpiredObjects">
            <summary>
            Control whether the instance respects object life spans
            if they are set
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileImplementation.MaxMemoryLimit">
            <summary>
            Imposes a limit on maximum number of bytes that a pile can allocate of the system heap.
            The default value of 0 means no limit, meaning - the pile will keep allocating objects
            until the system allows
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileImplementation.MaxSegmentLimit">
            <summary>
            Gets the maximum count of segments that this pile can have.
            The property is not thread-safe for set and can only be set if pile is inactive.
            The value of zero means no limit
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.IPileImplementation.SegmentSize">
            <summary>
            Gets the segment size in bytes, up to (2^31)-1
            The property is not thread-safe for set and can only be set if pile is inactive
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.DefaultPileBase.Crawl(System.Boolean)">
            <summary>
            Analyzes all segments scanning for free spaces. Returns number of uncovered free bytes.
            This is a full-blocking long operation that may take around 8 seconds on a 64Gb heaps in non-parallel mode
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.DefaultPileBase.Put(System.Object,System.UInt32,System.Int32)">
            <summary>
            Puts a CLR object into the pile and returns a newly-allocated pointer.
            Throws out-of-space if there is not enough space in the pile and limits are set.
            Optional lifeSpanSec is ignored by this implementation
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.DefaultPileBase.Put(NFX.ApplicationModel.Pile.PilePointer,System.Object,System.UInt32,System.Boolean)">
            <summary>
            Tries to put the new object over an existing one at the pre-define position.
            The pointer has to reference a valid allocated block.
            If object fits in the allocated block returns true, otherwise tries to create an internal link
            to the new pointer which is completely transparent to the caller. The linking may be explicitly disabled
            in which case the method returns false when the new object does not fit into the existing block
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.DefaultPileBase.Get(NFX.ApplicationModel.Pile.PilePointer)">
            <summary>
            Returns a CLR object by its pointer or throws access violation if pointer is invalid
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.DefaultPileBase.GetRawBuffer(NFX.ApplicationModel.Pile.PilePointer,System.Byte@)">
            <summary>
            Returns a raw byte[] occupied by the object payload, only payload is returned along with serializer flag
            which tells what kind of serializer was used.
            This method is rarely used, it is needed for debugging and special-case "direct" memory access on read
            to bypass the de-serialization process altogether
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.DefaultPileBase.get(NFX.ApplicationModel.Pile.PilePointer,System.Boolean,System.Byte@)">
            <summary>
            Returns a CLR object by its pointer or throws access violation if pointer is invalid
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.DefaultPileBase.Delete(NFX.ApplicationModel.Pile.PilePointer,System.Boolean)">
            <summary>
            Deletes object from pile by its pointer returning true if there is no access violation
            and pointer is pointing to the valid object, throws otherwise unless
            throwInvalid is set to false
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.DefaultPileBase.MakeSegment(System.Int32)">
            <summary>
            Override to make segmnet backed by the appropriate memory technology
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.Identity">
            <summary>
            When set to value greater than zero, provides a process-unique identity of the pile instance.
            The property must be set to unique value in order to start the pile, or set to less or equal to zero to keep the instance private.
            Used by Piled via PileInstances retrived by Identity (if greater than zero)
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.InstrumentationEnabled">
            <summary>
            Implements IInstrumentable
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.Locality">
            <summary>
            Returns PileLocality.Local
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.Persistence">
            <summary>
            Returns PilePersistence - where data is kept
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.SupportsObjectExpiration">
            <summary>
            Returns false
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.NodeCount">
            <summary>
            Returns 1 as this pile is not distributed
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.AllocMode">
            <summary>
            Defines modes of allocation: space/time tradeoff
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.FreeChunkSizes">
            <summary>
            Sets the sizes of free chunks that free lists group by.
            Must be an array of FREE_LST_COUNT(16) of consequitively increasing integers
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.FreeListSize">
            <summary>
            Determines the size of free chunk list. Every segment has FREE_LST_COUNT=16 lists each of this size.
            This property may only be set on an inactive service instance
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.MaxSegmentLimit">
            <summary>
            Gets the maximum count of segments tha this pile can have.
            The property is not thread-safe for set and can only be set if pile is inactive.
            The value of zero means no limit
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.SegmentSize">
            <summary>
            Gets the maximum segment size in bytes, up to (2^31)-1
            The property is not thread-safe for set and can only be set if pile is inactive
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.MaxMemoryLimit">
            <summary>
            Imposes a limit on maximum number of bytes that a pile can allocate of the system heap.
            The default value of 0 means no limit, meaning - the pile will keep allocating objects
            until the system allows. The value may not be less than minimum 1 seg size (64 mb).
            May set on an active instance, however no existing objects will be removed if the limit is exceeded
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.ObjectCount">
            <summary>
            Returns the total number of objects allocated at this point in time
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.ObjectLinkCount">
            <summary>
            Returns the total number of object links allocated at this point in time
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.AllocatedMemoryBytes">
            <summary>
            Returns the number of bytes allocated by this pile from the system memory heap.
            As pile pre-allocates memory in segments, it is absolutely normal to have this property
            return 100s of megabytes even when pile is almost empty.
            This property may return close to all physical memory available
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.UtilizedBytes">
            <summary>
            Returns the number of bytes currently occupied by object stored in this pile.
            This number is always less than AllocatedMemoryBytes
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.OverheadBytes">
            <summary>
            Returns the number of extra bytes used by pile metadata currently occupied by object stored in this pile
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.SegmentCount">
            <summary>
            Returns the total number of segments allocated at this point in time
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.MemoryCapacityBytes">
            <summary>
            Returns an approximate capacity of free memory that the system has left
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.SegmentTotalCount">
            <summary>
            Returns the total number of total segments - allocated and empty at this point in time.
            This number is greater or equal to SegmentCount
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase.SweepExpiredObjects">
            <summary>
            Returns false and does nothing on set in this implementation
            if they are set
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase._segment.FreeBytesChangePctSinceLastCrawl">
            <summary>
            How much %-wise more space became available since last crawl
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPileBase._segment.SnapshotOfFreeChunkCapacities">
            <summary>
            takes a snapshot of free chunk capacities for instrumentation
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.DefaultPileBase.SegmentCrawlStatus">
            <summary>
            Holds information obtained after a segment crawl
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.MMFPile.MakeSegment(System.Int32)">
            <summary>
            Creates a segment that stores data in memory mapped files
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.MMFPile.DataDirectoryRoot">
            <summary>
            Specifies the full path to directory root under which the MMFPile creates a named instance directory where the memory-mapped files are kept.
            The instance directory name is taken from Pile.Name
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.MMFPile.DataDirectory">
            <summary>
            Returns the full path root + name where the memory mapped files are kept
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.MMFPile.Persistence">
            <summary>
            Returns PilePersistence.Memory
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.MMFPile.CompletelyLoaded">
            <summary>
            Returns true when pile has completely loaded - mounted and Crawled(), from the MMF images on disk
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.PileEntry">
            <summary>
            Represents an entry stored in a pile - a pointer+size vector.
            Used for pile enumeration
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.PileEntry.Pointer">
            <summary>
            Points to data
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.PileEntry.Type">
            <summary>
            Denotes data type, i.e.: Object/String/Buffer/Link
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.PileEntry.Size">
            <summary>
            The byte size of allocation
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.MMFMemory">
            <summary>
            Represents memory backed by Memory Mapped Files (MMF)
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Memory">
            <summary>
            INTERNAL implementation detail. This class is critical for performance.
            The  methods that read integers and pile pointer in a single call are more efficient that reading byte-by-byte.
            Provides abstraction for working with raw memory chunk.
            The chunk may be a maximum of 2 Gb in size.
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.MMFMemory.GetSegmentFileNames(System.String)">
            <summary>
            Returns file names in the order of segment idex
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.MMFMemory.#ctor(System.String,System.Int32)">
            <summary>
            Mounts existing segment file
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.MMFMemory.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Mounts new segment file
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.DefaultPile">
            <summary>
            Provides default implementation of IPile which stores objects in the local machine RAM
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.DefaultPile.MakeSegment(System.Int32)">
            <summary>
            Creates a segment that stores data in local memory array byte buffers
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.DefaultPile.Persistence">
            <summary>
            Returns PilePersistence.Memory
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.LocalityKind">
            <summary>
            Indicates where pile implementation stores data: local vs distributed
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.LocalityKind.Local">
            <summary>
            The pile resides on this machine and is limited by the RAM on the local server
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.LocalityKind.Distributed">
            <summary>
            The pile is distributed - it runs across many machines
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.LocalityKind.Cluster">
            <summary>
            The pile is distributed - it runs across many machines using server cluster
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.ObjectPersistence">
            <summary>
            Denotes modes of object persistence
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.ObjectPersistence.Memory">
            <summary>
            The data is kept in memory in a format that prohibits the preservation of data between object layout changes,
             for example, the Slim serializer does not support versioning, hence this mode is beneficial for maximum performance
             of local in-process heaps
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.ObjectPersistence.UpgreadableMemory">
            <summary>
            The data is kept in memory in a format that allows to change the object structure (serialization versioning), i.e.
             a distributed node may keep objects usable even after client's software changes
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.ObjectPersistence.Disk">
            <summary>
            The data is kept on disk. The data is in object-upgreadable format (support changes of object structure)
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.ObjectPersistence.MemoryDisk">
            <summary>
            The data is kept on disk and cached in memory (i.e. memory-mapped file).
            The data is in object-upgreadable format (support changes of object structure)
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.AllocationMode">
            <summary>
            Defines modes of allocation: space/time tradeoff
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.AllocationMode.ReuseSpace">
            <summary>
            The pile will try to reuse ram at the cost of possibly slower allocations
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.AllocationMode.FavorSpeed">
            <summary>
            The pile may use more ram in some cases but allocate faster
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.PileException">
            <summary>
            Thrown by pile memory manager
            </summary>
        </member>
        <member name="T:NFX.NFXException">
            <summary>
            Base exception thrown by the framework
            </summary>
        </member>
        <member name="P:NFX.NFXException.Code">
            <summary>
            Provides general-purpose error code
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.PileAccessViolationException">
            <summary>
            Thrown by pile memory manager when a supplied PilePointer is not pointing to a valid buffer
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.PileOutOfSpaceException">
            <summary>
            Thrown by pile memory manager when there is not anough room in the pile to perform the requested operation
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.PileCacheException">
            <summary>
            Thrown by pile cache
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheLongGauge">
            <summary>
            Provides base for cache long gauges
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.PileLongGauge">
            <summary>
            Provides base for pile long gauges
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.LongGauge">
            <summary>
            Represents a general-purpose long integer measurement datum
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Gauge">
            <summary>
            Represents a base for gauges - events of measurement of some values
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Datum">
            <summary>
            Base class for single measurement events (datums) reported to instrumentation
            </summary>
        </member>
        <member name="T:NFX.Log.IArchiveLoggable">
            <summary>
            Marker interface for entities that can be stored in archives, such as access/telemetry logs
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.IBSONSerializable">
            <summary>
            Denotes entities which can write/serialize their state directly into BSONDocument
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.IBSONSerializable.IsKnownTypeForBSONDeserialization(System.Type)">
            <summary>
            Return true to state that the supplied type is known by IBSONDeserializable implementation
            and its type id should not be added to the document
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.IBSONDeserializable">
            <summary>
            Denotes entities which can read/deserialize their state directly from BSONDocument
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.IJSONWritable">
            <summary>
            Denotes a CLR type-safe entity (class or struct) that can directly write itself as JSON content string.
            This mechanism bypasses all of the reflection/dynamic code.
            This approach may be far more performant for some classes that need to serialize their state/data in JSON format,
            than relying on general-purpose JSON serializer that can serialize any type but is slower
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.IJSONWritable.WriteAsJSON(System.IO.TextWriter,System.Int32,NFX.Serialization.JSON.JSONWritingOptions)">
             <summary>
             Writes entitie's data/state as JSON string
             </summary>
            <param name="wri">
            TextWriter to write JSON content into
            </param>
             <param name="nestingLevel">
             A level of nesting that this instance is at, relative to the graph root.
             Implementations may elect to use this parameter to control indenting or ignore it
             </param>
             <param name="options">
             Writing options, such as indenting.
             Implementations may elect to use this parameter to control text output or ignore it
             </param>
        </member>
        <member name="M:NFX.Instrumentation.Datum.GetViewGroupInterfaces(System.Type)">
            <summary>
            Returns Datum classification interfaces marked with InstrumentViewGroup attribute. The implementation is cached fr efficiency
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Datum.Aggregate(System.Collections.Generic.IEnumerable{NFX.Instrumentation.Datum})">
            <summary>
            Aggregates events, for example from multiple threads into one
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Datum.ReduceSourceDetail(System.Int32)">
            <summary>
            Override to set a new source value which is less-specific than existing source.
            ReductionLevel specifies how much detail should be lost. The function is idempotent, that is - calling more than once with the same arg does not
            change the state of the object.
            The default implementation removes all source details (unspecified source) when reductionLevel less than zero.
            Example:
             TotalBytesSent("mpx://45.12.123.19:7823 -> MySystem.Contracts.IDoSomething.SomeMethod1()")
             ReduceSourceDetail(0) -> yields original string
             ReduceSourceDetail(1) - > "MySystem.Contracts.IDoSomething.SomeMethod1()"
             ReduceSourceDetail(2) - > "MySystem.Contracts.IDoSomething"
             ReduceSourceDetail(3) - > ""
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.UTCTime">
            <summary>
            Returns UTC time stamp when event happened
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.UTCEndTime">
            <summary>
            Returns UTC time stamp when event happened. This property may be gotten only if IsAggregated==true, otherwise UTCTime value is returned
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.IsAggregated">
            <summary>
            Indicates whether this instance represents a rollup/aggregation of multiple events
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.Count">
            <summary>
            Returns count of measurements. This property may be gotten only if IsAggregated==true, otherwise zero is returned
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.Source">
            <summary>
            Returns datum source. Data are rolled-up by type of recorded datum instances and source
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.Rate">
            <summary>
            Returns rate of occurrence string
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.Description">
            <summary>
            Returns description for data that this datum represents. Base implementation returns full type name of this instance
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.ValueAsObject">
            <summary>
            Provides access to value polymorphically
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.PlotValue">
            <summary>
            Provides numeric value used for charts
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.ValueUnitName">
            <summary>
            Provides name for units that value is measured in
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Datum.ViewGroupInterfaces">
            <summary>
            Returns Datum classification interfaces marked with InstrumentViewGroup attribute. The implementation is cached fr efficiency
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.LongGauge.Value">
            <summary>
            Gets gauge value
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.ICacheInstrument">
            <summary>
            Cache-related operations
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IOperationClass">
            <summary>
            A class of operations that instrument measures
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IInstrumentClass">
            <summary>
            Root marker interface for instrumentation data classification.
            Instruments are primarily classified by their derivation from Datum ancestor, however this interface-based
             scheme allows for alternate classification (a la multiple inheritance)
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IMemoryInstrument">
            <summary>
            Memory-related operations
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheDoubleGauge">
            <summary>
            Provides base for cache double gauges
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.PileDoubleGauge">
            <summary>
            Provides base for pile double gauges
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.DoubleGauge">
            <summary>
            Represents a general-purpose double measurement datum
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.DoubleGauge.Value">
            <summary>
            Gets gauge value
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheEvent">
            <summary>
            Provides base for cache events
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Event">
            <summary>
            Represents a base for events that happen so instrumentation can calculate event counts and rates of occurence
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheTableCount">
            <summary>
            Provides table count in the cache instance
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheCount">
            <summary>
            Provides object count in the cache instance
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheCapacity">
            <summary>
            Provides entry/slot count in the cache instance
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheLoadFactor">
            <summary>
            Provides load factor percentage
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CachePut">
            <summary>
            How many times put resulted in new object insertion in cache with or without overwriting the existing item
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CachePutCollision">
            <summary>
            How many times put could not insert new object in cache because there was no room and existing data could not be overwritten
             due to higher priority
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CachePutOverwrite">
            <summary>
            How many times put inserted new object in cache by overwriting existing value with lower priority
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CachePutReplace">
            <summary>
            How many times put replaced existing object in cache
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheRemoveHit">
            <summary>
            How many times key was found and object removed
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheRemoveMiss">
            <summary>
            How many times key was not found and object not removed
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheSweep">
            <summary>
            How many entries/objects were removed by sweep
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheSweepDuration">
            <summary>
            How long the sweeping took (examination + removal of expired)
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheTableSwept">
            <summary>
            Cache table was swept
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheRejuvenateHit">
            <summary>
            How many times key entry was found and its age reset to zero
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheRejuvenateMiss">
            <summary>
            How many times key entry was not found for resetting its age
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheGetHit">
            <summary>
            How many times cached object was found and gotten by its key
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheGetMiss">
            <summary>
            How many times cached object was tried to be gotten but not found by its key
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheGrew">
            <summary>
            How many times cache has to increase its capacity
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.CacheShrunk">
            <summary>
            How many times cache has to decrease its capacity
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.ObjectCount">
            <summary>
            Provides object count in the instance
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.SegmentCount">
            <summary>
            Provides segment count in the instance
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.AllocatedMemoryBytes">
            <summary>
            Number of bytes allocated by the instance from system memory
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.MemoryCapacityBytes">
            <summary>
            Average capacity of free memory that the system has left
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.UtilizedBytes">
            <summary>
            Number of bytes allocated for object storage within AllocatedMemoryBytes
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.OverheadBytes">
            <summary>
            Number of extra bytes used by pile metadata currently occupied by object stored in this pile
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.AverageObjectSizeBytes">
            <summary>
            Number of bytes for average object
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.PutCount">
            <summary>
            Count of Put() calls
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.DeleteCount">
            <summary>
            Count of Delete() calls
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.GetCount">
            <summary>
            Count of Get() calls
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Instrumentation.FreeListCapacity">
            <summary>
            Number of free clots(chunks) in the free list
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.ICache">
            <summary>
            Represents a cache of expiring objects, which are identified by a key and stored in a pile.
            Pile allows to store hundreds of millions of objects without overloading the managed GC.
            The cache may be local or distributed
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICache.GetOrCreateTable``1(System.String,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns existing table by name, if it does not exist creates a new table.
            For existing table the types must be identical to the ones used at creation
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICache.GetOrCreateTable``1(System.String,System.Boolean@,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns existing table by name, if it does not exist creates a new table.
            For existing table the types must be identical to the ones used at creation
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICache.GetTable``1(System.String)">
            <summary>
            Returns existing table by name, if it does not exist thorws.
            The TKey must correspond to existing table
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICache.PurgeAll">
            <summary>
            Removes all data from all tables stored in the cache
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICache.Locality">
            <summary>
            Returns whether the cache key:value mappings are local or distributed
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICache.Persistence">
            <summary>
            Returns the model of key:value mapping persistence that this cache supports
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICache.PileStatus">
            <summary>
            Returns the status of the pile where object are stored
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICache.Tables">
            <summary>
            Tables that this cache contains
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICache.Count">
            <summary>
            Returns how many records are kept in cache
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.CollisionMode">
            <summary>
            Defines table collision modes: Speculative (prabability-based - ignores collisions) vs Durable (works slower but handles collisions)
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.CollisionMode.Speculative">
            <summary>
            Does not do chaining/rehashing, works faster for caches but may overwrite data with lower priority
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.CollisionMode.Durable">
            <summary>
            Guarantees to store all the data and handles all key collisions at the expense of extra processing.
            Ignores priorities as they are irrelevant
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICacheTable.Purge">
            <summary>
            Removes all data from table
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheTable.Cache">
            <summary>
            References cache that this table is under
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheTable.Count">
            <summary>
            Returns how many records are kept in a table
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheTable.Capacity">
            <summary>
            Returns how many slots/entries allocated in a table
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheTable.LoadFactor">
            <summary>
            Returns the percentage of occupied table slots.
            When this number exceeds high-water-mark threshold the table is grown,
            otheriwse if the number falls below the low-water-mark level then the table is shrunk
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheTable.Options">
            <summary>
            Cache table options in effect
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheTable.CollisionMode">
            <summary>
            Determines how this instance handles collisions.
            This property can not be changed after the table was created from TableOptions.
            Changing CollisionMode in TableOptions has no effect on this property after creation
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.PutResult">
            <summary>
            Denotes statuses of cache table Put
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.PutResult.Collision">
            <summary>
            The item could not be put because it collides with existing data
            that can not be overwritten because it has higher priority and there is no extra space
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.PutResult.Inserted">
            <summary>
            The item was inserted into cache table anew
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.PutResult.Replaced">
            <summary>
            The item replaced an existing item with the same key
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.PutResult.Overwritten">
            <summary>
            The item was inserted instead of an existing item with lower or equal priority
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.ICacheEntry`1">
            <summary>
            Provides information about the item stored in cache
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheEntry`1.Value">
            <summary>
            Returns value only if enumerator is in materializing mode, obtained by a call to AsEnumerable(withValues: true)
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICacheTable`1.AsEnumerable(System.Boolean)">
            <summary>
            Returns the table as enumerable of entries with optional materialization
            of values (which is slower). Materialization is guaranteed to be consistent with the key
            </summary>
            <param name="withValues">True, to materialize internal PilePointers into CLR objects</param>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICacheTable`1.ContainsKey(`0,System.Int32)">
            <summary>
            Returns true if cache has object with the key, optionally filtering-out objects older than ageSec param if it is &gt; zero.
            Returns false if there is no object with the specified key or it is older than ageSec limit.
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICacheTable`1.SizeOfValue(`0,System.Int32)">
            <summary>
            Returns the size of stored object if cache has object with the key, optionally filtering-out objects older than ageSec param if it is &gt; zero.
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICacheTable`1.Get(`0,System.Int32)">
            <summary>
            Gets cache object by key, optionally filtering-out objects older than ageSec param if it is &gt; zero.
            Returns null if there is no object with the specified key or it is older than ageSec limit.
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICacheTable`1.GetPointer(`0,System.Int32)">
            <summary>
            Gets cache object pointer by key, optionally filtering-out objects older than ageSec param if it is &gt; zero.
            Returns invalid pointer if there is no object with the specified key or it is older than ageSec limit.
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICacheTable`1.Put(`0,System.Object,System.Nullable{System.Int32},System.Int32,System.Nullable{System.DateTime})">
            <summary>
            Puts an object identified by a key into cache returning the result of the put.
            For example, put may have added nothing if the table is capped and the space is occupied with data of higher priority
            </summary>
            <param name="key">A table-wide unique obvject key</param>
            <param name="obj">An object to put</param>
            <param name="maxAgeSec">If null then the default maxAgeSec is taken from Options property, otherwise specifies the length of items life in seconds</param>
            <param name="priority">The priority of this item. If there is no space in future the items with lower priorities will not evict existing data with highr priorities</param>
            <param name="absoluteExpirationUTC">Optional UTC timestamp of object eviction from cache</param>
            <returns>The status of put - whether item was inserted/replaced(if key exists)/overwritten or collided with higher-prioritized existing data</returns>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICacheTable`1.PutPointer(`0,NFX.ApplicationModel.Pile.PilePointer,System.Nullable{System.Int32},System.Int32,System.Nullable{System.DateTime})">
            <summary>
            Puts a pointer identified by a key into cache returning the result of the put.
            For example, put may have added nothing if the table is capped and the space is occupied with data of higher priority
            </summary>
            <param name="key">A table-wide unique obvject key</param>
            <param name="ptr">A valid pointer to put</param>
            <param name="maxAgeSec">If null then the default maxAgeSec is taken from Options property, otherwise specifies the length of items life in seconds</param>
            <param name="priority">The priority of this item. If there is no space in future the items with lower priorities will not evict existing data with highr priorities</param>
            <param name="absoluteExpirationUTC">Optional UTC timestamp of object eviction from cache</param>
            <returns>The status of put - whether item was inserted/replaced(if key exists)/overwritten or collided with higher-prioritized existing data</returns>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICacheTable`1.Remove(`0)">
            <summary>
            Removes data by key returning true if found and removed
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICacheTable`1.Rejuvenate(`0)">
            <summary>
            Resets internal object age returning true of object was found and rejuvenated
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.ICacheTable`1.GetOrPut(`0,System.Func{NFX.ApplicationModel.Pile.ICacheTable{`0},`0,System.Object,System.Object},System.Object,System.Nullable{NFX.ApplicationModel.Pile.PutResult}@,System.Int32,System.Int32,System.Int32,System.Nullable{System.DateTime})">
            <summary>
            Atomically tries to get object by key if it exists, otherwise calls a factory method under lock and puts the data with the specified parameters.
            'newPutResult' returns the result of the put after factory method call.
            Keep in mind, that even if a factory method created a new object, there may be a case when the value
            could not be physically inserted in the cache because of a collision (data with higher priority occupies space and space is capped), so check for
            'newPutResult' value which is null in case of getting an existing item.
            Returns object that was gotten or created anew
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheTable`1.KeyComparer">
            <summary>
            Returns equality comparer for keys, or null to use default Equals
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheImplementation.PileMaxMemoryLimit">
            <summary>
            Imposes a limit on maximum number of bytes that a pile can allocate of the system heap.
            The default value of 0 means no limit, meaning - the pile will keep allocating objects
            until the system allows. If the limit is reached, then the cache will start deleting
            older objects to releave the memory load even if they are not due for expiration yet
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheImplementation.PileAllocMode">
            <summary>
            Defines modes of allocation: space/time tradeoff
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheImplementation.TableOptions">
            <summary>
            Returns table options - used for table creation
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.ICacheImplementation.DefaultTableOptions">
            <summary>
            Sets default options for a table which is not found in TableOptions collection.
            If this property is null then every table assumes the set of constant values defined in Table class
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.GDIDWithISOKey">
            <summary>
            Represents a value-type GDID+3 char ISO code tuple, suitable for serving as a cache table key.
            The point of this structure is to avoid creation of references for Pile cache so keys alone do not stall the GC.
            The ISO code is case-insensitive
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.IDistributedStableHashProvider">
            <summary>
            Denotes entities that provide ULONG STABLE hash code for use in a distributed (large scale) system.
            This is needed primarily for cluster/large datasets to properly compute 64bit sharding addresses and to differentiate
            from GetHashCode() that returns 32 bits unstable hash for local object location in hashtables.
            DO not confuse with object.GetHashCode() which is un-suitable for long-term persistence
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IDistributedStableHashProvider.GetDistributedStableHash">
            <summary>
            Provides 64 bit STABLE hash suitable for distributed system application.
            This hash may NOT depend on platform as it is used for storage.
            Warning! DO NOT CALL object.GetHashCode() as it may not be suitable for storage
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.DatedGDIDWithISOKey">
            <summary>
            Represents a date (not time)-sensitive value-type GDID+3 char ISO code tuple, suitable for serving as a cache table key.
            The point of this structure is to avoid creation of references for Pile cache so keys alone do not stall the GC.
            The ISO code is case-insensitive
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.Dated2GDIDWithISOKey">
            <summary>
            Represents a date (not time)-sensitive value-type 2 GDIDs+3 char ISO code tuple, suitable for serving as a cache table key.
            The point of this structure is to avoid creation of references for Pile cache so keys alone do not stall the GC.
            The ISO code is case-insensitive
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.TwoGDIDWithISOKey">
            <summary>
            Represents a value-type 2 GDIDs+3 char ISO code tuple, suitable for serving as a cache table key.
            The point of this structure is to avoid creation of references for Pile cache so keys alone do not stall the GC.
            The ISO code is case-insensitive
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.GDIDWithStrHash">
            <summary>
            Represents a GDID with 8 byte string hash. The hash is case sensitive.
            The point of this structure is to avoid creation of references for Pile cache so keys alone do not stall the GC.
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.GDIDWithInt">
            <summary>
            Represents GDID with int
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.LocalCache">
            <summary>
            Provides default implementation of a cache that stores the mapping locally.
            The mapped-to objects may reside in local or distributed pile as configured
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.LocalCache.ExternalParametersForGroups(System.String[])">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.LocalCache.ExternalGetParameter(System.String,System.Object@,System.String[])">
            <summary>
            Gets external parameter value returning true if parameter was found
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.LocalCache.ExternalSetParameter(System.String,System.Object,System.String[])">
            <summary>
            Sets external parameter value returning true if parameter was found and set
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCache.InstrumentationEnabled">
            <summary>
            Implements IInstrumentable
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCache.Pile">
            <summary>
            Gets/sets a pile instance that this cache is using.
            Can set on an inactive only.
            If the target pile is directed by this service then it will start/stop the pile,
            otherwise the pile has to be managed externally
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCache.Tables">
            <summary>
            Tables that this cache contains
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCache.TableOptions">
            <summary>
            Returns table options - used for table creation
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCache.DefaultTableOptions">
            <summary>
            Sets default options for a table which is not found in TableOptions collection.
            If this property is null then every table assumes the set of constant values defined in Table class
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCache.DetailedInstrumentationForAllTables">
            <summary>
            Handy admin property that sets detailed instrumentation flag for all tables at once
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCache.Count">
            <summary>
            Returns total number of records in cache
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCache.ExternalParameters">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCacheTable`1.Count">
            <summary>
            How many records in the instance
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCacheTable`1.Capacity">
            <summary>
            How many entries are allocated for data
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.LocalCacheTable`1.LoadFactor">
            <summary>
            Load factor for the table
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.LocalMemory">
            <summary>
            Represents local memory accessed via byte[]
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.ChunkFlag">
            <summary>
            Chunk flags: Free/Used
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.PileInstances">
            <summary>
            Provides a central multiton interface for mapping PileID -> pile instance.
            This class is thread-safe.
            This class is used by system code and should not be used by business developers
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.PileInstances._____Register(NFX.ApplicationModel.Pile.IPile)">
            <summary>
            Internal method used by IPile implementation, business logic developers do not call
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.PileInstances._____Unregister(NFX.ApplicationModel.Pile.IPile)">
            <summary>
            Internal method used by IPile implementation, business logic developers do not call
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.PileInstances.Map(System.Int32)">
            <summary>
            Maps pileID to IPile intsance or null if not found
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.PilePointer">
            <summary>
            Represents a pointer to the pile object (object stored in a pile).
            The reference may be local or distributed in which case the NodeID is>=0.
            Distributed pointers are very useful for organizing piles of objects distributed among many servers, for example
             for "Big Memory" implementations or large neural networks where nodes may inter-connect between servers.
            The CLR reference to the IPile is not a part of this struct for performance and practicality reasons, as
             it is highly unlikely that there are going to be more than one instance of a pile in a process, however
             should more than 1 pile be allocated than this pointer would need to be wrapped in some other structure along with source IPile reference
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.PilePointer.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates distributed pointer
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.PilePointer.#ctor(System.Int32,System.Int32)">
            <summary>
            Create local pointer
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.PilePointer.NodeID">
            <summary>
            Distributed Node ID. The local pile sets this to -1 rendering this pointer as !DistributedValid
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.PilePointer.Segment">
            <summary>
            Segment # within pile
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.Pile.PilePointer.Address">
            <summary>
            Address within the segment
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.PilePointer.Invalid">
            <summary>
            Returns a -1:-1 non-valid pointer (either local or distributed)
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.PilePointer.Valid">
            <summary>
            Returns true if the pointer has positive segment and address, however this does not mean that pointed-to data exists.
            Even if this is a valid local pointer it may be an invalid distributed pointer
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.PilePointer.DistributedValid">
            <summary>
            Returns true if the pointer has positive distributed NodeID and has a valid local pointer
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Pile.TableOptions">
            <summary>
            Provides config options for cache tables
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Pile.TableOptions.Clone">
            <summary>
            Makes an identical copy of this instance
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.MinimumCapacity">
            <summary>
            How many elements a table may have at minimum, the property is checked at shrinking.
            Zero = no limit.
            The value is dependent on bucket count, so the actual table capacity is bucket-dependent
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.MaximumCapacity">
            <summary>
            How many elements a table may have at maximum, the property is checked at growth.
            Zero = no limit
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.InitialCapacity">
            <summary>
            How many elements an empty table should contain. The value is dependent on bucket count, so the actual table capacity is bucket-dependent
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.GrowthFactor">
            <summary>
            Defines the factor of growth - how much does a table grow when HWM is reached. The number has to be at least 1.2d
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.ShrinkFactor">
            <summary>
            Defines the factor of shrinking - how much does a table shrink when LWM is reached. The number has to be at most 0.7d
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.LoadFactorLWM">
            <summary>
            Defines the load factor below which the shrinking is triggered
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.LoadFactorHWM">
            <summary>
            Defines the load factor above which the growth is triggered
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.DefaultMaxAgeSec">
            <summary>
            Specifies default max age length which is applied to cache items if Put() does not specify particular max age
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.DetailedInstrumentation">
            <summary>
            True to include instrumentation details per table
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.CollisionMode">
            <summary>
            Defines how table handles collisions.
            Note: this property can only be supplied to table ctor, the changes are ignored after the table has created
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Pile.TableOptions.AsExternalParameter">
            <summary>
            Allows to get/set options as external parameters
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.ServiceBaseApplication">
            <summary>
            Provides base implementation of IApplication for applications that have no forms like services and console apps. This class IS thread safe
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ServiceBaseApplication.#ctor(System.String[],NFX.Environment.ConfigSectionNode)">
            <summary>
            Takes optional application args[] and root configuration.
            The args are parsed into CommandArgsConfiguration.
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ServiceBaseApplication.#ctor(System.String,NFX.Environment.Configuration,NFX.Environment.ConfigSectionNode)">
            <summary>
            Takes optional command-line configuration args and root configuration. If configuration is null then
             application is configured from a file co-located with entry-point assembly and
              called the same name as assembly with '.config' extension, unless args are specified and "/config file"
              switch is used in which case 'file' has to be locatable and readable.
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.ServiceBaseApplication.Destroy">
            <summary>
            Destroys application effectively finalizing all services
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.Instance">
            <summary>
            References a singleton instance of ServiceBaseApplication
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.ContextAvailable">
            <summary>
            Indicates whether application context was allocated
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.AppName">
            <summary>
            Returns application name
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.IsActive">
            <summary>
            Returns true when application instance is active and working. This property returns false as soon as application finalization starts on shutdown
            Use to exit long-running loops and such
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.Logger">
            <summary>
            References application logger
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.Instruments">
            <summary>
            References application instrumentation
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.Throttles">
            <summary>
            References application throttling
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.CommandArgs">
            <summary>
            References command line arguments configuration, so one can use it as:
             <code>
              if (ServiceApplication.Instance.CommandArgs["DeleteFiles"].Exists)
              {
                // this will run if process was invoked like so: process.exe /deleteFiles
              }
             </code>
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.CmdArgs">
            <summary>
            References command line arguments configuration, so one can use it as:
             <code>
              if (Servicepplication.CmdArgs["DeleteFiles"].Exists)
              {
                // this will run if process was invoked like so: process.exe /deleteFiles
              }
             </code>
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.ConfRoot">
            <summary>
            Provides access to configuration root for the whole application
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.Data">
            <summary>
            References application data store
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.Objects">
            <summary>
            References application object store. Objects will survive application termination
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.Glues">
            <summary>
            References glue that can be used to connect to remote entities
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.Security">
            <summary>
            References security manager that performs user authentication based on passed credentials and other security-related global tasks
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.Time">
            <summary>
            References time source - an entity that supplies local and UTC times. The concrete implementation
             may elect to get accurate times from the network or other external precision time sources (i.e. NASA atomic clock)
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.ServiceBaseApplication.Timer">
            <summary>
            References event timer which maintains and runs scheduled Event instances
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.SessionLoginType">
            <summary>
            Denotes types of session login
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.SessionLoginType.Unspecified">
            <summary>
            Not known
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.SessionLoginType.Human">
            <summary>
            A human user has entered/supplied/provided the credentials
            </summary>
        </member>
        <member name="F:NFX.ApplicationModel.SessionLoginType.Robot">
            <summary>
            A robot/computer/process/API caller
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.NOPApplication">
            <summary>
            Represents an application that consists of pure-nop providers, consequently
             this application does not log, does not store data and does not do anything else
            still satisfying its contract
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.NOPApplication.Instance">
            <summary>
            Returns a singlelton instance of the NOPApplication
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.TestApplication">
            <summary>
            Application designated for use in various unit test cases.
            This class is not intended for use in production systems!
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.TestApplication.RegisterConfigSettings(NFX.Environment.IConfigSettings)">
            <summary>
            Registers an instance of IConfigSettings with application container to receive a call when
             underlying app configuration changes
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.TestApplication.UnregisterConfigSettings(NFX.Environment.IConfigSettings)">
            <summary>
            Removes the registration of IConfigSettings from application container
            </summary>
            <returns>True if settings instance was found and removed</returns>
        </member>
        <member name="M:NFX.ApplicationModel.TestApplication.NotifyAllConfigSettingsAboutChange">
            <summary>
            Forces notification of all registered IConfigSettings-implementers about configuration change
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.TestApplication.NotifyAllConfigSettingsAboutChange(NFX.Environment.IConfigSectionNode)">
            <summary>
            Forces notification of all registered IConfigSettings-implementers about configuration change
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Volatile.NOPObjectStoreProvider">
            <summary>
            Defines a provider that does not do anything - does not store object anywhere but memory
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Volatile.ObjectStoreProvider">
            <summary>
            Defines a base provider that stores objects for ObjectStoreService class
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Volatile.FileObjectFormat">
            <summary>
            Format of files on disk
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Volatile.FileObjectStoreProvider">
            <summary>
            Defines a file-based provider that stores objects for ObjectStoreService class
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.FileObjectStoreProvider.Format">
            <summary>
            Returns file format used for serialization/deserialization into/from files
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.FileObjectStoreProvider.LoadLimit">
            <summary>
            Imposes the limit on number of bytes that can be read from disk on load all.
            Once limit is exceeded the rest of objects will not load.
            Provider loads most recent objects first
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.FileObjectStoreProvider.LoadSize">
            <summary>
            Returns how many bytes have been loaded from disk
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.FileObjectStoreProvider.RootPath">
            <summary>
            Gets/sets the root path where objects are stored
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Volatile.IObjectStore">
            <summary>
            Outlines interface for object store
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.IObjectStore.Fetch(System.Guid,System.Boolean)">
            <summary>
            Retrieves an object reference from the store identified by the "key" or returns null if such object does not exist.
            Object is not going to be persisted as this method provides logical read-only access. If touch=true then object timestamp is updated
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.IObjectStore.CheckOut(System.Guid)">
            <summary>
            Retrieves an object reference from the store identified by the "key" or returns null if such object does not exist.
            Object is not going to be persisted until it is checked back in the store.
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.IObjectStore.UndoCheckout(System.Guid)">
            <summary>
            Reverts object state to Normal after the call to Checkout. This way the changes (if any) are not going to be persisted.
            Returns true if object was found and checkout canceled. Keep in mind: this method CAN NOT revert inner object state
             to its original state if it was changed, it only unmarks object as changed.
            This method is reentrant just like the Checkout is
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.IObjectStore.CheckIn(System.Guid,System.Int32)">
            <summary>
            Puts an object into store identified by the "key"
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.IObjectStore.CheckIn(System.Guid,System.Object,System.Int32)">
            <summary>
            Puts an object reference "value" into store identified by the "key"
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.IObjectStore.CheckInUnderNewKey(System.Guid,System.Guid,System.Object,System.Int32)">
            <summary>
            Puts an object reference "value" into store identified by the "oldKey" under the "newKey".
            If oldKey was not checked in, then checks-in under new key as normally would
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.IObjectStore.Delete(System.Guid)">
            <summary>
            Deletes object identified by key. Returns true when object was found and marked for deletion
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.IObjectStore.ObjectLifeSpanMS">
            <summary>
            Specifies how long objects live without being touched before becoming evicted from the list
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Volatile.NOPObjectStore">
            <summary>
            Implements ObjectStore service that does nothing
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.NOPObjectStore.CheckOut(System.Guid)">
            <summary>
            Retrieves an object reference from the store identified by the "key" or returns null if such object does not exist.
            Object is not going to be persisted until it is checked back in the store.
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.NOPObjectStore.UndoCheckout(System.Guid)">
            <summary>
            Reverts object state to Normal after the call to Checkout. This way the changes (if any) are not going to be persisted.
            Returns true if object was found and checkout canceled. Keep in mind: this method CAN NOT revert inner object state
             to its original state if it was changed, it only unmarks object as changed.
            This method is reentrant just like the Checkout is
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.NOPObjectStore.CheckIn(System.Guid,System.Object,System.Int32)">
            <summary>
            Puts an object reference "value" into store identified by the "key"
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.NOPObjectStore.CheckInUnderNewKey(System.Guid,System.Guid,System.Object,System.Int32)">
            <summary>
            Puts an object reference "value" into store identified by the "oldKey" under the "newKey".
            If oldKey was not checked in, then checks-in under new key as normally would
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.NOPObjectStore.CheckIn(System.Guid,System.Int32)">
            <summary>
            Puts an object reference "value" into store identified by the "key"
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.NOPObjectStore.Delete(System.Guid)">
            <summary>
            Deletes object identified by key. Returns true when object was found and marked for deletion
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.NOPObjectStore.Instance">
            <summary>
            Returns a singlelton instance of the objectstore that does not do anything
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Volatile.ObjectStoreEntryStatus">
            <summary>
            Represents status of ObjectStoreEntry
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Volatile.ObjectStoreEntry">
            <summary>
            Internal framework class that stores data in ObjectStoreService
            </summary>
        </member>
        <member name="T:NFX.ApplicationModel.Volatile.ObjectStoreService">
            <summary>
            Implements service that stores object in proccess's memory, asynchronously saving objects to external non-volatile storage
            upon change and synchronously saving objects upon service stop. This service is useful for scenarious like ASP.NET
            volatile domain that can be torn down at any time.
            Note for ASP.NET uses: the key difference of this approach from .NET session state management is the fact that this service never blocks
             object CheckIn() operations as backing store is being updated asynchronously.
            This class is thread-safe unless specified otherwise on a property/method level
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.ObjectStoreService.#ctor">
            <summary>
            Creates instance of the store service
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.ObjectStoreService.#ctor(System.Guid)">
            <summary>
            Creates instance of the store service with the state identified by "storeGUID". Refer to "StoreGUID" property.
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.ObjectStoreService.Fetch(System.Guid,System.Boolean)">
            <summary>
            Retrieves an object reference from the store identified by the "key" or returns null if such object does not exist.
            Object is not going to be persisted as this method provides logical read-only access. If touch=true then object timestamp is updated
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.ObjectStoreService.CheckOut(System.Guid)">
            <summary>
            Retrieves an object reference from the store identified by the "key" or returns null if such object does not exist.
            Object is not going to be persisted until it is checked back in the store using the same number of calls to CheckIn() for the same GUID.
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.ObjectStoreService.UndoCheckout(System.Guid)">
            <summary>
            Reverts object state to Normal after the call to Checkout. This way the changes (if any) are not going to be persisted.
            Returns true if object was found and checkout canceled. Keep in mind: this method CAN NOT revert inner object state
             to its original state if it was changed, it only unmarks object as changed.
            This method is reentrant just like the Checkout is
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.ObjectStoreService.CheckIn(System.Guid,System.Object,System.Int32)">
            <summary>
            Puts an object reference "value" into store identified by the "key".
            The object is written in the provider when call count to this method equals to CheckOut()
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.ObjectStoreService.CheckInUnderNewKey(System.Guid,System.Guid,System.Object,System.Int32)">
            <summary>
            Puts an object reference "value" into store identified by the "oldKey" under the "newKey".
            If oldKey was not checked in, then checks-in under new key as normally would
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.ObjectStoreService.CheckIn(System.Guid,System.Int32)">
            <summary>
            Puts an object back into store identified by the "key".
            The object is written in the provider when call count to this method equals to CheckOut().
            Returns true if object with such id exists and was checked-in
            </summary>
        </member>
        <member name="M:NFX.ApplicationModel.Volatile.ObjectStoreService.Delete(System.Guid)">
            <summary>
            Deletes object identified by key. Returns true when object was found and marked for deletion
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.ObjectStoreService.StoreGUID">
            <summary>
            Returns unique identifier that identifies this particular store.
            This ID is used to load store's state from external medium upon start-up.
            One may think of this ID as of a "pointer/handle" that survives phisical object destroy/create cycle
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.ObjectStoreService.InstrumentationEnabled">
            <summary>
            Implements IInstrumentable
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.ObjectStoreService.BucketCount">
            <summary>
            Specifies how many buckets objects are kept in. Increasing this number improves thread concurrency
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.ObjectStoreService.ObjectLifeSpanMS">
            <summary>
            Specifies how long objects live without being touched before becoming evicted from the list
            </summary>
        </member>
        <member name="P:NFX.ApplicationModel.Volatile.ObjectStoreService.Provider">
            <summary>
            References provider that persists objects
            </summary>
        </member>
        <member name="T:NFX.Collections.CappedSet`1">
            <summary>
            Implements a set of T with the optional size limit and optional item lifespan limit.
            This class is thread-safe and must be disposed in a deterministic way
            </summary>
        </member>
        <member name="M:NFX.Collections.CappedSet`1.Put(`0)">
            <summary>
            Atomic operation which tries to include a member in the set. Returns true if member was included.
            </summary>
        </member>
        <member name="M:NFX.Collections.CappedSet`1.Get(`0,System.DateTime@)">
            <summary>
            Atomic operation which tries to get a member data returning true if it was found
            </summary>
        </member>
        <member name="M:NFX.Collections.CappedSet`1.Contains(`0)">
            <summary>
            Atomic operation which tries to get a member data returning true if it was found
            </summary>
        </member>
        <member name="M:NFX.Collections.CappedSet`1.Remove(`0)">
            <summary>
            Atomic operation which tries to remove and existing memeber returning true
            </summary>
        </member>
        <member name="M:NFX.Collections.CappedSet`1.Clear">
            <summary>
            Removes all items
            </summary>
        </member>
        <member name="P:NFX.Collections.CappedSet`1.SizeLimit">
            <summary>
            If set > 0, imposes a limit on the maximum number of entries.
            When Count exceeds the limit the set asynchronously capps the capacity by
            removing older entries. The limit does not guarantee the instant or exact consistency with the Count property
            </summary>
        </member>
        <member name="P:NFX.Collections.CappedSet`1.TimeLimitSec">
            <summary>
            If set >0 then evicts the entries older than the specified value.
            Does not guarantee the exact consistency of eviction time
            </summary>
        </member>
        <member name="P:NFX.Collections.CappedSet`1.Count">
            <summary>
            Returns the number of members in the set
            </summary>
        </member>
        <member name="T:NFX.Collections.NamedInterlocked">
            <summary>
            Provides functionality similar to the Interlocked class executed over a named slot.
            All operations are THREAD-SAFE for calling concurrently.
            The name comparison is that of Registry's which is OrdinalIgnoreCase.
            This class was designed to better organize named counters incremented from different threads,
            i.e. this is needed to keep a count of calls to remote host identified by their names.
            This class is NOT designed for frequent additions/deletions of named slots, nor was it designed
            to keep millions of slots. Use it in cases when there are thousands at most slots and new slots
            appear infrequently. You must delete un-needed slots
            </summary>
        </member>
        <member name="M:NFX.Collections.NamedInterlocked.SnapshotAllLongs(System.Nullable{System.Int64})">
            <summary>
            Enumerates all named integers. This operation is thread-safe, and returns a snapshot of the instance taken at the time of the first call.
            If exchange is specified, atomicaly flips the value of every slot
            </summary>
        </member>
        <member name="M:NFX.Collections.NamedInterlocked.SnapshotAllAmounts(System.Nullable{System.Decimal})">
            <summary>
            Enumerates all named amounts. This operation is thread-safe, and returns a snapshot of the instance taken at the time of the first call
            If exchange is specified, atomicaly flips the value of every slot
            </summary>
        </member>
        <member name="M:NFX.Collections.NamedInterlocked.SnapshotAllLongsInto``1(System.Nullable{System.Int64},NFX.Instrumentation.IInstrumentation)">
            <summary>
            Records a snapshot of all longs converted into TDatum. The TDatum must have a public .ctor(string, long) or runtime exception is thrown
            (this is because C# does not have a contract/constraint for parameterized cosntructors)
            </summary>
        </member>
        <member name="M:NFX.Collections.NamedInterlocked.Clear">
            <summary>
            Deletes all state for all slots
            </summary>
        </member>
        <member name="M:NFX.Collections.NamedInterlocked.Clear(System.String)">
            <summary>
            Deletes all state for the named slot returning true if the slot was found and removed
            </summary>
        </member>
        <member name="M:NFX.Collections.NamedInterlocked.Exists(System.String)">
            <summary>
            Returns true when the instance contains the named slot
            </summary>
        </member>
        <member name="M:NFX.Collections.NamedInterlocked.Add(NFX.Collections.NamedInterlocked,System.Nullable{System.Int64})">
            <summary>
            Adds slot snapshot from another source.
            Pass exchange to flip the existing slots to the exchanged value
            </summary>
        </member>
        <member name="M:NFX.Collections.NamedInterlocked.ReadAtomicLong(System.String)">
            <summary>
             Returns a 64-bit value, loaded as an atomic operation even on a 32bit platform
            </summary>
        </member>
        <member name="M:NFX.Collections.NamedInterlocked.VolatileReadLong(System.String)">
            <summary>
            Captures the current value of a named long value.
            If slot does not exist, creates it and captures the value (which may be non-zero even if the slot was just created)
            </summary>
        </member>
        <member name="M:NFX.Collections.NamedInterlocked.ExchangeLong(System.String,System.Int64)">
            <summary>
            Captures the current value of a named long value and atomically sets it to the passed value
            </summary>
        </member>
        <member name="P:NFX.Collections.NamedInterlocked.Count">
            <summary>
            Returns the current number of named slots in the instance
            </summary>
        </member>
        <member name="P:NFX.Collections.NamedInterlocked.AllNames">
            <summary>
            Enumerates all slot names. This operation is thread-safe, and returns a snapshot of the instance taken at the time of the first call
            </summary>
        </member>
        <member name="T:NFX.Collections.NamedInterlocked`1">
            <summary>
            Adds context to NamedInterlocked
            </summary>
        </member>
        <member name="T:NFX.Collections.StringMap">
            <summary>
            Efficeintly maps string -> string for serialization.
            Compared to Dictionary[string,string] this class yields 20%-50% better Slim serialization speed improvement and 5%-10% space improvement
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.CacheParams">
            <summary>
            Implements ICacheParams - supplied caching parameters
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.ICacheParams">
            <summary>
            Supplies caching params
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.ICacheParams.ReadCacheMaxAgeSec">
            <summary>
            If greater than 0 then would allow reading a cached result for up-to the specified number of seconds.
            If =0 uses cache's default span.
            Less than 0 does not try to read from cache
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.ICacheParams.WriteCacheMaxAgeSec">
            <summary>
            If greater than 0 then writes to cache with the expiration.
            If =0 uses cache's default life span.
            Less than 0 does not write to cache
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.ICacheParams.WriteCachePriority">
            <summary>
            Relative cache priority which is used when WriteCacheMaxAgeSec>=0
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.ICacheParams.CacheAbsentData">
            <summary>
            When true would cache the instance of AbsentData to signify the absence of data in the backend for key
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.CacheParams.ReadWriteSec(System.Int32,System.Int32)">
            <summary>
            Cache params with the same read/write interval
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.CacheParams.ReadFreshWriteSec(System.Int32,System.Int32)">
            <summary>
            Cache params with no read but write caching interval and priority
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.CacheParams.NoCache">
            <summary>
            CacheParams that dont use cache
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.CacheParams.DefaultCache">
            <summary>
            CacheParams that use cache's default
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.CacheParams.OneMinute">
            <summary>
            CacheParams that uses one minute for sensitive data (i.e. user account-related data)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.CacheParams.ReadCacheMaxAgeSec">
            <summary>
            If greater than 0 then would allow reading a cached result for up-to the specified number of seconds.
            If =0 uses cache's default span.
            Less than 0 does not try to read from cache
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.CacheParams.WriteCacheMaxAgeSec">
            <summary>
            If greater than 0 then writes to cache with the expiration.
            If =0 uses cache's default life span.
            Less than 0 does not write to cache
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.CacheParams.WriteCachePriority">
            <summary>
            Relative cache priority which is used when WriteCacheMaxAgeSec>=0
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.CacheParams.CacheAbsentData">
            <summary>
            When true would cache the instance of AbsentData to signify the absence of data in the backend for key
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.CRUDQueryHandler">
            <summary>
            Represents an entity that can execute a query. The implementation may be called by multiple threads and must be safe
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.CRUDQueryHandler.GetSchema(NFX.DataAccess.CRUD.ICRUDQueryExecutionContext,NFX.DataAccess.CRUD.Query)">
            <summary>
            Executes query without fetching any data but schema. The implementation may be called by multiple threads and must be safe
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.CRUDQueryHandler.GetSchemaAsync(NFX.DataAccess.CRUD.ICRUDQueryExecutionContext,NFX.DataAccess.CRUD.Query)">
            <summary>
            Executes query without fetching any data but schema. The implementation may be called by multiple threads and must be safe
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.CRUDQueryHandler.Execute(NFX.DataAccess.CRUD.ICRUDQueryExecutionContext,NFX.DataAccess.CRUD.Query,System.Boolean)">
            <summary>
            Executes query. The implementation may be called by multiple threads and must be safe
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.CRUDQueryHandler.ExecuteAsync(NFX.DataAccess.CRUD.ICRUDQueryExecutionContext,NFX.DataAccess.CRUD.Query,System.Boolean)">
            <summary>
            Executes query. The implementation may be called by multiple threads and must be safe
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.CRUDQueryHandler.OpenCursor(NFX.DataAccess.CRUD.ICRUDQueryExecutionContext,NFX.DataAccess.CRUD.Query)">
            <summary>
            Executes query into Cursor. The implementation may be called by multiple threads and must be safe
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.CRUDQueryHandler.OpenCursorAsync(NFX.DataAccess.CRUD.ICRUDQueryExecutionContext,NFX.DataAccess.CRUD.Query)">
            <summary>
            Executes query into Cursor. The implementation may be called by multiple threads and must be safe
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.CRUDQueryHandler.ExecuteWithoutFetch(NFX.DataAccess.CRUD.ICRUDQueryExecutionContext,NFX.DataAccess.CRUD.Query)">
            <summary>
            Executes query that dows not return results. The implementation may be called by multiple threads and must be safe.
            Returns rows affected
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.CRUDQueryHandler.ExecuteWithoutFetchAsync(NFX.DataAccess.CRUD.ICRUDQueryExecutionContext,NFX.DataAccess.CRUD.Query)">
            <summary>
            Executes query that dows not return results. The implementation may be called by multiple threads and must be safe.
            Returns rows affected
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.CRUDQueryHandler.Name">
            <summary>
            Returns query name that this handler handles
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.CRUDQueryHandler.Store">
            <summary>
            Store instance that handler is under
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.CRUDQueryHandler`1">
            <summary>
            Represents an entity that can execute a query. The implementation may be called by multiple threads and must be safe
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.CRUDQueryHandler`1.Store">
            <summary>
            Store instance that handler is under
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.JSONMappings">
            <summary>
            Facilitates mapping of CRUD/CLR types/values to JSON and back to CLR/CRUD
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.ICRUDDataStore">
            <summary>
            Represents a DataStore that supports CRUD operations
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.ICRUDOperations">
            <summary>
            Describes an entity that performs single (not in transaction/batch)CRUD operations
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.ICRUDOperations.SupportsTrueAsynchrony">
            <summary>
            Returns true when backend supports true asynchronous operations, such as the ones that do not create extra threads/empty tasks
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.ICRUDTransactionOperations">
            <summary>
            Describes an entity that performs single (not in transaction/batch)CRUD operations
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.ICRUDTransactionOperations.BeginTransaction(System.Data.IsolationLevel,NFX.DataAccess.CRUD.TransactionDisposeBehavior)">
            <summary>
            Returns a transaction object for backend. Even if backend does not support transactions internally, CRUDTransactions save changes
             into the store on commit only
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.ICRUDTransactionOperations.BeginTransactionAsync(System.Data.IsolationLevel,NFX.DataAccess.CRUD.TransactionDisposeBehavior)">
            <summary>
            Returns a transaction object for backend. Even if backend does not support transactions internally, CRUDTransactions save changes
             into the store on commit only
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.ICRUDTransactionOperations.SupportsTransactions">
            <summary>
            Returns true when backend supports transactions. Even if false returned, CRUDDatastore supports CRUDTransaction return from BeginTransaction()
             in which case statements may not be sent to destination until a call to Commit()
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.ICRUDDataStore.ScriptFileSuffix">
            <summary>
            Returns default script file suffix, which some providers may use to locate script files
             i.e. for MySql:  ".my.sql" which gets added to script files like so:  name.[suffix].[script ext (i.e. sql)].
            This name should uniquely identify the provider
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.ICRUDDataStore.StoreType">
            <summary>
            Provides classification for the underlying store
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.ICRUDDataStore.QueryResolver">
            <summary>
            Reolver that turns query into handler
            </summary>
        </member>
        <member name="T:NFX.DataAccess.IDataStoreImplementation">
            <summary>
            Represents a store that can save and retrieve data
            </summary>
        </member>
        <member name="T:NFX.DataAccess.IDataStore">
            <summary>
            Represents a store that can save and retrieve data
            </summary>
        </member>
        <member name="M:NFX.DataAccess.IDataStore.TestConnection">
            <summary>
            Tests connection and throws an exception if connection could not be established
            </summary>
        </member>
        <member name="P:NFX.DataAccess.IDataStore.TargetName">
            <summary>
            Returns the name of the underlying store technology, i.e. "ORACLE".
            This property is used by some metadata-based validation logic which is target-dependent
            </summary>
        </member>
        <member name="P:NFX.DataAccess.IDataStoreImplementation.LogLevel">
            <summary>
            Defines log level for data stores
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.RowEqualityComparer">
            <summary>
            Checks for reference equality. Use RowEqualityComparer.Instance
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Cursor">
            <summary>
            Represents a buffer-less unidicrectional reader that binds IEnumerable(Row) and the backend resource
            (such as SQLReader or other object which is internal to the backend).
            The cursor is NOT thread-safe and must be disposed properly by closing all resources associated with it.
            Only one iteration (one call to GetEnumerator) is possible
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Cursor.#ctor(System.Collections.Generic.IEnumerable{NFX.DataAccess.CRUD.Row})">
            <summary>
            This method is not inteded to be called by application developers
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.PassthroughCursor">
            <summary>
            Represents a cursor that basically does nothing else but
            passes through control to source IEnumerable(Row)
            </summary>
        </member>
        <member name="T:NFX.DataUtils">
            <summary>
            Provides various extension methods for construction of FieldFilterFunc and casting rowsets
            </summary>
        </member>
        <member name="M:NFX.DataUtils.OnlyTheseFields(System.String,System.Boolean)">
            <summary>
            Converts field names separated by ',' or ';' into a FieldFilterFunction
            </summary>
        </member>
        <member name="M:NFX.DataUtils.OnlyTheseFields(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Converts field names separated by ',' or ';' into a FieldFilterFunction
            </summary>
        </member>
        <member name="M:NFX.DataUtils.AllButTheseFields(System.String,System.Boolean)">
            <summary>
            Converts field names separated by ',' or ';' into a FieldFilterFunction
            </summary>
        </member>
        <member name="M:NFX.DataUtils.AllButTheseFields(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Converts field names separated by ',' or ';' into a FieldFilterFunction
            </summary>
        </member>
        <member name="M:NFX.DataUtils.Clone``1(``0,System.Boolean,System.Boolean,System.Func{System.String,NFX.DataAccess.CRUD.Schema.FieldDef,System.Boolean},System.Func{System.String,System.String,System.Boolean})">
            <summary>
            If source is not null, creates a shallow clone using 'source.CopyFields(copy)'
            </summary>
        </member>
        <member name="M:NFX.DataUtils.AsEnumerableOf``1(System.Collections.Generic.IEnumerable{NFX.DataAccess.CRUD.Row})">
            <summary>
            Casts enumerable of rows (such as rowset) to the specified row type, returning empty enumerable if the source is null
            </summary>
        </member>
        <member name="M:NFX.DataUtils.LoadRow``1(NFX.DataAccess.CRUD.ICRUDOperations,NFX.DataAccess.CRUD.Query{``0})">
            <summary>
            Loads one row cast per Query(T) or null
            </summary>
        </member>
        <member name="M:NFX.DataUtils.LoadRowAsync``1(NFX.DataAccess.CRUD.ICRUDOperations,NFX.DataAccess.CRUD.Query{``0})">
            <summary>
            Async version - loads one row cast per Query(T) or null
            </summary>
        </member>
        <member name="M:NFX.DataUtils.LoadEnumerable``1(NFX.DataAccess.CRUD.ICRUDOperations,NFX.DataAccess.CRUD.Query{``0})">
            <summary>
            Loads rowset with rows cast per Query(T) or empty enum
            </summary>
        </member>
        <member name="M:NFX.DataUtils.LoadEnumerableAsync``1(NFX.DataAccess.CRUD.ICRUDOperations,NFX.DataAccess.CRUD.Query{``0})">
            <summary>
            Async version - loads rowset with rows cast per Query(T) or empty enum
            </summary>
        </member>
        <member name="T:NFX.CoreConsts">
            <summary>
            Central non-lozalizable NFX system consts
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.CRUDOperationCallContext">
            <summary>
            Establishes a thead-static context which surrounds CRUD operations. You can derive your own classes, the .ctor must be chained.
            The context can be nested. A call to .ctor must be balanced with .Dispose().
            This is needed to pass some out-of-band information in some special cases to CRUD operations without changing
            the caller interface, i.e. to swap database connection string.
            This class IS NOT THREAD SAFE, so in cases of async operations, the context captures extra parameters ONLY for initial ASYNC INVOCATION, that is-
             a true ASYNC implementation must pass the reference along the task execution line (in which case the object may be already Disposed but usable for property access
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.CRUDOperationCallContext.Current">
            <summary>
            Returns the current set CRUDOperationCallContext or null
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.CRUDOperationCallContext.ConnectString">
            <summary>
            Used to override store's default database connection string
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.CRUDOperationCallContext.DatabaseName">
            <summary>
            Used to override store's default database name - used by some stores, others take db name form connect string
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Subscriptions.ICRUDSubscriptionStore">
            <summary>
            Describes a CRUD store that can send ROW data via an established subscriptions into local recipients.
            Subscriptions are really stateless, they do not capture the data, however the Recipients do.
            Recipients can either support pull (caller has to fetch data), or reactive (calling delegate) modes
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Subscriptions.ICRUDSubscriptionStore.Subscribe(System.String,NFX.DataAccess.CRUD.Query,NFX.DataAccess.CRUD.Subscriptions.Mailbox,System.Object)">
            <summary>
            Subscribes the local recipient to the remote data store by executing a Query.
            The subscription ends by calling a .Dispose()
            </summary>
            <param name="name">The store-wide-unique subscription name</param>
            <param name="query">The query that informs the remote store what data to send back</param>
            <param name="recipient">The local Recipient which will receive remote data</param>
            <param name="correlate">Adhock correlation object</param>
            <returns>The subscription. It may be ended by calling .Dispose()</returns>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Subscriptions.ICRUDSubscriptionStore.OpenMailbox(System.String)">
            <summary>
            Returns existing mailbox by name (case-insensitive) or creates a new named mailbox
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Subscriptions.ICRUDSubscriptionStore.Subscriptions">
            <summary>
            Returns registry of all active subscriptions
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Subscriptions.ICRUDSubscriptionStore.Mailboxes">
            <summary>
            Returns registry of all mailboxes
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Subscriptions.DataTimeStamp">
            <summary>
            Represents a microsecond interval since UNIX epoch start.
            This struct is used to tag incoming subscription data, so upon re-subscription
            the client may tell the server where to start sync from
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Subscriptions.CRUDSubscriptionEvent">
            <summary>
            Describes row modification
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Subscriptions.CRUDSubscriptionEvent.EventType">
            <summary>
            Describes what kind of modification was done
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Subscriptions.SubscriptionReceiptEventHandler">
            <summary>
            Describes event handlers that get called when data arrives
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Subscriptions.Mailbox">
            <summary>
            Represents CRUD row data recipient
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Subscriptions.SubscriptionAppComponent">
            <summary>
            Base type for externally parametrized app components that are used throughout Subscription implementation
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Subscriptions.SubscriptionAppComponent.ExternalParametersForGroups(System.String[])">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Subscriptions.SubscriptionAppComponent.ExternalGetParameter(System.String,System.Object@,System.String[])">
            <summary>
            Gets external parameter value returning true if parameter was found
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Subscriptions.SubscriptionAppComponent.ExternalSetParameter(System.String,System.Object,System.String[])">
            <summary>
            Sets external parameter value returning true if parameter was found and set
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Subscriptions.SubscriptionAppComponent.ExternalParameters">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Subscriptions.Mailbox.Deliver(NFX.DataAccess.CRUD.Subscriptions.Subscription,NFX.DataAccess.CRUD.Subscriptions.CRUDSubscriptionEvent)">
            <summary>
            Delivers data to the mailbox. This method is called by subscription
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Subscriptions.Mailbox.FetchBuffered(System.Int32,System.Boolean)">
            <summary>
            Tries to take the specified number of samples in chronological order
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Subscriptions.Mailbox.Buffered">
            <summary>
            Returns all buffered data in chronological order
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Subscriptions.Mailbox.BufferedCount">
            <summary>
            Returns how much is currently buffered
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Subscriptions.InvalidSubscriptionRequestException">
            <summary>
            Thrown by provider to indicate that such a subscribtion can not be established in principle,
            i.e. you may have passed a zero size of populus group, the server may respond with this error
            to indicate the principal error in request
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.CRUDException">
            <summary>
            Thrown by CRUD data access classes
            </summary>
        </member>
        <member name="T:NFX.DataAccess.DataAccessException">
            <summary>
            Thrown by data access classes
            </summary>
        </member>
        <member name="F:NFX.DataAccess.DataAccessException.KeyViolationKind">
            <summary>
            Spcifies the sub-type of key violation
            </summary>
        </member>
        <member name="F:NFX.DataAccess.DataAccessException.KeyViolation">
            <summary>
            Provides the name of entity/index/field that was violated and resulted in this exception
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Subscriptions.Subscription">
            <summary>
            Represents a subscription to the CRUD Data.
            Call Dispose() to terminate the subscription.
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Subscriptions.Subscription.Invalidate(NFX.DataAccess.CRUD.Subscriptions.InvalidSubscriptionRequestException)">
            <summary>
            Called by descendants to invalidate this subscription
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Subscriptions.Subscription.HasLoaded">
            <summary>
            Call after subscription has been initialized
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Subscriptions.Subscription.InvalidSubscriptionException">
            <summary>
            If this property is not null then this subscription is !IsValid
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Subscriptions.Subscription.IsValid">
            <summary>
            Returns false when this subscription experienced InvalidSubscriptionException
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Subscriptions.Subscription.Correlate">
            <summary>
            Allows to attach arbtrary bject for correlation
            </summary>
        </member>
        <member name="T:NFX.Environment.ConfigNodeEqualityComparer">
            <summary>
            Performs deep structural comparison of IConfigNodes
            </summary>
        </member>
        <member name="T:NFX.Environment.IConfigStringBuilder">
            <summary>
            Denotes objects that can build a string (i.e. a database connection string) from the configured
            state/properties. This is used for example to build DB connect strings from host names that need
            to be resolved via an external system
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigStringBuilder.BuildString">
            <summary>
            Builds the string based on the configured state
            </summary>
        </member>
        <member name="T:NFX.Environment.ConfigStringBuilder">
            <summary>
            Facilitates the creation/building of strings from existing strings or configuration vectors.
            This is used for example to build DB connect strings from host names that need
            to be resolved via an external system
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigStringBuilder.Build(NFX.Environment.IConfigNode)">
            <summary>
            Builds the string based on the configured state supplied as a config vector, or
            passes the supplied string through if it is not a loaconic vector with CONFIG_BUILDER_ROOT
            </summary>
            <param name="source">The original source which may be IConfigStringBuilder injector or attribute value</param>
            <returns>The original attribute string value or the string returnd by IConfigStringBuilder.BuildString() method if IConfigStringBuilder was specified</returns>
        </member>
        <member name="M:NFX.Environment.ConfigStringBuilder.Build(NFX.Environment.IConfigSectionNode,System.String)">
            <summary>
            Builds the string based on the configured state supplied as a config vector, or
            passes the supplied string through if it is not a loaconic vector with CONFIG_BUILDER_ROOT
            </summary>
            <param name="level">The configuration section level</param>
            <param name="sectionOrAttributeName">The name of section or attribute at the specified level</param>
            <returns>The original attribute string value or the string returnd by IConfigStringBuilder.BuildString() method if IConfigStringBuilder was specified</returns>
        </member>
        <member name="T:NFX.Environment.JSONConfiguration">
            <summary>
            Provides implementation of configuration based on a classic JSON content
            </summary>
        </member>
        <member name="T:NFX.Environment.FileConfiguration">
            <summary>
            Provides file-based configuration base object used for concrete implementations such as XML or INI file base configurations
            </summary>
        </member>
        <member name="T:NFX.Environment.Configuration">
            <summary>
            Provides top-level configuration abstraction
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.NewEmptyRoot(System.String)">
            <summary>
            Creates a new empty config root based on laconic format
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.ProviderLoadFromFile(System.String)">
            <summary>
            Loads the contents of the supplied file name in an appropriate configuration provider implementation for the supplied extension format
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.ProviderLoadFromAnySupportedFormatFile(System.String)">
            <summary>
            Loads the contents of the supplied file name without format extension trying to match any of the supported format extensions.
            When match is found the file is loaded via an appropriate configuration provider
            </summary>
            <example>
            Given "c:\conf\users" as an input:
              if "c:\conf\users.xml" exists then it will be opened as XMLConfiguration
              if "c:\conf\users.laconf" exists then it will be opened as LaconicConfiguration
              if "c:\conf\users.json" exists then it will be opened as JSONConfiguration
              and so on... for the rest of supported formats
            </example>
        </member>
        <member name="M:NFX.Environment.Configuration.ProviderLoadFromString(System.String,System.String,System.String)">
            <summary>
            Loads the supplied string content in the specified format, which may be format name like "xml" or "laconfig" with or without extension period
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.IsSupportedFormat(System.String)">
            <summary>
            True when format is supported
            </summary>
        </member>
        <member name="F:NFX.Environment.Configuration.ProcesswideEnvironmentVarResolver">
            <summary>
            Gets/sets global Environment variable resolver that is used by all configurations in this process instance
            </summary>
        </member>
        <member name="F:NFX.Environment.Configuration.ProcesswideConfigNodeProviderType">
            <summary>
            Gets/sets global implementor of IConfigNodeProvider that is used by all configurations in this process instance
            when type is not specified
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.Create(System.String)">
            <summary>
            Creates new configuration - creates new configuration root with optional name parameter
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.CreateFromMerge(NFX.Environment.ConfigSectionNode,NFX.Environment.ConfigSectionNode,NFX.Environment.NodeOverrideRules)">
            <summary>
            Creates new configuration from ordered merge result of two other nodes - base and override which can be from different configurations
            </summary>
            <param name="baseNode">A base node that data is defaulted from</param>
            <param name="overrideNode">A node that contains overrides/additions of/to data from base node</param>
            <param name="rules">Rules to use or default rules will be used in null is passed</param>
        </member>
        <member name="M:NFX.Environment.Configuration.CreateFromNode(NFX.Environment.IConfigSectionNode)">
            <summary>
            Creates new configuration from other node, which may belong to a different configuration instance
            </summary>
            <param name="otherNode">A base node that data is defaulted from</param>
        </member>
        <member name="M:NFX.Environment.Configuration.Destroy">
            <summary>
            Erases all config data
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.Refresh">
            <summary>
            Re-reads configuration from source
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.Save">
            <summary>
            Saves configuration to source
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.CheckAndAdjustNodeName(System.String)">
            <summary>
            Checks node name for aptitude for particular configuration type.
            For example, XML configuration does not allow nodes with spaces or separator chars.
            When StrictNames is set to true and value is not appropriate then exception is thrown
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.ResolveEnvironmentVar(System.String,NFX.Environment.IEnvironmentVariableResolver)">
            <summary>
            Resolves variable name into its value
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.RunMacro(NFX.Environment.IConfigSectionNode,System.String,System.String,NFX.Environment.IConfigSectionNode,NFX.Environment.IMacroRunner,System.Object)">
            <summary>
            Runs macro and returns its value
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.Clone``1">
            <summary>
            Creates a deep copy of this configuration into new instance of T
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.Clone(NFX.Environment.Configuration)">
            <summary>
            Creates a deep copy of this configuration into newInstance which was allocated externally
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.Clone">
            <summary>
            Implements IClonable by returning new MemoryConfiguration clone
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.Include(NFX.Environment.ConfigSectionNode,NFX.Environment.ConfigSectionNode)">
            <summary>
            Completely replaces this node with another node tree, positioning the new tree in the place of local node.
            Existing node is deleted after this operation completes, in its place child nodes from other node are inserted
            preserving their existing order. Attributes of other node get merged into parent of existing node
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.ToLaconicString(NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions)">
            <summary>
            Serializes configuration tree into Laconic format and returns it as a string
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.ToLaconicStream(System.IO.Stream,NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions,System.Text.Encoding)">
            <summary>
            Serializes configuration tree into Laconic format and writes it into stream
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.ToLaconicFile(System.String,NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions,System.Text.Encoding)">
            <summary>
            Serializes configuration tree into Laconic format and writes it into a file
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.ToConfigurationJSONDataMap">
            <summary>
            Returns this config as JSON data map suitable for making JSONConfiguration
            </summary>
        </member>
        <member name="M:NFX.Environment.Configuration.AdjustNodeName(System.String)">
            <summary>
            Override to perform transforms on node names so they become suitable for particular configuration type
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.AllSupportedFormats">
            <summary>
            Returns all configuration file formats (file extensions without '.') supported
            by ProviderLoadFromFile/ProviderLoadFromAnySupportedFormatFile/ProviderLoadFromString
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.Root">
            <summary>
            Accesses root section configuration node
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.StrictNames">
            <summary>
            Determines whether exception is thrown when configuration node name contains
            inappropriate chars for particular configuration type. For example,
             for XMLConfiguration node names may not have spaces and other separator chars.
            When StrictNames is false then particular configurations may replace incompatible
             chars in node names with neutral ones (i.e. "my value"->"my-value" in case of XMLConfiguration).
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.IsReadOnly">
            <summary>
            Indicates whether configuration is read-only
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.EnvironmentVarResolver">
            <summary>
            References variable resolver. If this property is not set then default Windows environment var resolver is used
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.MacroRunner">
            <summary>
            References macro runner. If this property is not set then default macro runner is used
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.MacroRunnerContext">
            <summary>
            Gets/sets an object passed by the framework into MacroRunner.Run() method.
            This property is auto-set for classes decorated with [ConfigMacroContext] attribute
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.EmptySection">
            <summary>
            References a special instance of an empty section node (one per configuration).
            Empty nodes are returned by indexers when a real node with specified name does not exist
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.EmptyAttr">
            <summary>
            References a special instance of an empty attribute node (one per configuration).
            Empty nodes are returned by indexers when a real node with specified name does not exist
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.Variable_ESCAPE">
            <summary>
            Variable escape tag
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.Variable_START">
            <summary>
            Variable start tag
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.Variable_END">
            <summary>
            Variable end tag
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.Variable_PATH_MOD">
            <summary>
            Variable path modifier
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.Variable_ENV_MOD">
            <summary>
            Variable environment modifier
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.Variable_MACRO_START">
            <summary>
            Variable get clause modifier
            </summary>
        </member>
        <member name="P:NFX.Environment.Configuration.ContentView">
            <summary>
            Primarily used for debugging - returns the content of the configuration as text in the pretty-printed Laconic format
            </summary>
        </member>
        <member name="M:NFX.Environment.FileConfiguration.#ctor">
            <summary>
            Creates an instance of a new configuration not bound to any file
            </summary>
        </member>
        <member name="M:NFX.Environment.FileConfiguration.#ctor(System.String)">
            <summary>
            Creates an isntance of configuration and reads contents from the file
            </summary>
        </member>
        <member name="M:NFX.Environment.FileConfiguration.SaveAs(System.String)">
            <summary>
            Saves configuration into specified file
            </summary>
        </member>
        <member name="P:NFX.Environment.FileConfiguration.IsReadOnly">
            <summary>
            Indicates whether configuration is readonly or may be modified and saved
            </summary>
        </member>
        <member name="M:NFX.Environment.JSONConfiguration.#ctor">
            <summary>
            Creates an instance of a new configuration not bound to any JSON file
            </summary>
        </member>
        <member name="M:NFX.Environment.JSONConfiguration.#ctor(System.String)">
            <summary>
            Creates an isntance of the new configuration and reads contents from a JSON file
            </summary>
        </member>
        <member name="M:NFX.Environment.JSONConfiguration.CreateFromJSON(System.String)">
            <summary>
            Creates an instance of configuration initialized from JSON content passed as string
            </summary>
        </member>
        <member name="M:NFX.Environment.JSONConfiguration.SaveAs(System.String)">
            <summary>
            Saves configuration into a JSON file
            </summary>
        </member>
        <member name="M:NFX.Environment.JSONConfiguration.SaveAs(System.String,NFX.Serialization.JSON.JSONWritingOptions,System.Text.Encoding)">
            <summary>
            Saves configuration into a JSON file
            </summary>
        </member>
        <member name="M:NFX.Environment.JSONConfiguration.SaveToString(NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Saves JSON configuration to string
            </summary>
        </member>
        <member name="T:NFX.ExternalParameterSecurityCheck">
            <summary>
            Specifies when security permissions should be checked while getting/setting extrenal parameters
            </summary>
        </member>
        <member name="T:NFX.ExternalParameterAttribute">
            <summary>
            Decorates properties that may be used as bindable external parameters.
            Provides methods for extraction of parameter names, values and binding of external object values into
             public read/write properties decorated by this attribute
            </summary>
        </member>
        <member name="M:NFX.ExternalParameterAttribute.#ctor(System.String[])">
            <summary>
            Provides a list of group names where this parameter applies
            </summary>
        </member>
        <member name="M:NFX.ExternalParameterAttribute.#ctor(System.String,NFX.ExternalParameterSecurityCheck,System.String[])">
            <summary>
            Provides a name override with list of groups names where this parameter applies
            </summary>
        </member>
        <member name="F:NFX.ExternalParameterAttribute.Name">
            <summary>
            Provides name override for external parameter. When this value is not set
             the name is taken from the decorated member name
            </summary>
        </member>
        <member name="F:NFX.ExternalParameterAttribute.SecurityCheck">
            <summary>
            Specifies what security check must be done on get/set
            </summary>
        </member>
        <member name="F:NFX.ExternalParameterAttribute.Groups">
            <summary>
            Returns null or a set of group names where parameter is applicable.
            This is needed to disregard parameters that do not belong to things being managed,
            for example, some parameters may be only set for isntrumentation, not for glue etc.
            </summary>
        </member>
        <member name="M:NFX.ExternalParameterAttribute.GetParameters(System.Object,System.String[])">
            <summary>
            Returns external parameter names and type - names for read/write public properties decorated with this attribute.
            If groups is null then all parameters returned, else parameters must intersect in their group sets with the
            supplied value
            </summary>
        </member>
        <member name="M:NFX.ExternalParameterAttribute.GetParameters(System.Type,System.String[])">
            <summary>
            Returns external parameter names and type - names for read/write public properties decorated with this attribute.
            If groups is null then all parameters returned, else parameters must intersect in their group sets with the
            supplied value
            </summary>
        </member>
        <member name="M:NFX.ExternalParameterAttribute.GetParametersWithAttrs(System.Type,System.String[])">
            <summary>
            Returns external parameter names, type and attributes - names for read/write public properties decorated with this attribute.
            If groups is null then all parameters returned, else parameters must intersect in their group sets with the
            supplied value
            </summary>
        </member>
        <member name="M:NFX.ExternalParameterAttribute.GetParameter(System.Object,System.String,System.Object@,System.String[])">
            <summary>
            Gets instrumentation parameter value returning true if parameter was found.
            Parameter names are case-insensitive.
            If groups is null then all parameters are searched, else parameters must intersect in
            their group sets with the supplied value
            </summary>
        </member>
        <member name="M:NFX.ExternalParameterAttribute.SetParameter(System.Object,System.String,System.Object,System.String[])">
            <summary>
            Sets instrumentation parameter value, true if parameter name was found and set succeeded.
            The property is tried to be set directly to the supplied value first, then, in case of assignment error,
             the value is converted into string then tried to be re-converted to target type.
            Returns true for successful set. Parameter names are case-insensitive.
            If groups is null then all parameters are searched, else parameters must intersect in
            their group sets with the supplied value
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Source.StreamSource">
            <summary>
            Represents source code stored in a stream
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Source.ISourceText">
            <summary>
            Represents source code input text (usually text from file)
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Source.ISourceText.Reset">
            <summary>
            Resets source to beginning
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Source.ISourceText.ReadChar">
            <summary>
            Returns next char and advances position
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Source.ISourceText.PeekChar">
            <summary>
            Returns next char without advancing position
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Source.ISourceText.EOF">
            <summary>
            Indicates whether last character has been read
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Source.ISourceText.Language">
            <summary>
            Indicates what language this source is supplied in
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Source.ISourceText.Name">
            <summary>
            Provides a meaningfull name to a source code
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Source.StreamSource.#ctor(System.IO.Stream,NFX.CodeAnalysis.Language,System.String)">
            <summary>
            Constructs stream source with specified language and default encoding
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Source.StreamSource.#ctor(System.IO.Stream,System.Text.Encoding,NFX.CodeAnalysis.Language,System.String)">
            <summary>
            Constructs stream source with specified language and encoding
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Source.StreamSource.Name">
            <summary>
            Returns source's name
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.XML.XMLLanguage">
            <summary>
            Represents XML language
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Language">
            <summary>
            Represents and abstraction of the language
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Language.TryFindLanguageByFileExtension(System.String)">
            <summary>
            Tries to find a language by file extension or returns UnspecifiedLanguage
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Language.MakeLexer(NFX.CodeAnalysis.IAnalysisContext,NFX.CodeAnalysis.Source.SourceCodeRef,NFX.CodeAnalysis.Source.ISourceText,NFX.CodeAnalysis.MessageList,System.Boolean)">
            <summary>
            Makes lexer capable of this language analysis
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Language.All">
            <summary>
            Returns all languages registered in the system
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Language.Family">
            <summary>
            Returns language family categorization
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Language.FileExtensions">
            <summary>
            Returns file extensions without '.'
            </summary>
        </member>
        <member name="T:NFX.Collections.BitList">
            <summary>
            Provides bit array with automatic resizing
            </summary>
        </member>
        <member name="T:NFX.Collections.BitMatrix2D">
            <summary>
            Provides an efficient access to a square 2D bit matrix accessible as boolean values
            </summary>
        </member>
        <member name="T:NFX.Collections.MatrixBase`1">
            <summary>
            Provides base for various matrices
            </summary>
        </member>
        <member name="M:NFX.Collections.BitMatrix2D.FillSubArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Fills homogeneous sub-area of this square with the specified value
            </summary>
        </member>
        <member name="P:NFX.Collections.BitMatrix2D.Item(System.Int32,System.Int32)">
            <summary>
            Provides access to bit values by X,Y matric coordinates
            </summary>
        </member>
        <member name="T:NFX.Collections.EventPhase">
            <summary>
            Specifies the phase of the event i.e. before/after
            </summary>
        </member>
        <member name="T:NFX.Collections.EventedCollectionGetReadOnlyHandler`1">
            <summary>
            Event handler for list changes
            </summary>
        </member>
        <member name="T:NFX.Collections.EventedCollectionBase`1">
            <summary>
            Provides base implementation for some evented collections
            </summary>
        </member>
        <member name="P:NFX.Collections.EventedCollectionBase`1.ContextReadOnly">
            <summary>
            Returns true to indicate that Context property can not be set (was injected in .ctor only
            </summary>
        </member>
        <member name="P:NFX.Collections.EventedCollectionBase`1.Context">
            <summary>
            Context that this structure works in
            </summary>
        </member>
        <member name="P:NFX.Collections.EventedCollectionBase`1.IsReadOnly">
            <summary>
            Indicates whether collection can be modified
            </summary>
        </member>
        <member name="T:NFX.Collections.EventedDictionary`3">
            <summary>
            Represents a dictionary that rises events
            </summary>
        </member>
        <member name="M:NFX.Collections.EventedDictionary`3.#ctor">
            <summary>
             Initializes a new instance that is empty, has the default initial capacity, and uses the default
             equality comparer for the key type.
             </summary>
        </member>
        <member name="M:NFX.Collections.EventedDictionary`3.#ctor(`2,System.Boolean)">
            <summary>
             Initializes a new instance that is empty, has the default initial capacity, and uses the default
             equality comparer for the key type.
             </summary>
        </member>
        <member name="M:NFX.Collections.EventedDictionary`3.#ctor(`2,System.Boolean,System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Initializes a new instance that contains elements copied from the specified IDictionary[TKey,TValue]
             and uses the default equality comparer for the key type.
            </summary>
        </member>
        <member name="M:NFX.Collections.EventedDictionary`3.#ctor(`2,System.Boolean,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
              Initializes a new instance that is empty, has the default initial capacity, and uses the specified
                IEqualityComparer[T].
            </summary>
        </member>
        <member name="M:NFX.Collections.EventedDictionary`3.#ctor(`2,System.Boolean,System.Int32)">
            <summary>
            Initializes a new instance that is empty, has the specified initial capacity, and uses the default
              equality comparer for the key type.
            </summary>
        </member>
        <member name="M:NFX.Collections.EventedDictionary`3.#ctor(`2,System.Boolean,System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
             Initializes a new instance that contains elements copied from the specified IDictionary[TKey,TValue]
                and uses the specified IEqualityComparer[T].
            </summary>
        </member>
        <member name="M:NFX.Collections.EventedDictionary`3.#ctor(`2,System.Boolean,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the Dictionary[TKey,TValue]
              class that is empty, has the specified initial capacity, and uses the specified IEqualityComparer[T]
            </summary>
        </member>
        <member name="T:NFX.Collections.EventedDictionary`3.ChangeType">
            <summary>
            Describes changes in evented list
            </summary>
        </member>
        <member name="T:NFX.Collections.EventedList`2">
            <summary>
             Represents list that rises change events
            </summary>
        </member>
        <member name="M:NFX.Collections.EventedList`2.#ctor">
            <summary>
             Initializes a new instance that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:NFX.Collections.EventedList`2.#ctor(`1,System.Boolean)">
            <summary>
             Initializes a new instance that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:NFX.Collections.EventedList`2.#ctor(`1,System.Boolean,System.Collections.Generic.IEnumerable{`0})">
            <summary>
             Initializes a new instance that contains elements copied from the specified collection and has sufficient
              capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:NFX.Collections.EventedList`2.#ctor(`1,System.Boolean,System.Int32)">
            <summary>
             Initializes a new instance that is empty and has the specified initial capacity.
            </summary>
        </member>
        <member name="T:NFX.Collections.EventedList`2.ChangeType">
            <summary>
            Describes changes in evented list
            </summary>
        </member>
        <member name="T:NFX.Collections.Matrix2D`1">
            <summary>
            Represents a two deminsional matrix of T.
            This class uses jagged arrays for internal implementation ensuring proper array sizing per matrix structure
            </summary>
            <typeparam name="T">Any desired type</typeparam>
        </member>
        <member name="T:NFX.DataAccess.Cache.CacheRec">
            <summary>
            Stores cached item (such as a business object) along with additional caching information about it.
            The instance of this class gets reused for the same Key, so Key is immutable field.
            The instance of this class is returned by table.Get(key...) so the calling thread may see different Value property with time
            as it may be dynamically changed by some other thread (the newer value for the same Key)
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Bucketed">
            <summary>
            Abstraction of an item that can be placed in hashing bucket
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.CacheRec.ReuseCTOR(System.Object,System.Int32,System.Int32,System.Nullable{System.DateTime})">
            <summary>
            Used as a "constructor" that reuses this class instance to lessen GC burden
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.CacheRec.Key">
            <summary>
            Key is immutable because CacheRec is returned by table.Get(key)
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.CacheRec.Metadata">
            <summary>
            Stores arbitrary information about this item
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.CacheRec.ValueAs``1">
            <summary>
            Returns typecasted value
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheRec.AgeSec">
            <summary>
            Returns an approximate age of the item in seconds - an interval since this item was put into the store for the last time
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheRec.MaxAgeSec">
            <summary>
            Returns positive integer that specifies the maximum lifespan duration for this item expressed in seconds, or zero.
            Zero is returned when this item does not have specific lifespan defined and will be evicted from cache
             per lifespan specified on the table level: Table.MaxAgeSec (default)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheRec.AbsoluteExpirationUTC">
            <summary>
            Returns absolute expiration timestamp for this item or null
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheRec.Priority">
            <summary>
            Returns an integer value that dictates item priority relative to other items in the same table.
            Priorities play a role during cache collision as an item with higher priority is not going to be replaced
             by an item with lower priority
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheRec.HitCount">
            <summary>
            Returns how many times this cache item was hit (resulted in successfull read)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheRec.Value">
            <summary>
            Returns the value - a reference to cached item such as a business object
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.CacheStore">
            <summary>
            Represents an efficient in-memory cache of expiring optionally-prioritized objects.
            This class is higly optimized for caching of business objects in data store implementations and does not guarantee that
            all hash collisions are handled, that is - some data may be overridden. The implementation relies on 2 stage hashing, where the second collision replaces the
             existing item with the colliding one if items are equal in their priorities. The degree of collisions is controlled by 'bucketSize' and 'recPerPage' parameters that
             are passed to the store per table, so basically the tables are capped at a certain size and can not change (bucketSize*recPerPage).
            The lookup implementation is 100% lock-free, whereas the degree of mutability-related locking is controlled by 'lockCount' per table.
            This class is thread safe for reading and writing cache items, however it does not guarantee instant read/write consistency between threads.
            </summary>
            <remarks>
            Perfomance testing of this class vs. System.Runtime.Caching.MemoryCache storing a typical database record identified by a long key:
             NFX is 2.5-5 times faster for concurrent reads and takes 20% less ram.
             NFX is 1.3-2.5 times faster for writes
            </remarks>
        </member>
        <member name="M:NFX.DataAccess.Cache.CacheStore.ExternalParametersForGroups(System.String[])">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.CacheStore.Configure(NFX.Environment.IConfigSectionNode)">
            <summary>
            Configures store from node, if node==null then store will be configured by named node of 'app/cache/store[name=X]' path, if such path
            is not found the store tries to find 'app/cache/store[!name]' (node without name)
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.CacheStore.ExternalGetParameter(System.String,System.Object@,System.String[])">
            <summary>
            Gets external parameter value returning true if parameter was found
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.CacheStore.ExternalSetParameter(System.String,System.Object,System.String[])">
            <summary>
            Sets external parameter value returning true if parameter was found and set
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.CacheStore.DropTable(System.String)">
            <summary>
            Drops table by name returning true if it was found and removed
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheStore.Name">
            <summary>
            Returns store name which can be used to identify stores in registries and instrumentation/telemetry outputs
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheStore.Tables">
            <summary>
            Returns all tables that this store currently contains
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheStore.TableOptions">
            <summary>
            Returns table options - used for table creation
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheStore.DefaultTableOptions">
            <summary>
            Sets default options for a table which is not found in TableOptions collection.
            If this property is null then every table assumes the set of constant values defined in Table class
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheStore.Item(System.String)">
            <summary>
            Returns a table by its name creating its' instance if such table is not in the set. Table names are case-insensitive
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheStore.Item(System.String,System.UInt64)">
            <summary>
            Returns a cached record from named table identified by the key or null if this item was not found
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheStore.ParallelSweep">
            <summary>
            When enabled, uses parallel execution while sweeping tables, otherwise sweeps sequentially (default behavior)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheStore.Count">
            <summary>
            Returns total number of records in all tables in the store
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheStore.InstrumentationEnabled">
            <summary>
            When true, emits instrumentation messages
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.CacheStore.ExternalParameters">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.ComplexKeyHashingStrategy">
            <summary>
            Provides hashing strategy for keys that are not scalar uint64.
            This is a companion class for CacheStore which only understands uint64 as keys for efficiency purposes.
            One may extend this class to implement custom resolution of complex keys into uint64 hashes
            and provide collision handling. The base implementation uses object.GetHashCode() with chaining for collision resolution
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.ComplexKeyHashingStrategy.MAX_CACHE_CHAIN_LENGTH">
            <summary>
            How many times hash will be adjusted while chaining
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.ComplexKeyHashingStrategy.Store">
            <summary>
            References cachestore that this strategy works with
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.ComplexKeyHashingStrategy.DefaultComplexKeyToCacheKey(System.Object)">
            <summary>
            Default implementation that converts complex object to uint64 key.
            The default implementation returns the hashcode of the object unless the key is string
            in which case it calls DefaultStringKeyToCacheKey() or IULongHashProvider(GDID and parcels).
            The function is not deterministic due to the use of .GetHashCode() that may change between release for some objects (depends on object implementation),
            so the returned value should not be persisted
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.ComplexKeyHashingStrategy.DefaultStringKeyToCacheKey(System.String)">
            <summary>
            Provides default implementation for converting string keys into uint64 hash.
            This functions provides the best selectivity for strings that are 8 chars long or less.
            The function is NOT deterministic as it uses .GetHashCode(), so the returned value should not be persisted
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.ComplexKeyHashingStrategy.ComplexKeyToCacheKey(System.Object)">
            <summary>
            Override to convert complex object to uint64 key.
            The default implementation returns DefaultComplexKeyToCacheKey(key)
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.ComplexKeyHashingStrategy.Put(System.String,System.Object,System.Object,System.Int32,System.Int32,System.Nullable{System.DateTime})">
            <summary>
            Override to put a value keyed on a non-uint64 scalar into cache. Returns table.Put() result
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.ComplexKeyHashingStrategy.Get(System.String,System.Object,System.Int32)">
            <summary>
            Override to get a value keyed on a non-uint64 scalar from cache. Returns null when item does not exist
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.ComplexKeyHashingStrategy.Remove(System.String,System.Object)">
            <summary>
            Override to remove an item keyed on a non-uint64 scalar from cache. Returns true if remove found and removed item from table
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.CacheLongGauge">
            <summary>
            Provides base for cache long gauges
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.CacheDoubleGauge">
            <summary>
            Provides base for cache double gauges
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.RecordCount">
            <summary>
            Provides record count in the instance
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.PageCount">
            <summary>
            Provides page count in the instance
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.BucketPageLoadFactor">
            <summary>
            Provides the ratio of how many buckets are loaded with pages vs. bucket count
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.HitCount">
            <summary>
            How many times Get() resulted in cache hit
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.MissCount">
            <summary>
            How many times Get() resulted in cache miss
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.ValueFactoryCount">
            <summary>
            How many times factory func was called from GetOrPut()
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.SweepTableCount">
            <summary>
            How many times tables were swept
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.SweepPageCount">
            <summary>
            How many pages swept
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.SweepRemoveCount">
            <summary>
            How many records removed by sweep
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.PutCount">
            <summary>
            How many times Put() was called
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.PutInsertCount">
            <summary>
            How many times a call to Put() resulted in insert
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.PutReplaceCount">
            <summary>
            How many times a call to Put() resulted in relacement of existing item by key without collision
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.PutPageCreateCount">
            <summary>
            How many times a call to Put() resulted in bucket collision that created a page
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.PutCollisionCount">
            <summary>
            How many times a call to Put() resulted in new value overriding existing because of collision (old value lost)
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.PutPriorityPreventedCollisionCount">
            <summary>
            How many times a call to Put() could have resulted in new value overriding existing one because of collision, however the situation was prevented
            because existing item had higher priority than the newer one
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.RemovePageCount">
            <summary>
            How many pages have been deleted, a page gets deleted when there are no records stored in it
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.RemoveHitCount">
            <summary>
            How many records have been found and removed
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Instrumentation.RemoveMissCount">
            <summary>
            How many records have been sought to be removed but were not found
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Page">
            <summary>
            A composite item that stores collection of CacheRecs and can be placed into a hashing bucket
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.Table">
            <summary>
            Represents a table that stores cached items identified by keys
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_HitCount">
            <summary>
            how many hits - get was called
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_ComplexHitCount">
            <summary>
            how many complex key hits - get was called
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_MissCount">
            <summary>
            how many misses - get was called
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_ComplexMissCount">
            <summary>
            how many complex key misses - get was called
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_ValueFactoryCount">
            <summary>
            how many times factory called from GetOrPut
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_SweepTableCount">
            <summary>
            how many times swept
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_SweepPageCount">
            <summary>
            how many pages swept
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_SweepRemoveCount">
            <summary>
            how many records removed by sweep
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_PutCount">
            <summary>
            how many times put was called
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_PutInsertCount">
            <summary>
            how many times new value successfully inserted without collision
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_PutReplaceCount">
            <summary>
            how many times new value successfully replaced existing one (by the same key) without collision
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_PutPageCreateCount">
            <summary>
            how many times bucket collision occured that resulted in page creation
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_PutCollisionCount">
            <summary>
            how many times new value overrode existing because of collision
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_PutPriorityPreventedCollisionCount">
            <summary>
            how many times priority prevented collision
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_RemovePageCount">
            <summary>
            how many pages have been deleted, a page gets deleted when there are no records stored in it
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_RemoveHitCount">
            <summary>
            how many records have been found and removed
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.Table.stat_RemoveMissCount">
            <summary>
            how many records have been sought to be removed but were not found
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.Table.Put(System.UInt64,System.Object,System.Int32,System.Int32,System.Nullable{System.DateTime})">
            <summary>
            Puts a key-identified item into this table.
            If item with such key is already in this table then replaces it and returns false, returns true otherwise
            </summary>
            <param name="key">Item's unique key</param>
            <param name="value">Item</param>
            <param name="maxAgeSec">For how long will the item exist in cache before it gets swept out. Pass 0 to use table-level setting (default)</param>
            <param name="priority">Items priority relative to others in the table used during collision resolution, 0 = default</param>
            <param name="absoluteExpirationUTC">Sets absolute UTC time stamp when item should be swept out of cache, null is default</param>
        </member>
        <member name="M:NFX.DataAccess.Cache.Table.Put(System.UInt64,System.Object,NFX.DataAccess.Cache.CacheRec@,System.Int32,System.Int32,System.Nullable{System.DateTime})">
            <summary>
            Puts a key-identified item into this table.
            If item with such key is already in this table then replaces it and returns false, returns true otherwise
            </summary>
            <param name="key">Item's unique key</param>
            <param name="value">Item</param>
            <param name="rec">Returns new or existing CacheRec</param>
            <param name="maxAgeSec">For how long will the item exist in cache before it gets swept out. Pass 0 to use table-level setting (default)</param>
            <param name="priority">Items priority relative to others in the table used during collision resolution, 0 = default</param>
            <param name="absoluteExpirationUTC">Sets absolute UTC time stamp when item should be swept out of cache, null is default</param>
        </member>
        <member name="M:NFX.DataAccess.Cache.Table.Remove(System.UInt64)">
            <summary>
            Removes a key-identified item from the named table returning true when item was deleted
             or false when item was not found
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Cache.Table.GetOrPut``1(System.UInt64,System.Func{System.String,System.UInt64,``0,System.Object},``0,System.Int32,System.Int32,System.Int32,System.Nullable{System.DateTime})">
            <summary>
            Retrieves an item from this table by key where item age is less or equal to requested, or
             calls the itemFactory function and inserts the value in the store
            </summary>
            <param name="key">Item key</param>
            <param name="valueFactory">A function that returns new value for the specified tableName, key, and context</param>
            <param name="factoryContext">An object to pass into the factory function if it gets invoked</param>
            <param name="ageSec">Age of item in seconds, or 0 for any age</param>
            <param name="putMaxAgeSec">MaxAge for item if Put is called</param>
            <param name="putPriority">Priority for item if Put is called</param>
            <param name="putAbsoluteExpirationUTC">Absolute expiration UTC timestamp for item if Put is called</param>
            <typeparam name="TContext">A type of item factory context</typeparam>
        </member>
        <member name="M:NFX.DataAccess.Cache.Table.Get(System.UInt64,System.Int32)">
            <summary>
            Retrieves an item from this table by key where item age is less or equal to requested, or null if it does not exist
            </summary>
            <param name="key">Item key</param>
            <param name="ageSec">Age of item in seconds, or 0 for any age</param>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.Store">
            <summary>
            Returns the store instance that this table is a part of
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.Name">
            <summary>
            Returns table name which is a unique string within the cache store
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.Count">
            <summary>
            Returns item count in the table
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.PageCount">
            <summary>
            Returns page count in the table
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.StatHitCount">
            <summary>
            Returns hit count stats
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.StatComplexHitCount">
            <summary>
            Returns hit count stats for using complex keys
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.StatMissCount">
            <summary>
            Returns miss count stats
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.StatComplexMissCount">
            <summary>
            Returns miss count stats for using complex keys
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.BucketPageLoadFactor">
            <summary>
            Returns the ratio of how many buckets are loaded with pages vs. bucket count
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.Capacity">
            <summary>
            Returns the maximum number of items that this table can hold at any given time given that
             no items will have any key hash collisions
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.LockCount">
            <summary>
            Returns how many locks can be used for thread coordination during table changes
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.BucketCount">
            <summary>
            Returns how many slots/buckets are pre-allocated per table, the higher the number the more memory will be
            reserved at table construction time, every slot is a reference (4 bytes on 32bit systems, 8 bytes on 64bit).
            For optimal performance this number should be around 75% of total record count stored in the table (table load factor).
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.RecPerPage">
            <summary>
            Returns how many slots are pre-allocated per table's bucket(page) when more than one item produces hash collision.
            The higher the number, the more primary hash collisions can be accomodated by re-hashing on pages (secondary hash table within primary buckets)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.MaxAgeSec">
            <summary>
            Gets/sets maximum age of items in the table expressed in seconds. After this age is exceeded, the system will delete entries.
            The system does not guarantee that items will expire right on time, however it does guarantee that items will be available for at least
             this long.
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Cache.Table.ParallelSweep">
            <summary>
            When enabled, uses parallel execution while sweeping table buckets, otherwise sweeps sequentially (default behavior)
            </summary>
        </member>
        <member name="T:NFX.CollectionUtils">
            <summary>
            Some helpful extensions for standard collections
            </summary>
        </member>
        <member name="M:NFX.CollectionUtils.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Runs some method over each element of src sequence
            </summary>
            <typeparam name="T">Sequence item type</typeparam>
            <param name="src">Source sequence</param>
            <param name="action">Method to run over each element</param>
            <returns>Source sequence (to have ability to chain similar calls)</returns>
        </member>
        <member name="M:NFX.CollectionUtils.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            Runs some method over each element of src sequence
            </summary>
            <typeparam name="T">Sequence item type</typeparam>
            <param name="src">Source sequence</param>
            <param name="action">Method to call on each element and its sequence number</param>
            <returns>Source sequence (to have ability to chain similar calls)</returns>
        </member>
        <member name="M:NFX.CollectionUtils.AddRange``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Add all values from range sequence to src IDictionary. Source is actually modified.
            </summary>
            <typeparam name="TKey">Type of key</typeparam>
            <typeparam name="TValue">Type of value</typeparam>
            <param name="src">Source IDictionary (where to add range)</param>
            <param name="range">Sequence that should be added to source IDictionary</param>
            <returns>Source with added elements from range (to have ability to chain operations)</returns>
        </member>
        <member name="M:NFX.CollectionUtils.SkipLast``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Takes all elements except for last element from the given source
            </summary>
        </member>
        <member name="M:NFX.CollectionUtils.SkipLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Takes all but last N elements from the source
            </summary>
        </member>
        <member name="M:NFX.CollectionUtils.FirstOrAnyOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Tries to find the first element that matches the predicate and returns it,
            otherwise returns the first element found or default (i.e. null)
            </summary>
        </member>
        <member name="M:NFX.CollectionUtils.AppendToNew``1(``0[],``0[])">
            <summary>
            Returns a new array that contains source elements with additional elements appended at the end
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.TableCapacity">
            <summary>
            Provides cache table capacity classifications
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.TableCapacity.Default">
            <summary>
            25,111 * 7 = 175,777 items * 64(8/ptr + 40/cache rec + 12/obj over) = 11.25 Mb just for storing empty cache items
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.TableCapacity.Large">
            <summary>
            753,001 * 7 = 5,271,007 items * 64(8/ptr + 40/cache rec + 12/obj over) = 337.3 Mb just for storing empty cache items
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Cache.TableCapacity.XLarge">
            <summary>
            3,337,333 * 7 = 23,361,331 items * 64(8/ptr + 40/cache rec + 12/obj over) = 1.39 Gb just for storing empty cache items
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Cache.TableOptions">
            <summary>
            Provides config options for cache tables
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.FormMode">
            <summary>
            Denotes form modes: unspecified | insert | edit
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.FormModel">
            <summary>
            Represents a "model" (in MVC terms) of a data-entry form.
            Form models are statically typed - contain fields and can contain "extra amorphous" data
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.AmorphousTypedRow">
            <summary>
            Represents a type-safe row of data when schema is known at compile-time that also implements IAmorphousData
            interface that allows this row to store "extra" data that does not comply with the current schema.
            Typed rows store data in instance fields, providing better performance and schema definition compile-time checking than DynamicRows
            at the expense of inability to define schema at runtime
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.TypedRow">
            <summary>
            Represents a type-safe row of data when schema is known at compile-time.
            Typed rows store data in instance fields, providing better performance and schema definition compile-time checking than DynamicRows
            at the expense of inability to define schema at runtime
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Row">
            <summary>
            Base class for any CRUD row. This class has two direct subtypes - DynamicRow and TypedRow.
            Rows are NOT THREAD SAFE by definition
            </summary>
        </member>
        <member name="T:NFX.Environment.IConfigurationPersistent">
            <summary>
            Designates entities that may persist their parameters/state in configuration
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigurationPersistent.PersistConfiguration(NFX.Environment.ConfigSectionNode)">
            <summary>
            Persists relevant entities parameters/state into configuration
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.IValidatable">
            <summary>
            Denotes an entity that supports validation
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.IValidatable.Validate(System.String)">
            <summary>
            Validates entity state per particular named target, for performance reasons returns validation exception (instead of throwing)
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.MakeRow(NFX.DataAccess.CRUD.Schema,System.Type)">
            <summary>
            Factory method that makes an appropriate row type.For performance purposes,
             this method does not check passed type for Row-derivation and returns null instead if type was invalid
            </summary>
            <param name="schema">Schema, which is used for creation of DynamicRows and their derivatives</param>
            <param name="tRow">
            A type of row to create, if the type is TypedRow-descending then a parameterless .ctor is called,
            otherwise a type must have a .ctor that takes schema as a sole argument
            </param>
            <returns>
            Row instance or null if wrong type was passed. For performance purposes,
             this method does not check passed type for Row-derivation and returns null instead if type was invalid
            </returns>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.TryFillFromJSON(NFX.DataAccess.CRUD.Row,NFX.Serialization.JSON.IJSONDataObject,NFX.DataAccess.CRUD.SetFieldFunc)">
            <summary>
            Tries to fill the row with data returning true if field count matched
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.GetDataStoreKey(System.String)">
            <summary>
            Returns values for fields that represent row's primary key
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.Configure(NFX.Environment.IConfigSectionNode)">
            <summary>
            In base class applies Config attribute. Useful for typed rows
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.PersistConfiguration(NFX.Environment.ConfigSectionNode)">
            <summary>
            The base class does not implement this method. Override to persist row fields into config node
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.Validate">
            <summary>
            Performs validation of data in the row returning exception object that provides description
            in cases when validation does not pass. Validation is performed not targeting any particular backend
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.Validate(System.String)">
            <summary>
            Validates row using row schema and supplied field definitions.
            Override to perform custom validations,
            i.e. TypeRows may directly access properties and write some validation type-safe code
            The method is not expected to throw exception in case of failed validation, rather return exception instance because
             throwing exception really hampers validation performance when many rows need to be validated
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.ValidateField(System.String,System.String)">
            <summary>
            Validates row field by name.
            Shortcut to ValidateField(Schema.FieldDef)
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.ValidateField(System.String,NFX.DataAccess.CRUD.Schema.FieldDef)">
            <summary>
            Validates row field using Schema.FieldDef settings.
            This method is invoked by base Validate() implementation.
            The method is not expected to throw exception in case of failed validation, rather return exception instance because
             throwing exception really hampers validation performance when many rows need to be validated
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.Equals(NFX.DataAccess.CRUD.Row)">
            <summary>
            Override to perform custom row equality comparison.
            Default implementation equates rows using their key fields
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.Equals(System.Object)">
            <summary>
            Object override - sealed. Override Equals(row) instead
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.GetHashCode">
            <summary>
            Object override - gets hash code from key fields
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.SimpleFilterPredicate(System.String,System.Boolean)">
            <summary>
            Returns true if this row satisfies simple filter - it contains the supplied filter string.
            The filter pattern may start or end with "*" char that denotes a wildcard. A wildcard is permitted on both sides of the filter value
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.GetFieldValue(NFX.DataAccess.CRUD.Schema.FieldDef)">
            <summary>
            Gets value of the field, for typerows it accesses property using reflection; for dynamic rows it reads data from
             row buffer array using field index(order)
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.SetFieldValue(NFX.DataAccess.CRUD.Schema.FieldDef,System.Object)">
            <summary>
            Sets value of the field, for typerows it accesses property using reflection; for dynamic rows it sets data into
             row buffer array using field index(order)
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.ConvertFieldValueToDef(NFX.DataAccess.CRUD.Schema.FieldDef,System.Object)">
            <summary>
            Converts field value to the type specified by Schema.FieldDef. For example converts GDID->ulong or ulong->GDID.
            This method can be overridden to perform custom handling of types,
             for example one can assign bool field as "Si" that would convert to TRUE.
            This method is called by SetFieldValue(...) before assigning actual field buffer
            </summary>
            <param name="fdef">Field being converted</param>
            <param name="value">Value to convert</param>
            <returns>Converted value before assignment to field buffer</returns>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.ApplyDefaultFieldValues(System.String,System.Boolean)">
            <summary>
            Writes default values specified in schema into fields.
            Pass overwrite=true to force defaults over non-null existing values (false by default)
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.CopyFields(NFX.DataAccess.CRUD.Row,System.Boolean,System.Boolean,System.Func{System.String,NFX.DataAccess.CRUD.Schema.FieldDef,System.Boolean},System.Func{System.String,System.String,System.Boolean})">
            <summary>
            Copies fields from this row into another row/form.
            Note: this is  shallow copy, as field values for complex types are just copied over
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.GetFieldValueDescription(System.String,System.String,System.Boolean)">
            <summary>
            For fields with ValueList returns value's description per specified targeted schema
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.GetFieldValueDescription(System.Int32,System.String,System.Boolean)">
            <summary>
            For fields with ValueList returns value's description per specified targeted schema
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.GetDisplayFieldValue(System.String,System.String,System.Func{System.Object,System.Object})">
            <summary>
            Returns field value as string formatted per target DisplayFormat attribute
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.GetDisplayFieldValue(System.Int32,System.String,System.Func{System.Object,System.Object})">
            <summary>
            Returns field value as string formatted per target DisplayFormat attribute
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.getDisplayFieldValue(System.String,NFX.DataAccess.CRUD.Schema.FieldDef,System.Func{System.Object,System.Object})">
            <summary>
            Returns field value as string formatted per target DisplayFormat attribute
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.GetClientFieldValueList(System.Object,NFX.DataAccess.CRUD.Schema.FieldDef,System.String,System.String)">
            <summary>
            Override to perform dynamic lookup of field value list for the specified field.
            This method is used by client ui/scaffolding to extract dynamic lookup values
            as dictated by business logic. This method IS NOT used by row validation, only by client
            that feeds from row's metadata.
            This is a simplified version of GetClientFieldDef
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.GetClientFieldDef(System.Object,NFX.DataAccess.CRUD.Schema.FieldDef,System.String,System.String)">
            <summary>
            Override to perform dynamic substitute of field def for the specified field.
            This method is used by client ui/scaffolding to extract dynamic definition for a field
            (i.e. field description, requirement, value list etc.) as dictated by business logic.
            This method IS NOT used by row validation, only by client that feeds from row's metadata.
            The default implementation returns the original field def, you can return a substituted field def
             per particular business logic
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.GetClientFieldValue(System.Object,NFX.DataAccess.CRUD.Schema.FieldDef,System.String,System.String)">
            <summary>
            Override to perform dynamic substitute of field value for the specified field.
            This method is used by client ui/scaffolding to extract field values for a field as dictated by business logic.
            This method IS NOT used by row validation, only by client that feeds from row's metadata.
            The default implementation returns the original GetFieldValue(fdef), you can return a substituted field value
             per particular business logic
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.WriteAsJSON(System.IO.TextWriter,System.Int32,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Writes row as JSON either as an array or map depending on JSONWritingOptions.RowsAsMap setting.
            Do not call this method directly, instead call rowset.ToJSON() or use JSONWriter class
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Row.FilterJSONSerializerField(NFX.DataAccess.CRUD.Schema.FieldDef,NFX.Serialization.JSON.JSONWritingOptions,System.String@)">
            <summary>
            Override to filter-out some fields from serialization to JSON, or change field values.
            Return name null to indicate that field should be filtered-out(excluded from serialization to JSON)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Row.Schema">
            <summary>
            References a schema for a table that this row is part of
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Row.Item(System.String)">
            <summary>
            Gets/sets field values by name
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Row.Item(System.Int32)">
            <summary>
            Gets/sets field values by positional index(Order)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.TypedRow.Schema">
            <summary>
            References a schema for a table that this row is a part of
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.IAmorphousData">
            <summary>
            Denotes an entity, which is typically a row-derivative, that has extra data fields that are not
            defined by particular schema and get represented as {name:value} map instead (schema-less data).
            This interface is usually implemented by rows that support version changing between releases, i.e. when
            structured storage (such as Mongo DB) stores more fields than are currently declared in the row the extra fields will be placed
             in the AmorphousData collection. This interface also provides hook BeforeSave()/AfterLoad() that allow for transforms between
             Amorphous and "hard-schema" data models
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.IAmorphousData.BeforeSave(System.String)">
            <summary>
            Invoked to allow the entity (such as a row) to transform its state into AmorphousData bag.
            For example, this may be usefull to store extra data that is not a part of established business schema.
            The operation is performed per particular targetName (name of physical backend). Simply put, this method allows
             business code to "specify what to do before object gets saved in THE PARTICULAR TARGET backend store"
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.IAmorphousData.AfterLoad(System.String)">
            <summary>
            Invoked to allow the entity (such as a row) to hydrate its fields/state from AmorphousData bag.
            For example, this may be used to reconstruct some temporary object state that is not stored as a part of established business schema.
            The operation is performed per particular targetName (name of physical backend).
            Simply put, this method allows business code to "specify what to do after object gets loaded from THE PARTICULAR TARGET backend store".
            An example: suppose current MongoDB collection stores 3 fields for name, and we want to collapse First/Last/Middle name fields into one field.
            If we change rowschema then it will only contain 1 field which is not present in the database, however those 'older' fields will get populated
            into AmorphousData giving us an option to merge older 3 fields into 1 within AfterLoad() implementation
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.IAmorphousData.AmorphousDataEnabled">
            <summary>
            When true, enabled amorphous data behaviour, i.e. copying of amorphous data between rows.
            When false, the amorphous data is ignored as-if the type did not implement this interface
            This is needed for security, i.e. on the web returning false will prevent injection via posted forms
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.IAmorphousData.AmorphousData">
            <summary>
            Returns data that does not comply with known schema (dynamic data).
            The field names are NOT case-sensitive
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.AmorphousTypedRow.BeforeSave(System.String)">
            <summary>
            Invoked to allow the row to transform its state into AmorphousData bag.
            For example, this may be usefull to store extra data that is not a part of established business schema.
            The operation is performed per particular targetName (name of physical backend). Simply put, this method allows
             business code to "specify what to do before object gets saved in THE PARTICULAR TARGET backend store"
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.AmorphousTypedRow.AfterLoad(System.String)">
            <summary>
            Invoked to allow the row to hydrate its fields/state from AmorphousData bag.
            For example, this may be used to reconstruct some temporary object state that is not stored as a part of established business schema.
            The operation is performed per particular targetName (name of physical backend).
            Simply put, this method allows business code to "specify what to do after object gets loaded from THE PARTICULAR TARGET backend store".
            An example: suppose current MongoDB collection stores 3 fields for name, and we want to collapse First/Last/Middle name fields into one field.
            If we change rowschema then it will only contain 1 field which is not present in the database, however those 'older' fields will get populated
            into AmorphousData giving us an option to merge older 3 fields into 1 within AfterLoad() implementation
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.AmorphousTypedRow.AmorphousDataEnabled">
            <summary>
            True by default for rows
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.AmorphousTypedRow.AmorphousData">
            <summary>
            Returns data that does not comply with known schema (dynamic data). The field names are NOT case-sensitive
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FormModel.FormMode">
            <summary>
            Gets/sets form mode - unspecified|insert|edit. This field may be queried by validate and save, i.e. Validate may perform extra cross checks on Insert - i.e. check whether
            some other user is already registered with the specified email in this form etc.
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FormModel.CSRFToken">
            <summary>
            Gets/sets CSRF token
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.FormModel.SetRoundtripBagFromJSONString(System.String)">
            <summary>
            If non null or empty parses JSON content and sets the RoundtripBag
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.FormModel.Save``1(``0@)">
            <summary>
            Saves form into data store. The form is validated first and validation error is returned which indicates that save did not succeed due to validation error/s.
            The core implementation is in DoSave() that can also abort by either returning execption when predictable failure happens on save (i.e. key violation).
            Other exceptions are thrown.
            Returns extra result obtained during save i.e. a db-assigned auto-inc field
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.FormModel.Save(System.Object@)">
            <summary>
            Saves form into data store. The form is validated first and validation error is returned which indicates that save did not succeed due to validation error/s.
            The core implementation is in DoSave() that can also abort by either returning execption when predictable failure happens on save (i.e. key violation).
            Other exceptions are thrown.
            Returns extra result obtained during save i.e. a db-assigned auto-inc field
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.FormModel.DoSave(System.Object@)">
            <summary>
            Override to save model into data store. Return "predictable" exception (such as key violation) as a value instead of throwing.
            Throw only in "un-predictable" cases (such as DB connection is down, not enough space etc...).
            Return extra result obtained during save i.e. a db-assigned auto-inc field
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.FormModel.HasRoundtripBag">
            <summary>
            True if RoundtripBag is allocated
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.FormModel.RoundtripBag">
            <summary>
            Returns lazily-allocated RoundtripBag.
            Use HasRoundtripBag to see if it is allocated not to allocate on get
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.FormModel.AmorphousDataEnabled">
            <summary>
            False by default for forms, safer for web. For example, no injection of un-inteded fields can be done via web form post
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.FormModel.DataStoreTargetName">
            <summary>
            Returns the name of data store target obtained from App.DataStore by default.
            Override to supply a different name. This property is used for validation
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.TargetTableMapping">
            <summary>
            Provides information about targetname->table name, sequence name(and possibly other) mappings
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.DataParcelAttribute">
            <summary>
            Decorates Pacel-derivative classes specifying distributed data store options.
            Unlike the CRUD family of metadata attributes this attributed is NOT TARGETABLE on purpose
            beacause different sharding definitions would have affected the properties of the parcel which could have been
            very complex to maintain/account for. So, every parcel has ONLY ONE set opf metadata definition.
            In case when different parcel definitions needed a new parcel type should be created which can reuse the payload - this is much
             easier to implement (two parcels) than targeting within the same parcel.
            Table mappings are targetable
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.ICachePolicy.CacheWriteMaxAgeSec">
            <summary>
            Specifies for how long should this parcel be cached in RAM after a write (after a parcel gets saved).
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.ICachePolicy.CacheReadMaxAgeSec">
            <summary>
            Specifies the maximum age of parcel instance in cache to be suitable for reading
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.ICachePolicy.CachePriority">
            <summary>
            Specifies the relative cache priority of this parcel
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.ICachePolicy.CacheAbsoluteExpirationUTC">
            <summary>
            Specifies the absolute time when items expires in cache
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.ICachePolicy.CacheTableName">
            <summary>
            Specifies the name of cache table
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.DataParcelAttribute.GetParcelAttr(System.Type)">
            <summary>
            Returns DataParcelAttribute for a parcel type. Use Parcel.MetadataAttribute to
             obtain the attribute instance polymorphically for instance.
             If parcel is not decorated by the attribute then exception is thrown
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.SupportsMerge">
            <summary>
            Returns true if parcel supports merge with other versions.
            Server may merge multiple parcel versions to resolve versioning conflict.
            Default implementation returns false
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.ShardingParcel">
            <summary>
            Specifies the type of Parcel that is used for sharding. By default this parameter is null, so
            parcels are sharded on their own instance types, however there are cases when a parcel overrides ShardingID
             and specifies ShardingParcel type via this member so it gets stored along with the specified parcel
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.SchemaName">
            <summary>
            Specifies the name for logical schema that parcel decorated by this attribute belongs to.
            The exact location within the data store is detailed further with AreaName property.
            The value is required and is always specified or exception is thrown in .ctor
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.AreaName">
            <summary>
            Specifies the Areaname - the logical subdivision in the store where parcels reside within the schema(see SchemaName): i.e.  'commonClinicalData'.
            Depending on a particular store setup this logical name may or may not represent physical servers/locations in the store.
            Every store implementation maps logical paths to physical servers and/or shards. This feature provides very high degree
             of distributed database design flexibility, as some parcels may represent common/dictionary data that does not need to be sharded,
            whereas others may represent purely transactional high-volume data that needs to be sharded.
            The value is required and is always specified or exception is thrown in .ctor
            </summary>
            <remarks>
            Keep in mind that in a distributed database system various parcels may be stored not only in different locations, be optionally sharded,
            and even be stored in different back-end technologies (i.e. NoSQL/RDBMS/flat files)
            </remarks>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.ReplicationChannel">
            <summary>
            Specifies the name of the replication channel used to pump data between servers/data centers/locations
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.CacheWriteMaxAgeSec">
            <summary>
            Specifies for how long should this parcel be cached in RAM after a write (after a saved change).
            This property acts as a default, the runtime first checks parcel instance properties then reverts to this attribute
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.CacheReadMaxAgeSec">
            <summary>
            Specifies the maximum age of parcel instance in cache to be suitable for reading
            This property acts as a default, the runtime first checks parcel instance properties then reverts to this attribute
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.CachePriority">
            <summary>
            Specifies the relative cache priority of this parcel
            This property acts as a default, the runtime first checks parcel instance properties then reverts to this attribute
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.CacheTableName">
            <summary>
            Specifies the name of the cache table for this parcel
            This property acts as a default, the runtime first checks parcel instance properties then reverts to this attribute
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.CacheAbsoluteExpirationUTC">
            <summary>
            This property can not be set on the attribute level and always returns null
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.DataParcelAttribute.TableMappings">
            <summary>
            Returns mappins of target->table attributes. Pass in [DataParcel(targetTableMappings = "targetName1=tableName1{atr1=v1 atr2=v2...} targetName2=tableName2{atr1=v1 atr2=v2...}...")];
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.Command">
            <summary>
            Defines a command sent into an IDistributedDataStore implementor to retrieve or change(if supported) data.
            A Command is a named bag of paremeters where every parameter has a name and a value.
            Every command has a unique Identity(GUID) which represents a token of the whole command state (name, type,all params).
            The identity is used for quick lookup/caching. The identity may be supplied externally as
            business code may map certain parameters into GUID and later reuse the same GUID to retrieve the cached command result, for example
             a web server app may cache command "GetPurchases(user=123, year=2015, month=3)" under session key "MY_PURCHASES_201503" to later
             retrieve a cached (if available) command results from the DB layer, this way the DB server does not have to store the whole
             commands with all params as the cache key (which would have been slow to compare and would have induced GC pressure).
             Warning: DO NOT CACHE command identity value on a client (i.e. web page) in an un-encrypted state, as this is a security flaw
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.IShardingPointerProvider">
            <summary>
            Denotes an entity which provides a sharding parcel type along with sharding ID (ShardingPointer) that can be used to determine
            data location via conversion of this id into physical shard #(particular server) that this entity represents
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IShardingPointerProvider.ShardingPointer">
            <summary>
            Returns the parcel type and ID used for sharding.
            This pointer is converted into physical shard # (particular server) where data represented by this entity resides.
            WARNING! The ShardingPointer is immutable during the lifecycle of the entity. See Parcel.ShardingPointer
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Command.Identity">
            <summary>
            Returns the identity of this instance, that is - an ID that UNIQUELY identifies the instance of this command
            including all of the names, parameters, values. This is needed for Equality comparison and cache lookup.
            The identity is either generated by .ctor or supplied to it if it is cached (i.e. in a user session)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Command.Name">
            <summary>
            Returns Command name, providers use it to locate modules particular to backend implementation that they represent
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Command.ShardingPointer">
            <summary>
            Returns the ShardingPointer for this command
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Command.Item(System.String)">
            <summary>
            Returns parameter by its name or null
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Command.CacheWriteMaxAgeSec">
            <summary>
            Implements IParcelCachePolicy contract.
            The default implementation returns null.
            Override to supply a value for maximum length of this isntance stay in cache
             that may depend on particular command state (i.e. param values)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Command.CacheReadMaxAgeSec">
            <summary>
            Implements IParcelCachePolicy contract.
            The default implementation returns null.
            Override to supply a value for maximum validity span of cached command data
             that may depend on particular command state (i.e. param values).
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Command.CachePriority">
            <summary>
            Implements IParcelCachePolicy contract.
            The default implementation returns null.
            Override to supply a relative cache priority of this command data
             that may depend on particular command state (i.e. param values).
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Command.NFX#DataAccess#Distributed#ICachePolicy#CacheTableName">
            <summary>
            Implements IParcelCachePolicy contract.
            The implementation returns null for commands
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Command.CacheAbsoluteExpirationUTC">
            <summary>
            Implements IParcelCachePolicy contract.
            The default implementation returns null.
            Override to supply a different absolute cache expiration UTC timestamp for this command data
             that may depend on particular command state (i.e. field values).
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.Command.Param">
            <summary>
            Represents a distributed command parameter
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.NullCommandResult">
            <summary>
            Represents a result of command that is absent. This is needed to distinguish from null reference
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.ShardingPointer">
            <summary>
            Contains information about sharding parcel type and ID
            which is used to calculate the physical location of parcel data
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.DistributedDataAccessException">
            <summary>
            Thrown by distributed data access classes
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.DistributedDataParcelSerializationException">
            <summary>
            Thrown by distributed data access classes when parcel serialization problems happen
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.ParcelValidationException">
            <summary>
            Thrown by distributed data access classes  to indicate some data validation error
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.ParcelSealValidationException">
            <summary>
            Thrown by Parcel.Seal() method trying to ensure parcel consistency before it gets sealed
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.GDID">
            <summary>
            Represents a Global Distributed ID key (key field) used in distributed databases that identify entities with a combination of unsigned 32 bit integer
             'Era' and unsigned 64 bit integer 'ID'. The first 32 bit integer is an 'era' in which the 'ID' (64 bit) was created, consequently
            a GDID is a 12 byte = 96 bit integer that can hold 2^96 = 79,228,162,514,264,337,593,543,950,336 combinations.
            The ID consists of two segments: 4 bit authority + 60 bits counter. Authority segment occupies the most significant 4 bits of uint64, so
             the system may efficiently query the data store to identify the highest stored ID value in a range.
            Authorities identify one of 16 possible ID generation sources in the global distributed system, therefore ID duplications are not
            possible between authorities.
            Within a single era, GDID structure may identify 2^60 = 1,152,921,504,606,846,976(per authority) * 16(authorities) = 2^64 = 18,446,744,073,709,551,616 total combinations.
            Because of such a large number of combinations supported by GDID.ID alone (having the same Era), some systems may always use Era=0 and only store the ID part
            (i.e. as UNSIGNED BIGINT in SQL datastores).
            Note GDID.Zero is never returned by generators as it represents the absence of a value
            </summary>
        </member>
        <member name="T:NFX.DataAccess.IDataStoreKey">
            <summary>
            Decorator interface for entities used to uniquely identify entities in a store
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.GDID.COUNTER_MAX">
            <summary>
            Provides maximum value for counter segment
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.GDID.AUTHORITY_MAX">
            <summary>
            Provides maximum value for authority segment
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.GDID.Zero">
            <summary>
            Zero GDID singleton
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.GDID.ToString">
            <summary>
            Returns the guaranted parsable stable string representation of GDID in the form 'Era:Authority:Counter'
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.GDID.Authority">
            <summary>
            Returns the 0..15 index of the authority that issued this ID
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.GDID.Counter">
            <summary>
            Returns the 60 bits of counter segment of this id (without athority segment upper 4 bits)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.GDID.Bytes">
            <summary>
            Returns the GDID buffer as BigEndian Era:ID tuple
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.GDID.IsZero">
            <summary>
            True is this instance is invalid - represents 0:0:0
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.GDIDSymbol">
            <summary>
            Represents a tuple of GDID and its symbolic representation (framework usualy uses an ELink as symbolic representation).
            This struct is needed to pass GDID along with its ELink representation together.
            Keep in mind that string poses a GC load, so this stuct is not suitable for beiing used as a pile cache key
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.GDIDRangeComparer">
            <summary>
            Compares GDID regardless of authority. This is useful for range checking, when authorities generating GDIDs in the same
             range should be disregarded. Use GDIDRangeComparer.Instance.
             Only relative range comparison can be made.
             The Equality returned by this comparer can not be relied upon for GDID comparison as it disregards authority.
             Equality can only be tested for range comparison.
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.IDistributedDataStore">
             <summary>
             Represents a data store that works with large distributed systems that support OLTP-style processing
             and provide data querying, caching, partitioning/sharding, failover and replication.
             These systems are designed to handle billions of rows that need to be accessed by millions of active concurrent users,
              so the design is specific to this model that scales horizontally. There is no need to use this technology for medium and smaller data stores
              as it imposes specific requirements on how application is written/interacts with the backend system. This technology is based on the idea
              of Parcels - an atomic unit of data change. Parcels get replicated between hosts for failover and performance reasons.
             Note:
              NFX library does not provide the implementation for this technology, only marker interfaces so developers can plan for distributed backends
              in future
             </summary>
             <remarks>
             The structure of distributed data store:
            
              +------------------------------------------------------------------------------------------------------------+
              |                                            Data Store                                                      |
              |  +-------------------------------------------------------------------------+      +---------------------+  |
              |  |                             Bank = N 1 (Schema A)                       |      |      Bank   =  N 2  |  |
              |  | +----------+ +--------------------------------------------------------+ |      |      (Schema A)     |  |
              |  | |   Area   | +                 Area "UserData"                        | | ...  |                     |  |
              |  | | "common" | +-----------+-----------+-----------+-----------+--------+ |      |                     |  |
              |  | |          | +  Shard 1  |  Shard 2  |  Shard 3  |  Shard 4  |          |      |                     |  |
              |  | +----------+ |           |           |           |           |          |      +---------------------+  |
              |  |              +-----------+           |           |           |          |      +---------------------+  |
              |  | +----------------------+ |           +-----------+           |          |      |      Bank   =  N X  |  |
              |  | |Area "clinicalData"   | |           |           |           |          |      |      (Schema B)     |  |
              |  | |       /doctors       | |           |           |           |          | ...  |                     |  |
              |  | |       /codes         | |           |           |           |          |      |                     |  |
              |  | |       /diagnoses     | |           |           +-----------+          |      |                     |  |
              |  | +----------------------+ |           |                                  |      +---------------------+  |
              |  |                          +-----------+                                  |                               |
              |  +-------------------------------------------------------------------------+                               |
              +------------------------------------------------------------------------------------------------------------+
             Distributed data stores hold single or multiple named data banks instances: Bank = global data bank name, a named instance of a distributed database.
             Banks are logical isolation containers in large datasets. Store implementations may use it for physical isolation as well.
             Every bank implements a particular schema - a structure suitable for some business purpose.
             A store may support multiple schemas, but every particular database bank implements only one schema.
             Named instances of database banks with the same schema may be used to house data for different clients or environments.
             Bank name example: "PROD-Data", "DEV-Data", "EnterpriseA", "CustomerX" etc.
            
             Every Bank is further broken down by Areas that can be accessed/addressed by their names.
             Areas contain shards that partition large volumes of data horizontally, they define how data is partitioned and where it is stored
             </remarks>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IDistributedDataStore.BankNames(System.String)">
            <summary>
            Returns names of database bank instances in the store that implement the specified schema
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IDistributedDataStore.GetBank(System.String,System.String)">
            <summary>
            Returns Bank object by name within schema
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IDistributedDataStore.SchemaNames">
            <summary>
            Returns names of database bank schemas supported by the store.
            Every bank implements a particular schema
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.ISchema">
            <summary>
            Provides information about schema of data store banks. Schema defines areas of the bank, where every area
             defines what parcel types can be stored. Each bank implements only one bank schema
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.ISchema.DataStore">
            <summary>
            References data store that this schema is a part of
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.ISchema.Areas">
            <summary>
            Returns registry of named schema areas
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.ISchema.TargetSuffix">
            <summary>
            Returns target name suffix which is added at the end.
            This allows for detailed targeting of metadata for particular schema.
            In most cases this property returns null which means no specific schema targeting
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.IArea">
            <summary>
            Provides information about an area of a bank schema. This information does not depend on a particular bank instance,
             as it is common for all banks that implement the same schema.
            Area provides configuration information for parcels that it can store.
            Every instance of this (interface-implementer) class has a corresponding IAreaInstance instance that stores information
             for every particular bank, i.e. what distribution policies are applied (such as sharding) to the parcels stored in this area
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IArea.Schema">
            <summary>
            Returns schema that this area is in
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IArea.Description">
            <summary>
            Returns area description
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IArea.DeviceType">
            <summary>
            Returns the type of device driver that loads/stores data
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.DataVeracity">
            <summary>
            Stipulates levels of data fidality, the higher the level - the more accurately verified data is provided
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.DataVeracity.Maximum">
            <summary>
            The highest level of data accuracy - the backend will compare data from multiple storage mediums/devices to calculate the most accurate/latest data.
            This mode is the slowest among the others
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.DataVeracity.BackedUp">
            <summary>
            The backend will return the data which is stored in more than one device/medium
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.DataVeracity.Any">
            <summary>
            The backend will return the fist available data as soon as it finds it. This mode is the fastest however it may return
            data that has since been overwritten in some other storage devices/mediums.
            This mode may be used in cases when performance is paramount but 100% data accuracy is not really needed, i.e. when showing
            message/forum post comments on a social web site
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.DataCaching">
            <summary>
            Stipulates where data gets cached
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.DataCaching.None">
            <summary>
            Does not get cached
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.DataCaching.LatestData">
            <summary>
            Gets cached on the level where data is always accurate and never gets stale, i.e. in the BDB server that reflects most recent changes (can not get out of date)
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.DataCaching.Everywhere">
            <summary>
            Gets cached everywhere including system tiers where data can get stale
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.IBank">
            <summary>
            Provides abstraction for Global Database Bank instance
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.GetDescription(System.String)">
            <summary>
            Returns database description for the specific culture.
            This method is needed because end users may need to see the description of the database instance in their native language
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.GenerateReplicationVersionInfo(NFX.DataAccess.Distributed.Parcel)">
            <summary>
            Generates version replication information for the parcel instance which is being sealed
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.ObjectToShardingID(System.Object)">
            <summary>
            Returns ULONG for an object so any object (i.e. a string) may be used as a sharding key.
            Suppose a string needs to be used for sharding, this method translates a string into a 64 bit hash expressed as ulong
            </summary>
            <param name="key">An object used for sharding ID translation</param>
            <returns>UInt64 that represents the sharding ID</returns>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.Load(System.Type,NFX.DataAccess.Distributed.GDID,System.Object,NFX.DataAccess.Distributed.DataVeracity,NFX.DataAccess.Distributed.DataCaching,System.Nullable{System.Int32},NFX.ApplicationModel.ISession)">
            <summary>
            Loads parcel by fetching it from the bank backened by its primary id
            </summary>
            <param name="tParcel">Parcel type to load</param>
            <param name="id">The unique GDID of the parcel</param>
            <param name="shardingID">
            The ID of the entity used for sharding,
            i.e. a message may use ID of the item that the message relates to, so messages get sharded in the same location as their "parent" record.
            The parcel type T specifies the DataParcelAttirbute.GetParcelAttr(typeof(T)).ShardingParcel
            </param>
            <param name="veracity">The level of data veracity</param>
            <param name="cacheOpt">The cache control options</param>
            <param name="cacheMaxAgeSec">The maximum acceptable age of cached instance, cached data will be re-queried from backend if it is older</param>
            <param name="session">User session, if null session will be taken from execution context. The session may be needed for policy filtering</param>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.LoadAsync(System.Type,NFX.DataAccess.Distributed.GDID,System.Object,NFX.DataAccess.Distributed.DataVeracity,NFX.DataAccess.Distributed.DataCaching,System.Nullable{System.Int32},NFX.ApplicationModel.ISession)">
            <summary>
            Async version: Loads parcel by fetching it from the bank backened by its primary id
            </summary>
            <param name="tParcel">Parcel type to load</param>
            <param name="id">The unique GDID of the parcel</param>
            <param name="shardingID">
            The ID of the entity used for sharding,
            i.e. a message may use ID of the item that the message relates to, so messages get sharded in the same location as their "parent" record.
            The parcel type T specifies the DataParcelAttirbute.GetParcelAttr(typeof(T)).ShardingParcel
            </param>
            <param name="veracity">The level of data veracity</param>
            <param name="cacheOpt">The cache control options</param>
            <param name="cacheMaxAgeSec">The maximum acceptable age of cached instance, cached data will be re-queried from backend if it is older</param>
            <param name="session">User session, if null session will be taken from execution context. The session may be needed for policy filtering</param>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.Load``1(NFX.DataAccess.Distributed.GDID,System.Object,NFX.DataAccess.Distributed.DataVeracity,NFX.DataAccess.Distributed.DataCaching,System.Nullable{System.Int32},NFX.ApplicationModel.ISession)">
            <summary>
            Loads parcel by fetching it from the bank backened by its primary id
            </summary>
            <param name="id">The unique GDID of the parcel</param>
            <param name="shardingID">
            The ID of the entity used for sharding,
            i.e. a message may use ID of the item that the message relates to, so messages get sharded in the same location as their "parent" record.
            The parcel type T specifies the DataParcelAttirbute.GetParcelAttr(typeof(T)).ShardingParcel
            </param>
            <param name="veracity">The level of data veracity</param>
            <param name="cacheOpt">The cache control options</param>
            <param name="cacheMaxAgeSec">The maximum acceptable age of cached instance, cached data will be re-queried from backend if it is older</param>
            <param name="session">User session, if null session will be taken from execution context. The session may be needed for policy filtering</param>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.LoadAsync``1(NFX.DataAccess.Distributed.GDID,System.Object,NFX.DataAccess.Distributed.DataVeracity,NFX.DataAccess.Distributed.DataCaching,System.Nullable{System.Int32},NFX.ApplicationModel.ISession)">
            <summary>
            Async version: Loads parcel by fetching it from the bank backened by its primary id
            </summary>
            <param name="id">The unique GDID of the parcel</param>
            <param name="shardingID">
            The ID of the entity used for sharding,
            i.e. a message may use ID of the item that the message relates to, so messages get sharded in the same location as their "parent" record.
            The parcel type T specifies the DataParcelAttirbute.GetParcelAttr(typeof(T)).ShardingParcel
            </param>
            <param name="veracity">The level of data veracity</param>
            <param name="cacheOpt">The cache control options</param>
            <param name="cacheMaxAgeSec">The maximum acceptable age of cached instance, cached data will be re-queried from backend if it is older</param>
            <param name="session">User session, if null session will be taken from execution context. The session may be needed for policy filtering</param>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.Query(NFX.DataAccess.Distributed.Command,NFX.DataAccess.Distributed.DataVeracity,NFX.DataAccess.Distributed.DataCaching,System.Nullable{System.Int32},NFX.ApplicationModel.ISession)">
            <summary>
            Loads result object by executing a query command in the bank backend fetching necessary parcels/records/documents and aggregating the result.
            The query may return parcel/s that can be modified and saved back into the store
            </summary>
            <param name="command">The command object that contains command name and parameters to query the datastore</param>
            <param name="veracity">The level of data veracity</param>
            <param name="cacheOpt">The cache control options</param>
            <param name="cacheMaxAgeSec">The maximum acceptable age of cached instance, cached data will be re-queried from backend if it is older</param>
            <param name="session">User session, if null session will be taken from execution context. The session may be needed for policy filtering</param>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.QueryAsync(NFX.DataAccess.Distributed.Command,NFX.DataAccess.Distributed.DataVeracity,NFX.DataAccess.Distributed.DataCaching,System.Nullable{System.Int32},NFX.ApplicationModel.ISession)">
            <summary>
            Async version: Loads result object by executing a query command in the bank backend fetching necessary parcels/records/documents and aggregating the result.
            The query may return parcel/s that can be modified and saved back into the store
            </summary>
            <param name="command">The command object that contains command name and parameters to query the datastore</param>
            <param name="veracity">The level of data veracity</param>
            <param name="cacheOpt">The cache control options</param>
            <param name="cacheMaxAgeSec">The maximum acceptable age of cached instance, cached data will be re-queried from backend if it is older</param>
            <param name="session">User session, if null session will be taken from execution context. The session may be needed for policy filtering</param>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.Save(NFX.DataAccess.Distributed.Parcel,NFX.DataAccess.Distributed.DataCaching,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.DateTime},NFX.ApplicationModel.ISession)">
             <summary>
             Saves/sends the parcel into this bank
             </summary>
             <param name="parcel">parcel instance to save</param>
             <param name="cacheOpt">The cache control options</param>
             <param name="cachePriority">
             The relative priority of the item in cache.
             If null is passed then the value is obtained from the parcel instance
             </param>
             <param name="cacheMaxAgeSec">
             Specifies the duration of parcel lifespan in cache devices.
             If null is passed then the value is obtained from the parcel instance
             </param>
            <param name="cacheAbsoluteExpirationUTC">
             Specifies absolute expiration time for this parcel instance in cache.
             If null is passed then the value is obtained from the parcel instance
             </param>
             <param name="session">User session, if null session will be taken from execution context. The session may be needed for policy filtering</param>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.SaveAsync(NFX.DataAccess.Distributed.Parcel,NFX.DataAccess.Distributed.DataCaching,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.DateTime},NFX.ApplicationModel.ISession)">
             <summary>
             Async version: Saves/sends the parcel into this bank
             </summary>
             <param name="parcel">parcel instance to save</param>
             <param name="cacheOpt">The cache control options</param>
             <param name="cachePriority">
             The relative priority of the item in cache.
             If null is passed then the value is obtained from the parcel instance
             </param>
             <param name="cacheMaxAgeSec">
             Specifies the duration of parcel lifespan in cache devices.
             If null is passed then the value is obtained from the parcel instance
             </param>
            <param name="cacheAbsoluteExpirationUTC">
             Specifies absolute expiration time for this parcel instance in cache.
             If null is passed then the value is obtained from the parcel instance
             </param>
             <param name="session">User session, if null session will be taken from execution context. The session may be needed for policy filtering</param>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.Remove(System.Type,NFX.DataAccess.Distributed.GDID,System.Object,NFX.ApplicationModel.ISession)">
            <summary>
            Removes the parcel from the bank returning true if parcel was found and removed
            </summary>
            <param name="tParcel">Type of parcel to remove</param>
            <param name="id">The unique GDID of the parcel</param>
            <param name="shardingID">
            The ID of the entity used for sharding,
            i.e. a message may use ID of the item that the message relates to, so messages get sharded in the same location as their "parent" record.
            The parcel type T specifies the DataParcelAttirbute.ShardingParcel
            </param>
            <param name="session">User session, if null session will be taken from execution context. The session may be needed for policy filtering</param>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.RemoveAsync(System.Type,NFX.DataAccess.Distributed.GDID,System.Object,NFX.ApplicationModel.ISession)">
            <summary>
            Async version: Removes the parcel from the bank returning true if parcel was found and removed
            </summary>
            <param name="tParcel">Type of parcel to remove</param>
            <param name="id">The unique GDID of the parcel</param>
            <param name="shardingID">
            The ID of the entity used for sharding,
            i.e. a message may use ID of the item that the message relates to, so messages get sharded in the same location as their "parent" record.
            The parcel type T specifies the DataParcelAttirbute.ShardingParcel
            </param>
            <param name="session">User session, if null session will be taken from execution context. The session may be needed for policy filtering</param>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.Remove``1(NFX.DataAccess.Distributed.GDID,System.Object,NFX.ApplicationModel.ISession)">
            <summary>
            Removes the parcel from the bank returning true if parcel was found and removed
            </summary>
            <param name="id">The unique GDID of the parcel</param>
            <param name="shardingID">
            The ID of the entity used for sharding,
            i.e. a message may use ID of the item that the message relates to, so messages get sharded in the same location as their "parent" record.
            The parcel type T specifies the DataParcelAttirbute.ShardingParcel
            </param>
            <param name="session">User session, if null session will be taken from execution context. The session may be needed for policy filtering</param>
        </member>
        <member name="M:NFX.DataAccess.Distributed.IBank.RemoveAsync``1(NFX.DataAccess.Distributed.GDID,System.Object,NFX.ApplicationModel.ISession)">
            <summary>
            Async version: Removes the parcel from the bank returning true if parcel was found and removed
            </summary>
            <param name="id">The unique GDID of the parcel</param>
            <param name="shardingID">
            The ID of the entity used for sharding,
            i.e. a message may use ID of the item that the message relates to, so messages get sharded in the same location as their "parent" record.
            The parcel type T specifies the DataParcelAttirbute.ShardingParcel
            </param>
            <param name="session">User session, if null session will be taken from execution context. The session may be needed for policy filtering</param>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IBank.DataStore">
            <summary>
            References data store that this data bank is a part of
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IBank.Schema">
            <summary>
            Returns the schema that this bank implements
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IBank.Areas">
            <summary>
            Returns registry of named bank schema area instances
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IBank.Description">
            <summary>
            Returns database description
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IBank.IDGenerator">
            <summary>
            Returns sequence provider that generates unique identifiers in the store
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.IAreaInstance">
            <summary>
            Represents data for a concrete instance of schema area within banks, this depends on a concrete bank instance (unlike it's complementary part IArea)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IAreaInstance.Area">
            <summary>
            Returns schema area that this bank area represents - a prototype of this instance
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IAreaInstance.Bank">
            <summary>
            Returns bank instance that this area is in
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.IReplicatable">
            <summary>
            Denotes a distributed entity that can be replicated to a different location/site/instance.
            Normally only Parcel and its derivatives should implement this interface
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IReplicatable.ReplicationVersionInfo">
            <summary>
            Provides the information about this version of data that this isntance represents.
            Usually this object contains the name of the user who made a change, server/cluster node ID and/or machine name
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IReplicatable.ReplicationPriority">
            <summary>
            Returns the relative priority of replication, where 0=highest priority
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IReplicationVersionInfo.VersionDeleted">
            <summary>
            Returns true for items that have been marked for deletion
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.IReplicationVersionInfo.VersionUTCTimestamp">
            <summary>
            Provides a UTC timestamp for this version - when last change was made
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.CachePolicyData">
            <summary>
            Holds data per IParcelCachePolicy contract
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.ParcelState">
            <summary>
            Represents data parcel states - creating, modifying, sealed
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.Parcel">
            <summary>
            Describes a data parcel - a piece of logically-grouped data that gets fetched from/comitted into a distributed backend system.
            Parcels represent an atomic unit of change, a changeset that gets replicated between failover hosts.
            Every parcel has a Payload property that stores business data of interest that the parcel contains.
            This class is not thread-safe. Use DeepClone() to create 100% copies for working in multiple threads.
            This particular class serves as a very base for all Parcel implementations
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.Parcel.DEFAULT_REPLICATION_PRIORITY">
            <summary>
            Default priority of replication
            </summary>
        </member>
        <member name="F:NFX.DataAccess.Distributed.Parcel.STANDARD_KNOWN_SERIALIZER_TYPES">
            <summary>
            Defines well-known frequently used types for slim serializer compression
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.GetParcelCacheTableName(System.Type)">
            <summary>
            Obtains parcel cache name from either it's associated DataParcelAttribute or
             if not defined, from parcel type full name
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.#ctor">
            <summary>
            Used for serialization
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.#ctor(System.Object)">
            <summary>
            This ctor is never public, used with __ctor__injectID
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.#ctor(NFX.DataAccess.Distributed.GDID,System.Object)">
            <summary>
            Called when creating new Parcel instances by the original author.
            The new instance is in 'ParcelState.Creating' state
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.#ctor(NFX.DataAccess.Distributed.GDID,System.Object,NFX.DataAccess.Distributed.IReplicationVersionInfo)">
            <summary>
            Called by device to load parcel from storage.
            The new instance is in 'ParcelState.Sealed' state.
            Business logic devs - do not call
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.__ctor__injectID(NFX.DataAccess.Distributed.GDID)">
            <summary>
            Internal framework method, developers: never call
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.Open">
            <summary>
            Opens parcel for modification. Parcel must be in the Sealed state for this call and must not be ReadOnly.
            Once open for modification, a parcel can not be "UnOpened", only Seal()-ed. This is because there is no way to track
            whether some part of payload object has changed by the calling code. Use DeepClone() before calling Open to retain a copy of Sealed parcel
            to revert to the cloned instance instead
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.Seal(NFX.DataAccess.Distributed.IBank)">
            <summary>
            Seal parcel after modification
            May call this method on parcels in either Creating or Modifying states.
            Bank is used to create the ReplicationVersionInfo which is depends on store/bank implementation.
            Parcels can replicate only within stores/technologies that have sealed them
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.Merge(System.Collections.Generic.IEnumerable{NFX.DataAccess.Distributed.Parcel})">
            <summary>
            Merges other parcel instances into this one.
            A parcel type may support merging (when DataParcel attribute SupportsMerge is set to true) of data from other parcels/versions into this instance.
            This parcel must not be sealed as merge may change the payload in which case TRUE is returned. The parcel needs to be sealed again after the change.
            If a call to this method returns false, then nothing was changed as this instance already contains the latest data/could not be merged.
            Merging is used for version conflict resolution: servers check if the type of the updated parcel instance SupportsMerge, then if it does, Opens parcel
            and calls this method passing other versions in question to this method. The framework does not impose a limit on the supplied parcel types, however
            most of the parcel types support merge only with the same-typed parcel instances.
            IMPORTANT: The ordering of parcel versions is not guaranteed.
            </summary>
            <param name="others">Other parcel versions/data</param>
            <returns>True if Merge() generated newer version/changed payload. False when Merge did not/could not change existing parcel</returns>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.Validate(NFX.DataAccess.Distributed.IBank)">
            <summary>
            Performs validation of the data. Does not throw but populates validation exceptions if data is not valid.
            Bank context may be used to run sub-queries during consistency/crosschecks
            May call this method on parcels in either Creating or Modifying states
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.DeepClone">
            <summary>
            Duplicates this parcel by doing a complete deep-clone of its state via serialization.
            This method is useful for making copies of the same parcel for different threads as it is thread-safe while no other thread mutates the instance,
            however Parcel instances are NOT THREAD-SAFE for parallel changes.
            The existing parcel MUST be SEALED (otherwise it can not be serialized).
            This method is also used before a call to Open() if parcel needs to be "un-opened" the cloned instance may be reverted to
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.Equals(System.Object)">
            <summary>
            Tests for parcel equality based on the same type and GDID value
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.GetHashCode">
            <summary>
            Generates hash code based on parcel type and GDID value
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.DoOpen">
            <summary>
            Override to perform actions when parcel is unsealed (opened) for modification
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.DoSeal(NFX.DataAccess.Distributed.IBank)">
            <summary>
            Override to seal the parcel instance, i.e. generate some calculated fields.
            The version information is already generated by the time this method is called
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.DoMerge(System.Collections.Generic.IEnumerable{NFX.DataAccess.Distributed.Parcel})">
            <summary>
            Override to merge other parcels into this one. Return true if merge changed the payload. See Merge().
            This implementation throws an exception
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel.DoValidate(NFX.DataAccess.Distributed.IBank)">
            <summary>
            Override to perform parcel/payload validation after modification. Add validation exceptions into m_ValidationExceptions field.
            Use bank for cross-checks (i.e. may run queries to check consistency)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.GDID">
            <summary>
            Returns GDID for data that this parcel represents
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.ShardingPointer">
            <summary>
            Returns the ShardingPointer(type:ID) used for sharding, default implementation returns this parcel type and GDID.
            Override ShardingID property to return another sharding key, i.e. a social comment msg may use parent item (that the msg relates to) ID
            as the shard key so msgs are co-located with related items. Use CompositeShardingID to return multiple values.
             IMPORTANT!!! ShardingPointer must return an immutable value, the one that CAN NOT be changed during parcel payload life
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.ShardingID">
            <summary>
            Returns the ShardingID used for sharding, default implementation returns this parcel type and GDID.
            Override to return another sharding key, i.e. a social comment msg may use parent item (that the msg relates to) ID
            as the shard key so msgs are co-located with related items. Use CompositeShardingID to return multiple values.
             IMPORTANT!!! ShardingID must return an immutable value, the one that CAN NOT be changed during parcel payload life
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.ReplicationPriority">
            <summary>
            Returns replication priority, override to make replication priority dependent on instance, i.e. a user profile data for
             a celebrity user may need to have higher replication rate. The lower value indicates the higher priority
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.Payload">
            <summary>
            Returns payload of this parcel. This may be null for deleted parcels (VersionDeleted).
            WARNING!!! Although parcels do not allow to set Payload property if they are sealed, one can still mutate/modify the payload object graph
            even on a sealed parcel instance, i.e. one may write:
              <code>mySealedParcel.Payload.DueDates.Add(DateTime.Now) (given DueDates of type List(DateTime))</code>.
            This case is considered to be a bug in the calling-code. The framework has no way of preventing such an inadvertent behavior as there is no
            way to intercept a mutation via transitive or direct references/functors in an object graph referenced by Payload property because payload type
             does not impose (and should not) any constraints on what can be a payload.
            In Aum language we will use static type checker that will detect possible property access via Payload BEFORE calling Open()
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.ReadOnly">
            <summary>
            Indicates whether the data may be altered.
            ReadOnly parcels can not be Opened after that have been Sealed by their creator
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.State">
            <summary>
            Returns the state of the parcel: Creating|Modifying|Sealed
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.NewlySealed">
            <summary>
            Returns true when parcel was just sealed after a call to Open or .ctor/create.
            Datastore may check this flag and disallow saving of parcel instances that have not changed
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.ReplicationVersionInfo">
            <summary>
            Implements IReplicatable interface
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.CacheWriteMaxAgeSec">
            <summary>
            Implements IParcelCachePolicy contract.
            The default implementation returns null.
            Override to supply a value for maximum length of this isntance stay in cache
             that may depend on particular parcel payload state (i.e. field values)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.CacheReadMaxAgeSec">
            <summary>
            Implements IParcelCachePolicy contract.
            The default implementation returns null.
            Override to supply a value for maximum validity span of cached parcel
             that may depend on particular parcel payload state (i.e. field values).
            This property may be used to obtain a value before parcel is re-read from the store
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.CachePriority">
            <summary>
            Implements IParcelCachePolicy contract.
            The default implementation returns null.
            Override to supply a relative cache priority of this parcel
             that may depend on particular parcel payload state (i.e. field values).
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.NFX#DataAccess#Distributed#ICachePolicy#CacheTableName">
            <summary>
            Implements IParcelCachePolicy contract.
            The implementation returns null for parcel.
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.CacheAbsoluteExpirationUTC">
            <summary>
            Implements IParcelCachePolicy contract.
            The default implementation returns null.
            Override to supply a different absolute cache expiration UTC timestamp for this parcel
             that may depend on particular parcel payload state (i.e. field values).
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.ValidationExceptions">
            <summary>
            Returns validation exceptions - populated by a call to Validate
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.MetadataAttribute">
            <summary>
            Returns DataParcelAttribute that describes this parcel. Every parcel MUST be decorated by the DataParcel attribute
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel.EffectiveCachePolicy">
            <summary>
            Returns effective cache policy the one that is calculated from attribute and overidden by the instance
            </summary>
        </member>
        <member name="T:NFX.DataAccess.Distributed.Parcel`1">
            <summary>
            Describes a data parcel - a piece of logically-grouped data that gets fetched from/comitted into a distributed backend system.
            Parcels represent an atomic unit of change, a changeset that gets replicated between failover hosts.
            Every parcel has a Payload property that stores business data of interest that the parcel contains.
            This class is not thread-safe.
            This particular class serves as a very base for distributed data store implementations
            </summary>
            <typeparam name="TPayload">Type of payload that parcel carries</typeparam>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel`1.#ctor">
            <summary>
            Used for serialization
            </summary>
        </member>
        <member name="M:NFX.DataAccess.Distributed.Parcel`1.#ctor(`0)">
            <summary>
            This ctor is never public, used with __ctor__injectID
            </summary>
        </member>
        <member name="P:NFX.DataAccess.Distributed.Parcel`1.Payload">
            <summary>
            Returns payload of this parcel. May be null for deleted parcels (VersionDeleted)
            </summary>
        </member>
        <member name="T:NFX.DataAccess.StoreLogLevel">
            <summary>
            Defines log level for DataStores
            </summary>
        </member>
        <member name="T:NFX.DataAccess.StoreFlag">
            <summary>
            Determines whether entity should be loaded/stored from/to storage
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CharCase">
            <summary>
            Types of char casing
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CharCase.AsIs">
            <summary>
            The string remains as-is
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CharCase.Upper">
            <summary>
            The string is converted to upper case
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CharCase.Lower">
            <summary>
            The string is converted to lower case
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CharCase.Caps">
            <summary>
            The first and subsequent chars after space or '.' are capitalized, the rest left intact
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CharCase.CapsNorm">
            <summary>
            The first and subsequent chars after space or '.' are capitalized, the rest is lower-cased
            </summary>
        </member>
        <member name="T:NFX.DataAccess.ISequenceInfo">
            <summary>
            Provides basic information about a named sequence.
            Warning!!! This class represents informational-only data which CAN NOT be used for real identification
            </summary>
        </member>
        <member name="P:NFX.DataAccess.ISequenceInfo.Era">
            <summary>
            Current Era in which the IDs are generated. This CAN NOT be used to obtain real ID, just the info
            </summary>
        </member>
        <member name="P:NFX.DataAccess.ISequenceInfo.ApproximateCurrentValue">
            <summary>
            Approximate current ID. This CAN NOT be used to obtain real ID, just the info
            </summary>
        </member>
        <member name="P:NFX.DataAccess.ISequenceInfo.TotalPreallocation">
            <summary>
            The size of block (if any) that was pre-allocated (instead of generating IDs every time)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.ISequenceInfo.RemainingPreallocation">
            <summary>
            Remaining IDs from the preallocated count
            </summary>
        </member>
        <member name="P:NFX.DataAccess.ISequenceInfo.IssuerName">
            <summary>
            The name of issuing authority
            </summary>
        </member>
        <member name="P:NFX.DataAccess.ISequenceInfo.IssueUTCDate">
            <summary>
            Time stamp of issue
            </summary>
        </member>
        <member name="T:NFX.DataAccess.ConsecutiveUniqueSequenceIDs">
            <summary>
            Represents a starting ID along with the number of consecutive generated IDs of the sequence
            </summary>
        </member>
        <member name="T:NFX.DataAccess.IUniqueSequenceProvider">
            <summary>
            Represents an entity that provides unique identifiers via named sequences
            </summary>
        </member>
        <member name="M:NFX.DataAccess.IUniqueSequenceProvider.GetSequenceInfos(System.String)">
            <summary>
            Returns sequnce information enumerable for all sequences in the named scope
            </summary>
        </member>
        <member name="M:NFX.DataAccess.IUniqueSequenceProvider.GenerateOneSequenceID(System.String,System.String,System.Int32,System.Nullable{System.UInt64},System.Boolean)">
            <summary>
            Generates one ID for the supplied sequence name.
            Note: do not confuse with block pre-allocation, which is an internal optimization.
            Even if 100 IDs are pre-allocated the method returns one unique ID
            </summary>
            <param name="scopeName">The name of scope where sequences are kept</param>
            <param name="sequenceName">The name of sequence within the scope for which ID to be obtained</param>
            <param name="blockSize">If >0 specifies how many sequence values to pre-allocate, otherwise provider would use its default setting</param>
            <param name="vicinity">The location on ID counter scale, the issuing authority may disregard this parameter</param>
            <param name="noLWM">
             When true, does not start async fetch of the next ID block while the current block reaches low-water-mark.
             This may not be desired in some short-lived processes.
             The provider may disregard this flag
            </param>
            <returns>The new ULONG sequence value</returns>
        </member>
        <member name="M:NFX.DataAccess.IUniqueSequenceProvider.TryGenerateManyConsecutiveSequenceIDs(System.String,System.String,System.Int32,System.Nullable{System.UInt64},System.Boolean)">
            <summary>
            Tries to generate many consecutive IDs. If the reserved block gets exhausted, then the returned ID count may be less than requested.
            </summary>
            <param name="scopeName">The name of scope where sequences are kept</param>
            <param name="sequenceName">The name of sequence within the scope for which ID to be obtained</param>
            <param name="idCount">How many Consecutive IDs should the system try to reserve</param>
            <param name="vicinity">The location on ID counter scale, the issuing authority may disregard this parameter</param>
            <param name="noLWM">
             When true, does not start async fetch of the next ID block while the current block reaches low-water-mark.
             This may not be desired in some short-lived processes.
             The provider may disregard this flag
            </param>
            <returns>The first uniqueID along with the number of Consecutive IDs that the system could allocate which can be less than requested number of IDs</returns>
        </member>
        <member name="P:NFX.DataAccess.IUniqueSequenceProvider.SequenceScopeNames">
            <summary>
            Returns the list of all scope names in the instance
            </summary>
        </member>
        <member name="T:NFX.DataAccess.IGDIDProvider">
            <summary>
            Represents an entity that provides unique Global Distributed IDs (GDIDs) via named sequences.
            Note: GDID.Zero is never returned as it indicates the absence of a value
            </summary>
        </member>
        <member name="M:NFX.DataAccess.IGDIDProvider.GenerateOneGDID(System.String,System.String,System.Int32,System.Nullable{System.UInt64},System.Boolean)">
            <summary>
            Generates Globally-Unique distributed ID (GDID) for the supplied sequence name.
            Note: do not confuse with block pre-allocation, which is an internal optimization.
            Even if 100 IDs are pre-allocated the method returns one unique GDID
            </summary>
            <param name="scopeName">The name of scope where sequences are kept</param>
            <param name="sequenceName">The name of sequence within the scope for which ID to be obtained</param>
            <param name="blockSize">If >0 specifies how many sequence values to pre-allocate, otherwise provider would use its default setting</param>
            <param name="vicinity">The location on ID counter scale, the authority may disregard this parameter</param>
            <param name="noLWM">
             When true, does not start async fetch of the next ID block while the current block reaches low-water-mark.
             This may not be desired in some short-lived processes.
             The provider may disregard this flag
            </param>
            <returns>The GDID instance</returns>
        </member>
        <member name="M:NFX.DataAccess.IGDIDProvider.TryGenerateManyConsecutiveGDIDs(System.String,System.String,System.Int32,System.Nullable{System.UInt64},System.Boolean)">
            <summary>
            Tries to generate many consecutive Globally-Unique distributed ID (GDID) from the same authority for the supplied sequence name.
            If the reserved block gets exhausted, then the returned ID array length may be less than requested
            </summary>
            <param name="scopeName">The name of scope where sequences are kept</param>
            <param name="sequenceName">The name of sequence within the scope for which ID to be obtained</param>
            <param name="gdidCount">How many Consecutive GDIDs from the same authority should the system try to reserve</param>
            <param name="vicinity">The location on ID counter scale, the authority may disregard this parameter</param>
            <param name="noLWM">
             When true, does not start async fetch of the next ID block while the current block reaches low-water-mark.
             This may not be desired in some short-lived processes.
             The provider may disregard this flag
            </param>
            <returns>The GDID[] instance which may have less elements than requested by gdidCount</returns>
        </member>
        <member name="P:NFX.DataAccess.IGDIDProvider.TestingAuthorityNode">
            <summary>
            Gets/sets Authority Glue Node for testing. It can only be set once in the testing app container init before the first call to
             Generate is made. When this setting is set then any cluster authority nodes which would have been normally used will be
             completely bypassed during block allocation
            </summary>
        </member>
        <member name="T:NFX.ELink">
            <summary>
            Represents an Electronic Link which is an alpha-encoded identifier along with metadata information.
            Warning! This class MAY generate fragments of profanity, however any ID can be regenerated using a different seed passed to Encode(seed)
            </summary>
        </member>
        <member name="F:NFX.ELink.VARIATIONS">
            <summary>
            Represents how many variations every link has (seeds)
            </summary>
        </member>
        <member name="M:NFX.ELink.#ctor(System.UInt64,System.Byte[])">
            <summary>
            Creates an Elink instance initialized with GDID of 0 Era having its ID set to ulong value
            </summary>
        </member>
        <member name="M:NFX.ELink.#ctor(NFX.DataAccess.Distributed.GDID,System.Byte[])">
            <summary>
            Create ELink instance from GDID (with era).
            </summary>
        </member>
        <member name="M:NFX.ELink.Encode(System.Nullable{System.Byte})">
            <summary>
            Encodes a link into a textual form, using the supplied randomization seed, otherwise the system rnd is used.
            A seed has 4 effective bits, yielding 16 possible variations for every link
            </summary>
        </member>
        <member name="P:NFX.ELink.ID">
            <summary>
            Returns the ID portion of GDID represented by this instance
            </summary>
        </member>
        <member name="P:NFX.ELink.Metadata">
            <summary>
            Returns metadata attached to this instance, or null if there is no metadata specified
            </summary>
        </member>
        <member name="P:NFX.ELink.Link">
            <summary>
            Returns a link encoded as a string using whatever randomization seed was passed to the last Encode(seed) call.
            If Encode() was not called, then the link will get encoded using system rnd for a seed value
            </summary>
        </member>
        <member name="P:NFX.ELink.GDID">
            <summary>
            Returns the GDID that this link represents
            </summary>
        </member>
        <member name="T:NFX.ExternalRandomGenerator">
            <summary>
            Represents a random generator which is based on System.Random() yet has an ability to feed external samples into it.
             Use ExtrenalRandomGenerator.Instance to use the default thread-safe instance.
            </summary>
            <remarks>
            Introduces external entropy into the generation sequence by adding a sample into the ring buffer.
            Call FeedExternalEntropySample(int sample) method from places that have true entropy values, i.e.
             a network-related code may have good entropy sources in server applications.
             External entropy sources may rely on user-dependent actions, i.e.:
              number of bytes/requests received per second, dollar(or cent remainders) amount of purchases made (on a server),
              zip codes of customers, IP addresses of site visitors, average noise level sampled on an open WAVE device(microphone),
               mouse position (i.e. in GUI app) etc...
             This class MAY be crypto-safe if it is fed a good entropy data at high rate, however that depends on the use pattern.
             The framework implementation feeds some entropy from Glue and cache components infrequently (once every few seconds),
              which is definitely not strong for cryptography
            </remarks>
        </member>
        <member name="M:NFX.ExternalRandomGenerator.#ctor">
            <summary>
            Create new instance of ExternalRandomGenerator. Create new instances only if you need to use different sample ring buffers.
            In majority of cases use ExternalRandomGenerator.Instance to use default instance instead of creating a new instance.
            Default instance is thread-safe for process-wide use
            </summary>
        </member>
        <member name="M:NFX.ExternalRandomGenerator.NextScaledRandomDouble(System.Double,System.Double)">
            <summary>
            Generates random double number in min..max range
            </summary>
        </member>
        <member name="M:NFX.ExternalRandomGenerator.FeedExternalEntropySample(System.Int32)">
            <summary>
            Introduces external entropy into the generation sequence by adding a sample into the ring buffer.
            Call this method from places that have true entropy values, i.e.
             a network-related code may have good entropy sources in server applications.
             External entropy sources may rely on user-dependent actions, i.e.:
              number of bytes/requests received per second, dollar(or cent remainders) amount of purchases made (on a server),
              zip codes of customers, IP addresses of site visitors, average noise level sampled on an open WAVE device(microphone),
               mouse position (i.e. in GUI app) etc...
            </summary>
        </member>
        <member name="M:NFX.ExternalRandomGenerator.NextScaledRandomInteger(System.Int32,System.Int32)">
            <summary>
            Generates random number in min..max range
            </summary>
        </member>
        <member name="M:NFX.ExternalRandomGenerator.NextRandomWebSafeString(System.Int32,System.Int32)">
            <summary>
            Generates a random string of chars which are safe for the use on the web -
             a string that only contains "a-z"/"A-Z" and "0-9" and "-"/"_" chars, i.e.: "bo7O0EFasZe-wEty9w0__JiOKk81".
            The length of the string can not be less than 4 and more than 1024 chars
            </summary>
        </member>
        <member name="M:NFX.ExternalRandomGenerator.NextRandomWebSafeSecureBuffer(System.Int32,System.Int32)">
            <summary>
            Generates a random secure buffer of chars which are safe for the use on the web -
             a string that only contains "a-z"/"A-Z" and "0-9" and "-"/"_" chars, i.e.: "bo7O0EFasZe-wEty9w0__JiOKk81".
            The length of the string can not be less than 4 and more than 1024 chars
            </summary>
        </member>
        <member name="M:NFX.ExternalRandomGenerator.NextRandomBytes(System.Int32)">
            <summary>
            Generates a random buffer of bytes
            </summary>
        </member>
        <member name="M:NFX.ExternalRandomGenerator.NextRandomBytes(System.Int32,System.Int32)">
            <summary>
            Generates a random buffer of bytes
            </summary>
        </member>
        <member name="M:NFX.ExternalRandomGenerator.NextRandomSecureBuffer(System.Int32)">
            <summary>
            Generates a random secure buffer of bytes
            </summary>
        </member>
        <member name="M:NFX.ExternalRandomGenerator.NextRandomSecureBuffer(System.Int32,System.Int32)">
            <summary>
            Generates a random secure buffer of bytes
            </summary>
        </member>
        <member name="P:NFX.ExternalRandomGenerator.Instance">
            <summary>
            Returns the default instance of the generator. This instance is thread-safe
            </summary>
        </member>
        <member name="P:NFX.ExternalRandomGenerator.NextRandomInteger">
            <summary>
            Generates next random integer in the Int32.MinValue..Int32.MaxValue diapason
            </summary>
        </member>
        <member name="P:NFX.ExternalRandomGenerator.NextRandomUnsignedInteger">
            <summary>
            Generates next random integer in the Uint32.MinValue..Uint32.MaxValue diapason
            </summary>
        </member>
        <member name="P:NFX.ExternalRandomGenerator.NextRandomUnsignedLong">
            <summary>
            Generates next random ulong in the Uint64.MinValue..Uint64.MaxValue range
            </summary>
        </member>
        <member name="P:NFX.ExternalRandomGenerator.NextRandom16Bytes">
            <summary>
            Generates random byte[16] buffer
            </summary>
        </member>
        <member name="P:NFX.ExternalRandomGenerator.NextRandomDouble">
            <summary>
            Returns 0..1 random double
            </summary>
        </member>
        <member name="T:NFX.Financial.Amount">
            <summary>
            Represents monetary amount with currency
            </summary>
        </member>
        <member name="M:NFX.Financial.Amount.IsSameCurrencyAs(NFX.Financial.Amount)">
            <summary>
            Perfoms case-insensitive currency equality comparison
            </summary>
        </member>
        <member name="T:NFX.Financial.FinancialException">
            <summary>
            Base exception thrown by the financial-related framework
            </summary>
        </member>
        <member name="T:NFX.Financial.Market.CandleSample">
            <summary>
            Represents data for a candle sample
            </summary>
        </member>
        <member name="T:NFX.Financial.Market.TimeSeriesSampleBase">
            <summary>
            Represents a sample of a TimeSeries stream
            </summary>
        </member>
        <member name="T:NFX.Financial.Market.ITimeSeriesSample">
            <summary>
            Represents a sample of a TimeSeries stream
            </summary>
        </member>
        <member name="T:NFX.Financial.Market.ITimedSample">
            <summary>
            Represents an interface to an object that has a timestamp
            </summary>
        </member>
        <member name="P:NFX.Financial.Market.ITimedSample.TimeStamp">
            <summary>
            Timestamp of the sample
            </summary>
        </member>
        <member name="M:NFX.Financial.Market.ITimeSeriesSample.MakeAggregateInstance">
            <summary>
            Makes aggregate instance
            </summary>
        </member>
        <member name="M:NFX.Financial.Market.ITimeSeriesSample.AggregateSample(NFX.Financial.Market.ITimeSeriesSample)">
            <summary>
            Adds a sample to this aggregation instance
            </summary>
        </member>
        <member name="M:NFX.Financial.Market.ITimeSeriesSample.SummarizeAggregation">
            <summary>
            Summarizes aggregation on this isntance
            </summary>
        </member>
        <member name="P:NFX.Financial.Market.ITimeSeriesSample.AssociatedData">
            <summary>
            Associates an arbitrary data
            </summary>
        </member>
        <member name="P:NFX.Financial.Market.TimeSeriesSampleBase.AssociatedData">
            <summary>
            Associates an arbitrary data
            </summary>
        </member>
        <member name="M:NFX.Financial.Market.CandleSample.Add(System.Single,System.Int64)">
            <summary>
            Add a price to current candle sample
            </summary>
            <param name="price">Price to be added</param>
            <param name="qty">
              Quantity to be added.
              Use positive values for Buy-side quantity and negative for Sell-side quantity
            </param>
        </member>
        <member name="M:NFX.Financial.Market.CandleSample.GenerateRandom(System.Int32,System.DateTime,System.Int32,System.Int32,System.Int32,System.Int32,System.Single)">
            <summary>
            Generates random market candle stream
            </summary>
        </member>
        <member name="P:NFX.Financial.Market.CandleSample.TimeSpanMs">
            <summary>
            Timespan in MS that this candle covers, may not be always needed
            </summary>
        </member>
        <member name="M:NFX.Financial.Market.SamplingUtils.SynthesizeCandles(System.Collections.Generic.IEnumerable{NFX.Financial.Market.ITimeSeriesSample},System.UInt32,System.Action{NFX.Financial.Market.CandleSample,NFX.Financial.Market.SecDb.SecDBFileReader.QuoteSample,System.Int32},System.Action{NFX.Financial.Market.CandleSample,NFX.Financial.Market.SecDb.SecDBFileReader.TradeSample,System.Int32})">
            <summary>
            Synthesizes a stream of candle samples from Quote and Trade samples coming from the market (i.e SecDB file)
            </summary>
            <param name="source">Source of market data</param>
            <param name="secSamplingPeriod">The output sampling period</param>
            <param name="funcQuote">Aggregation func for Quote, if null default is used which aggregates best bid</param>
            <param name="funcTrade">Aggregation func for Quote, if null default is used which aggregates buy and sell volumes</param>
            <returns>Synthesized candle stream</returns>
        </member>
        <member name="M:NFX.Financial.Market.SamplingUtils.SynthesizeCandles``1(System.Collections.Generic.IEnumerable{NFX.Financial.Market.ITimeSeriesSample},System.UInt32,System.Action{``0,NFX.Financial.Market.SecDb.SecDBFileReader.QuoteSample,System.Int32},System.Action{``0,NFX.Financial.Market.SecDb.SecDBFileReader.TradeSample,System.Int32})">
            <summary>
            Synthesizes a stream of candle samples from Quote and Trade samples coming from
            a market data source (i.e SecDB file)
            </summary>
            <param name="source">Source of market data</param>
            <param name="secSamplingPeriod">The output sampling period</param>
            <param name="funcQuote">Aggregation func for Quote, if null default is used which aggregates best bid</param>
            <param name="funcTrade">Aggregation func for Quote, if null default is used which aggregates buy and sell volumes</param>
            <returns>Synthesized candle stream</returns>
        </member>
        <member name="M:NFX.Financial.Market.SamplingUtils.AggregateHomogeneousSamples(System.Collections.Generic.IEnumerable{NFX.Financial.Market.ITimeSeriesSample},System.UInt32,System.Single)">
            <summary>
            Aggregates source stream of the normally equidistant samples of the same type by the specified factor
            </summary>
            <param name="source">Source stream</param>
            <param name="times">Factor of aggergation, i.e. 4x means aggregate 4 samples into one</param>
            <param name="samplingRateVariationPct">
             The allowed variation in timing between samples, once this variation is exceeded the system emits new aggregate
            </param>
            <returns>Aggregated sample stream</returns>
        </member>
        <member name="T:NFX.Financial.Market.SecDb.SecDBFileReader">
            <summary>
            Represents SecDB file. This class is thread-safe.
            See: https://github.com/saleyn/secdb/wiki/Data-Format
            </summary>
            <summary>
            Represents SecDB file. This class is thread-safe.
            See: https://github.com/saleyn/secdb/wiki/Data-Format
            </summary>
        </member>
        <member name="M:NFX.Financial.Market.SecDb.SecDBFileReader.GetCandleHeader(System.UInt32)">
            <summary>
            Tries to find a CandleHeader with the exact specified resolution or unassigned header
            </summary>
        </member>
        <member name="M:NFX.Financial.Market.SecDb.SecDBFileReader.GetCandleData(System.UInt32,System.Int32)">
            <summary>
            Tries to find a candle stream with the specified exact resolution skipping the specified number of seconds and returns it, or
            returns an empty enumerable if resolution is not available
            </summary>
        </member>
        <member name="M:NFX.Financial.Market.SecDb.SecDBFileReader.GetCandleData(System.UInt32,System.DateTime)">
            <summary>
            Tries to find a candle stream with the specified exact resolution and returns it starting from the specified start time, or
            returns an empty enumerable if resolution is not available
            </summary>
        </member>
        <member name="M:NFX.Financial.Market.SecDb.SecDBFileReader.GetCandleData(NFX.Financial.Market.SecDb.SecDBFileReader.CandleHeader,System.DateTime)">
            <summary>
            Returns candle data at the specified resolution starting at the specified start time
            </summary>
        </member>
        <member name="M:NFX.Financial.Market.SecDb.SecDBFileReader.GetCandleData(NFX.Financial.Market.SecDb.SecDBFileReader.CandleHeader,System.Int32)">
            <summary>
            Returns candle data at the specified resolution skipping the first specified number of seconds
            </summary>
        </member>
        <member name="M:NFX.Financial.Market.SecDb.SecDBFileReader.GetCandleDataAsCandleSamples(System.UInt32,System.DateTime)">
            <summary>
            Tries to find a candle stream returned as CandleSamples with the specified exact resolution starting at the specified start time and returns it, or
            returns an empty enumerable if resolution is not available
            </summary>
        </member>
        <member name="M:NFX.Financial.Market.SecDb.SecDBFileReader.GetCandleDataAsCandleSamples(System.UInt32,System.Int32)">
            <summary>
            Tries to find a candle stream returned as CandleSamples with the specified exact resolution skipping the specofoed number of seconds and returns it, or
            returns an empty enumerable if resolution is not available
            </summary>
        </member>
        <member name="M:NFX.Financial.Market.SecDb.SecDBFileReader.GetCandleDataAsCandleSamples(NFX.Financial.Market.SecDb.SecDBFileReader.CandleHeader,System.DateTime)">
            <summary>
            Returns candle data at the specified resolution starting at the specified start time
            </summary>
        </member>
        <member name="M:NFX.Financial.Market.SecDb.SecDBFileReader.GetCandleDataAsCandleSamples(NFX.Financial.Market.SecDb.SecDBFileReader.CandleHeader,System.Int32)">
            <summary>
            Returns candle data at the specified resolution skipping the first specified number of seconds
            </summary>
        </member>
        <member name="M:NFX.Financial.Market.SecDb.SecDBFileReader.GetStreamData(System.UInt32,System.DateTime)">
            <summary>
            Tries to find a candle stream by resolution and returns stream data starting from the specified UTC start time
            </summary>
        </member>
        <member name="M:NFX.Financial.Market.SecDb.SecDBFileReader.GetStreamData(System.UInt32,System.Int32)">
            <summary>
            Tries to find a candle stream by resolution and return stream data skipping the specified seconds count from data start
            </summary>
        </member>
        <member name="M:NFX.Financial.Market.SecDb.SecDBFileReader.GetStreamData(NFX.Financial.Market.SecDb.SecDBFileReader.CandleHeader,System.DateTime)">
            <summary>
            Gets stream data per candle header index starting from the specified UTC start time
            </summary>
        </member>
        <member name="M:NFX.Financial.Market.SecDb.SecDBFileReader.GetStreamData(NFX.Financial.Market.SecDb.SecDBFileReader.CandleHeader,System.Int32)">
            <summary>
            Gets stream data per candle header index skipping the specified seconds count from data start
            </summary>
        </member>
        <member name="M:NFX.Financial.Market.SecDb.SecDBFileReader.GetAllStreamData">
            <summary>
            Gets all stream data
            </summary>
        </member>
        <member name="P:NFX.Financial.Market.SecDb.SecDBFileReader.SystemHeader">
            <summary>
            Returns the required/system portion of the file header
            </summary>
        </member>
        <member name="P:NFX.Financial.Market.SecDb.SecDBFileReader.Headers">
            <summary>
            File headers dictionary, including the required ones
            </summary>
        </member>
        <member name="P:NFX.Financial.Market.SecDb.SecDBFileReader.CandlesMetadata">
            <summary>
            Returns metadata for candles in the file - collection of candle headers
            </summary>
        </member>
        <member name="T:NFX.Financial.Market.SecDb.SecDBFileReader.FileRequiredHeader">
            <summary>
            Contains data from the REQUIRED/system protion of the file header
            </summary>
        </member>
        <member name="F:NFX.Financial.Market.SecDb.SecDBFileReader.FileRequiredHeader.Shebang">
            <summary>
            .NIX shebang line
            </summary>
        </member>
        <member name="F:NFX.Financial.Market.SecDb.SecDBFileReader.FileRequiredHeader.Version">
            <summary>
            File format version
            </summary>
        </member>
        <member name="F:NFX.Financial.Market.SecDb.SecDBFileReader.FileRequiredHeader.Date">
            <summary>
            UTC date of market data
            </summary>
        </member>
        <member name="F:NFX.Financial.Market.SecDb.SecDBFileReader.FileRequiredHeader.OriginLocalTimeOffset">
            <summary>
            Offset of the origin local time from UTC
            </summary>
        </member>
        <member name="F:NFX.Financial.Market.SecDb.SecDBFileReader.FileRequiredHeader.OriginLocalTimeName">
            <summary>
            The name of the origin local time zone/location
            </summary>
        </member>
        <member name="F:NFX.Financial.Market.SecDb.SecDBFileReader.FileRequiredHeader.Exchange">
            <summary>
            Exchange producing market data
            </summary>
        </member>
        <member name="F:NFX.Financial.Market.SecDb.SecDBFileReader.FileRequiredHeader.Symbol">
            <summary>
            Company-specific security name
            </summary>
        </member>
        <member name="F:NFX.Financial.Market.SecDb.SecDBFileReader.FileRequiredHeader.Instrument">
            <summary>
            Exchange-specific security name
            </summary>
        </member>
        <member name="F:NFX.Financial.Market.SecDb.SecDBFileReader.FileRequiredHeader.SecurityId">
            <summary>
            Exchange-specific security ID
            </summary>
        </member>
        <member name="F:NFX.Financial.Market.SecDb.SecDBFileReader.FileRequiredHeader.Depth">
            <summary>
            Max depth of market quote levels
            </summary>
        </member>
        <member name="F:NFX.Financial.Market.SecDb.SecDBFileReader.FileRequiredHeader.PriceStep">
            <summary>
            Instrument's minimal price step
            </summary>
        </member>
        <member name="F:NFX.Financial.Market.SecDb.SecDBFileReader.FileRequiredHeader.UUID">
            <summary>
            Company-specific unique file ID
            </summary>
        </member>
        <member name="T:NFX.Financial.Market.SecDb.SecDBFileReader.CompressionType">
            <summary>
            Denotes compression types. Used in StreamMeta
            </summary>
        </member>
        <member name="T:NFX.Financial.Market.SecDb.SecDBFileReader.StreamID">
            <summary>
            Denotes stream types (id). Used in StreamMeta
            </summary>
        </member>
        <member name="P:NFX.Financial.Market.SecDb.SecDBFileReader.CandlesMeta.Resolutions">
            <summary>
            Returns resolution available in the file
            </summary>
        </member>
        <member name="F:NFX.Financial.Market.SecDb.SecDBFileReader.CandleHeader.File">
            <summary>
            File that the header is from
            </summary>
        </member>
        <member name="F:NFX.Financial.Market.SecDb.SecDBFileReader.CandleHeader.ResolutionSec">
            <summary>
            Size of candle in seconds
            </summary>
        </member>
        <member name="F:NFX.Financial.Market.SecDb.SecDBFileReader.CandleHeader.StartTimeMidnightOffsetSec">
            <summary>
            Offset since midnight in seconds
            </summary>
        </member>
        <member name="F:NFX.Financial.Market.SecDb.SecDBFileReader.CandleHeader.StartTime">
            <summary>
            Start time as calculated from StartTimeMidnightOffsetSec
            </summary>
        </member>
        <member name="F:NFX.Financial.Market.SecDb.SecDBFileReader.CandleHeader.CandleCount">
            <summary>
            Total candle samples at DataOffset
            </summary>
        </member>
        <member name="F:NFX.Financial.Market.SecDb.SecDBFileReader.CandleHeader.DataOffset">
            <summary>
            Where candle data starts
            </summary>
        </member>
        <member name="M:NFX.Financial.Market.SecDb.SecDBFileReader.CandleHeader.GetSkipSecondsUntil(System.DateTime)">
            <summary>
            Returns how many seconds need to be skipped to arrive at the particular date.
            The negative return means that the supplied data is BEFORE the data start
            </summary>
        </member>
        <member name="P:NFX.Financial.Market.SecDb.SecDBFileReader.CandleHeader.IsAssigned">
            <summary>
            True to indicate that struct instance is assigned meaningful data
            </summary>
        </member>
        <member name="T:NFX.Financial.Market.SecDb.SecDBFileReader.CandleData">
            <summary>
            Represents OHLC sample from the file
            </summary>
        </member>
        <member name="F:NFX.Financial.Market.SecDb.SecDBFileReader.CandleData.File">
            <summary>
            File that the header is from
            </summary>
        </member>
        <member name="P:NFX.Financial.Market.SecDb.SecDBFileReader.CandleData.IsAssigned">
            <summary>
            True to indicate that struct instance is assigned meaningful data
            </summary>
        </member>
        <member name="T:NFX.Financial.Market.SecDb.SecDBFileReader.StreamSample">
            <summary>
            Base class for all samples
            </summary>
        </member>
        <member name="T:NFX.Financial.Market.SecDb.StreamID">
            <summary>
            Denotes stream types (id). Used in StreamMeta
            </summary>
        </member>
        <member name="T:NFX.Financial.Market.SecDb.SecDBPrimitives">
            <summary>
            Facilittates reading SecDB primitive values
            see:  https://github.com/saleyn/secdb/wiki/Data-Format
            </summary>
        </member>
        <member name="T:NFX.Geometry.LatLng">
            <summary>
            Provides support for Latitude/Longitude logic
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxBinding">
            <summary>
            Provides asynchronous communicating pattern based on asynchronous virtual socket.
            The concrete socket may be based on OS-supported technology i.e. -  IO completion ports on Windows
            </summary>
        </member>
        <member name="T:NFX.Glue.Binding">
            <summary>
            Represents a particular named binding.
            Binding type defines a protocol by implementing a transport instance management strategy
            that support particular technology, such as blocking TCP or async ZeroMQ.
            Binding instance retains state/config information about all transports
            and has logic for Node's host:service resolution.
            Bindings are services, meaning - they can have state/threads that
            manage transport channels that operate under binding
            </summary>
        </member>
        <member name="T:NFX.Glue.GlueComponentService">
            <summary>
            Provides base functionality for internal glue component implementations
            </summary>
        </member>
        <member name="P:NFX.Glue.GlueComponentService.InstrumentationEnabled">
            <summary>
            Implements IInstrumentable
            </summary>
        </member>
        <member name="F:NFX.Glue.Binding.DEFAULT_STAT_TIMES_EMA_FACTOR">
            <summary>
            Defines how much smoothing the timing statistics filter does - the lower the number the more smoothing is done.
            Smoothing makes stat times insensitive to some seldom delays that may happen every now and then
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.GetClientCallStatTimeKey(NFX.Glue.ClientEndPoint,NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Extracts necessary information from client:request pair that characterizes the particular call
             for the purpose of call timing
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.AreNodesIdentical(NFX.Glue.Node,NFX.Glue.Node)">
            <summary>
            Returns true when two nodes represent the same binding, host and service identities.
            The implementation depends on binding, for example some binding may recognize an optional parameter as part of host segment, however
             that parameter does not change the identity of the node instance
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.DispatchCall(NFX.Glue.ClientEndPoint,NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Dispatches a call allocating new or re-using existing transport if needed. The strategy depends on particular Binding implementation.
            This call is thread-safe
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.CheckRunningState(System.Boolean)">
            <summary>
            Ensures that application and binding runtime are running or throws otherwise
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.DumpMsg(System.Boolean,NFX.Glue.Protocol.Msg,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Conditionally dumps message to disk
            </summary>
            <param name="server">True for server-side message</param>
            <param name="msg">Message that was deserialized/serialized. If null then error happened while deserializing</param>
            <param name="buffer">Message body</param>
            <param name="offset">Start index in buffer</param>
            <param name="count">Byte size of message body</param>
        </member>
        <member name="M:NFX.Glue.Binding.DumpMsg(System.Boolean,NFX.Glue.Protocol.Msg,System.Func{System.ArraySegment{System.Byte}})">
            <summary>
            Conditionally dumps message to disk where the data is lazily obtained by calling dataFun
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.DumpMsg(System.Boolean,NFX.Glue.Protocol.Msg,System.ArraySegment{System.Byte})">
            <summary>
            Conditionally dumps message to disk
            </summary>
            <param name="server">True for server-side message</param>
            <param name="msg">Message that was deserialized/serialized. If null then error happened while deserializing</param>
            <param name="data">Data</param>
        </member>
        <member name="F:NFX.Glue.Binding.m_ClientTransportAllocatorLocks">
            <summary>
            Hash table of locks used during new transport allocation, must be prime size
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.AcquireClientTransportForCall(NFX.Glue.ClientEndPoint,NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Returns an instance of transport suitable for a call. The implementation may return existing transport or allocate a new instance.
            The call is thread-safe
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.MakeNewClientTransport(NFX.Glue.ClientEndPoint)">
            <summary>
            Factory method - Override to make an instance of a new client transport suitable for particular binding type
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.ConfigureAndStartNewClientTransport(NFX.Glue.ClientTransport)">
            <summary>
            Override to perform custom transport preparation and launch
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.ReleaseClientTransportAfterCall(NFX.Glue.ClientTransport)">
            <summary>
            Releases a transport instance that was acquired for call.
            The implementation may return this instance back to the pool of available transports or deallocate it.
            The default implementation releases the instance back to the pool
            </summary>
        </member>
        <member name="M:NFX.Glue.Binding.TryGetExistingAcquiredTransportPerRemoteNode(NFX.Glue.Node)">
            <summary>
            Tries to acquire an available client transport to make a call.
            This method respects binding/transport settings that impose a limit on the number of
             open concurrent transports and timeouts for acqusition waiting
            </summary>
            <param name="remoteNode">remote node to connect to</param>
            <returns>Available acquired transport or null</returns>
        </member>
        <member name="P:NFX.Glue.Binding.OperationFlow">
            <summary>
            Returns sync/async flow that this binding provides
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.EncodingFormat">
            <summary>
            Returns name of msg format encoding
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.Transports">
            <summary>
            Returns all transports in the binding stack
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ClientTransports">
            <summary>
            Returns all client transports in the binding stack
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ServerTransports">
            <summary>
            Returns all server transports in the binding stack
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ConfigNode">
            <summary>
            Returns configuration node for this named instance
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ClientMsgInspectors">
            <summary>
            Returns client message inspectors for this instance
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ServerMsgInspectors">
            <summary>
            Returns server message inspectors for this instance
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ClientDump">
            <summary>
            Turns on/off client message dumping to disk. Turning on dumping has negative effect on performance and consumes resources
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ServerDump">
            <summary>
            Turns on/off server message dumping to disk. Turning on dumping has negative effect on performance and consumes resources
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.DumpPath">
            <summary>
            Set the path for message dumping. Must be an existing navigable path
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.DumpMsgFormat">
            <summary>
            Set the format for message dumping
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.InstrumentClientTransportStat">
            <summary>
            Defines whether client transport statistics is periodically dumped into instrumentation
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.InstrumentServerTransportStat">
            <summary>
            Defines whether server transport statistics is periodically dumped into instrumentation
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.MeasureStatTimes">
            <summary>
            Defines whether message processing latency should be measured - i.e. messages time-stamped on arrival
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.StatTimeTicks">
            <summary>
            Returns current time in system frequency-dependent ticks.
            This property is used to measure accurate times and depends on MeasureStatTimes set to true, otherwise 0 is returned
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.StatTimesEMAFactor">
            <summary>
            Defines how much smoothing the timing statistics filter does - the lower the number the more smoothing is done.
            Smoothing makes stat times insensitive to some seldom delays that may happen every now and then
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ClientTransportIdleTimeoutMs">
            <summary>
            Specifies when client transports get auto-closed. Interval is measured in ms. Zero means indefinite/never closed transport.
            For more info, see 'NFX.Glue: Client Call Concurrency' topic in manual/blog
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ServerTransportIdleTimeoutMs">
            <summary>
            Specifies when server transports get auto-closed. Interval is measured in ms. Zero means indefinite/never closed transport.
            For more info, see 'NFX.Glue: Client Call Concurrency' topic in manual/blog
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ClientTransportExistingAcquisitionTimeoutMs">
            <summary>
            Sets the length of interval for the binding trying to acquire existing client transport instance to make a call.
            When this interval is exhausted then binding tries to allocate a new client transport per remote address, unless
             other limits prohibit (max transport count). The value has to be greater or equal to zero.
            NOTE: this property works in conjunction with ClientTransportCoutWaitThreshold, if the number of active client transports
             is below ClientTransportCoutWaitThreshold, then binding does not wait and allocates a new client transport right away until
              ClientTransportCoutWaitThreshold limit is reached, then binding will try to acquire existing transport for ClientTransportExistingAcquisitionTimeoutMs milliseconds.
            For more info, see 'NFX.Glue: Client Call Concurrency' topic in manual/blog
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ClientTransportCountWaitThreshold">
            <summary>
            Sets the threshold, expressed as the number of active client transports per remote address, below which binding will always allocate a new instance
             of client transport without trying/waiting to acquire an existing one. When this number is exceeded then binding will try to acquire an existing
             client transport instance for up to ClientTransportExistingAcquisitionTimeoutMs milliseconds.
             For more info, see 'NFX.Glue: Client Call Concurrency' topic in manual/blog
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ClientTransportMaxCount">
            <summary>
            Imposes a limit on number of active client transports per remote address. Once this limit is reached the binding will block until it can acquire
            an existing transport instance. Set value to zero to remove the limit.
             For more info, see 'NFX.Glue: Client Call Concurrency' topic in manual/blog
            </summary>
        </member>
        <member name="P:NFX.Glue.Binding.ClientTransportMaxExistingAcquisitionTimeoutMs">
            <summary>
            Imposes a timeout for binding trying to get an existing transport instance per remote address.
            Binding throws ClientCallException when this timeout is exceeded. A value of zero removes the limit
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxBinding.MakeOrReuseChunk">
            <summary>
            Fetches available existing chunk from cache or creates a new one.
            Called by new sockets by incipient connections
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxBinding.OperationFlow">
            <summary>
            Mpx binding is always async by definition
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxBinding.SocketFactory">
            <summary>
            Returns factory used to make new socket instances per particular technology
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxBinding.MaxMsgSize">
            <summary>
            Imposes a limit on maximum message size in bytes
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxBinding.IdleChunkLifeSec">
            <summary>
            Specifies the maximum length of life of an unused memory chunk in the pool.
            The idle chunk will be evicted after this interval.
            This setting is common for both server and client as they share the same pool
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxBinding.MaxChunkPoolCount">
            <summary>
            Imposes a limit on how many memory chunks can be stored in free chunk pool.
            The chunks can be resued for making new connections.
            This setting is common for both server and client as they share the same pool
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxBinding.SocketLingerSec">
            <summary>
            Sets socket linger options.
            This setting is common for both server and client as they have the same channel semantics
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxClientTransport">
            <summary>
            Implements asynchronous MPX client transport for MpxBinding
            </summary>
        </member>
        <member name="T:NFX.Glue.Transport">
            <summary>
            Transports are thread-safe and are intended for use by multiple threads from ClientCallReactor
            and ServerProcessor when bindings operate in OperationFlow.Asynchronous mode.
            Transports are acquired by the thread that creates them
            </summary>
        </member>
        <member name="M:NFX.Glue.Transport.stat_Time(System.String,System.Int64)">
            <summary>
            Processes named time measurement statistical sample by using EMA filter
            </summary>
            <param name="key">Name of time measurement key</param>
            <param name="ticks">Duration in ticks</param>
        </member>
        <member name="M:NFX.Glue.Transport.ResetStats">
            <summary>
            Resets all statistical counters
            </summary>
        </member>
        <member name="M:NFX.Glue.Transport.DumpInstrumentationData">
            <summary>
            Dumps instrumentation data
            </summary>
        </member>
        <member name="M:NFX.Glue.Transport.DoDumpInstrumentationData">
            <summary>
            Override to dump instrumentation data, dont forget to call base to dump basic metrics
            </summary>
        </member>
        <member name="M:NFX.Glue.Transport.TryAcquire">
            <summary>
            A thread-safe operation that tries to acquire(reserve) this instance for exclusive use.
            Returns true if acqusition succeded, false is this instance is reserved by someone else
            </summary>
        </member>
        <member name="M:NFX.Glue.Transport.Release">
            <summary>
            Releases transport by setting Acquired flag to false so it can be used by other operations
            </summary>
        </member>
        <member name="M:NFX.Glue.Transport.CheckRunningState">
            <summary>
            Ensures that application and transport instance are running or throws otherwise
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.Acquired">
            <summary>
            Returns true when this transport instance has been acquired by some operation and is busy
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.Binding">
            <summary>
            Returns a binding that this transport operates under
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.Glue">
            <summary>
            Returns glue implementation that this transport is under
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.TransportKind">
            <summary>
            Reports if this is a server or client transport
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.ExpirationStart">
            <summary>
            Returns timestamp when manager touched the instance for last time and no traffic went through it since
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.IdleAgeMs">
            <summary>
            Returns the duration of transport idle period in ms.
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.Node">
            <summary>
            Returns node that this transport services
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.StatBytesReceived">
            <summary>
            Returns how many bytes were received since .ctor or last ResetStats() call
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.StatBytesSent">
            <summary>
            Returns how many bytes were sent since .ctor or last ResetStats() call
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.StatMsgReceived">
            <summary>
            Returns how many messages were received since .ctor or last ResetStats() call
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.StatMsgSent">
            <summary>
            Returns how many messages were sent since .ctor or last ResetStats() call
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.StatErrors">
            <summary>
            Returns how many message processing errors happened since .ctor or last ResetStats() call
            </summary>
        </member>
        <member name="P:NFX.Glue.Transport.StatTimes">
            <summary>
            Returns enumerable of named times measured in double second fractions.
            The returned times are EMA-filtered from supplied individual measurement samples
            </summary>
        </member>
        <member name="M:NFX.Glue.ClientTransport.SendRequest(NFX.Glue.ClientEndPoint,NFX.Glue.Protocol.RequestMsg,NFX.Glue.Protocol.CallOptions)">
            <summary>
            Sends a client request into remote endpoint.
            This is a blocking call for bindings that are OperationFlow.Synchronous and
            result arrives immediately into CallSlot.
            </summary>
        </member>
        <member name="M:NFX.Glue.ClientTransport.DoSendRequest(NFX.Glue.ClientEndPoint,NFX.Glue.Protocol.RequestMsg,NFX.Glue.Protocol.CallOptions)">
            <summary>
            Override to send a client request into remote endpoint.
            This is a blocking call for bindings that are OperationFlow.Synchronous and
            result arrives immediately into CallSlot.
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxServerTransport">
            <summary>
            Implements asynchronous MPX server transport for MpxBinding
            </summary>
        </member>
        <member name="M:NFX.Glue.ServerTransport.#ctor(NFX.Glue.Binding,NFX.Glue.ServerEndPoint)">
            <summary>
            Creates an instance of listener transport
            </summary>
        </member>
        <member name="M:NFX.Glue.ServerTransport.#ctor(NFX.Glue.Binding,NFX.Glue.ServerTransport)">
            <summary>
            Creates instance of a transport that resulted from connection accept by
            listener. Not all technologies support listener/child transports (TCP does)
            </summary>
        </member>
        <member name="M:NFX.Glue.ServerTransport.SendResponse(NFX.Glue.Protocol.ResponseMsg)">
            <summary>
            Sends a response into remote client endpoint
            </summary>
        </member>
        <member name="M:NFX.Glue.ServerTransport.DoSendResponse(NFX.Glue.Protocol.ResponseMsg)">
            <summary>
            Override to send a response into remote client endpoint
            </summary>
        </member>
        <member name="P:NFX.Glue.ServerTransport.ServerEndpoint">
            <summary>
            Returns server endpoint instance  that opened this transport
            </summary>
        </member>
        <member name="P:NFX.Glue.ServerTransport.IsListener">
            <summary>
            Indicates whether this instance is the one that accepts connections.
            Depending on implementation listeners may allocate other transports after
            they accept incoming connect request (i.e. TCP)
            </summary>
        </member>
        <member name="P:NFX.Glue.ServerTransport.Listener">
            <summary>
            Returns a listener transport that opened this one. If this is a listener
            transport then returns null. Not all technologies support listener/child
            transports (TCP does)
            </summary>
        </member>
        <member name="M:NFX.Glue.ServerTransport`1.#ctor(NFX.Glue.Binding,NFX.Glue.ServerEndPoint)">
            <summary>
            Creates an instance of listener transport
            </summary>
        </member>
        <member name="M:NFX.Glue.ServerTransport`1.#ctor(NFX.Glue.Binding,NFX.Glue.ServerTransport)">
            <summary>
            Creates instance of a transport that resulted from connection accept by listener.
            Not all technologies support listener/child transports (TCP does)
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxServerTransport.#ctor(NFX.Glue.Native.MpxBinding,NFX.Glue.ServerEndPoint,System.Net.IPAddress,System.Int32)">
            <summary>
            Allocates a listener transport
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxServerTransport.ClientSiteConnected(NFX.Glue.Native.MpxServerSocket)">
            <summary>
            Notifies the transport that site connection has arrived so the transport may allocate some site/socket-specific state.
            Called from listener
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxServerTransport.ClientSiteDisconnected(NFX.Glue.Native.MpxServerSocket)">
            <summary>
            Notifies the transport that site connection has closed/broke so the transport may de-allocate some site/socket-specific state.
            Called from listener
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxSocketReceiveAction`1">
            <summary>
            Delivers wire msg from another side. DO NOT use WireMsg beyound the implementation of this delegate,
             if needed make a copy of msg.Data as the memory will be freed after this call returns
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxSocket`1">
            <summary>
            Base for MpxSockets implementation. An MpxSocket represents an asynchronous bi-directional channel of communication
            that delivers binary/wire messages of flexible size.
            The socket is NOT THREAD SAFE for calling Send() from parallel threads. Send() is done synchronously on the
            calling thread, i.e. the sender waits until the data is written into the OS socket buff.
             Receive is invoked by internal/system/io thread asynchronously and should not block for long (seconds)
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxSocket`1.ReleaseMemChunksAfterAsyncOperations">
            <summary>
            Releases socket memory chunks. This method MUST BE called AFTER all pending async IO is done,
            otherwise the chunks may get released to the pool and get corrupted by the prior operation
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxSocket`1.DoReleaseMemChunksAfterAsyncOperations">
            <summary>
            Do not call this method, override only when freeing more than 2 standard chunks (send/recv)
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxSocket`1.Send(NFX.Glue.Native.WireMsg)">
            <summary>
            Adds the specified socket msg to the outgoing stack.
            This is a synchronous blocking call that executes until the data is written
            into socket stack (but not necessarily delivered). If send error occurs then socket is
            marked as !Active (Disposed)
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxSocket`1.GetSendChunk(System.Int32)">
            <summary>
            Reserves a chunk of memory of the suggested size for network send operation.
            The buffer must be released by a call to ReleaseSendBuffer().
            Keep in mind that this method is NOT RE-ENTRANT by this or any other thread until corresponding ReleaseSendChunk() is called.
            MpxSocket is not thread safe for sends in general.
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxSocket`1.ReleaseSendChunk">
            <summary>
            Releases previously reserved buffer, i.e. may trim excess allocation after a large message
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxSocket`1.AcceptManagerVisit(System.DateTime)">
            <summary>
            Override to perform maintenance i.e. trim excessive m_SendChunk size etc..
            This method is called by Glue/Binding/Transport runtime.
            Also resets last last idle manager visit timestamp which is used for socket closing
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.MpxSocket`1.InvokeReceive(NFX.Glue.Native.WireMsg)">
            <summary>
            Calls ReceiveAction callback guarding for possible unhandled receive action errors
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxSocket`1.Transport">
            <summary>
            Returns transport that this socket is under
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxSocket`1.EndPoint">
            <summary>
            Returns IP End point that this socket services, remote server for client socket and remote client for server sockets
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxSocket`1.Socket">
            <summary>
            Returns the underlying socket
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxSocket`1.Active">
            <summary>
            True when socket is not disposing and runtime is not shutting down
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxSocket`1.ClientSite">
            <summary>
            Returns client site for the computer that initiated the call.
            Server socket returns the transmitted value from client. Client socket returns the one that was
             sent to server upon handshake
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxSocket`1.LastIdleManagerVisit">
            <summary>
            Returns timestamp of last manager visit since then no traffic came through. Null indicates that traffic came though
             and socket has not been idle since last visit. Manager is an extrenal visitor that closes idle sockets
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxClientSocket">
            <summary>
            Represents client-side asynchronous socket. This socket initiates a connection to MpxServerSocket
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxServerSocket">
            <summary>
            Represents server-side asynchronous socket that clients connect to
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxServerSocket.Listener">
            <summary>
            Returns listener socket that initiated/opened this server socket
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxListener">
            <summary>
            Represents a server-side listener socket that accepts the calls
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxListener.Transport">
            <summary>
            Returns transpoirt that this listener listens under
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.MpxListener.EndPoint">
            <summary>
            Returns IP End point that this listener listens on
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxSocketFactory">
            <summary>
            Defines factory abstraction that creates socket per particular technology
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxWinSocketFactory">
            <summary>
            Factory that makes MpxWin sockets based on Windows-IO completion ports
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxWinClientSocket">
            <summary>
            Implements a MPX client socket using Windows IO completion ports for receive
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxWinServerSocket">
            <summary>
            Implements a MPX server socket using Windows IO completion ports for receive
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MpxWinListener">
            <summary>
            Implements a MPX socket listener that accepts connections into MpxWinServerSocket
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.MemChunk">
            <summary>
            Represents a stream/writable chunk of memory backed by an array buffer
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.MemChunk._LastReleaseUtc">
            <summary>
            Whan was the chunk released to the pool for the last time
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.MemChunk.Acquired">
            <summary>
            True if chunk is taken out of pool by some socket
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.MemChunk.stat_MaxUsedPosition">
            <summary>
            Used for statistics/tracking
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.MemChunk.stat_MaxLength">
            <summary>
            Used for statistics/tracking
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.WireMsg">
            <summary>
            Represents a message that is transmitted over the wire:
            </summary>
            <remarks>
              Wire Msg gets serialized like so:
                +----+ | +----------------------------------------------+---------+ | +-------+
                |Size| | |                 Frame Content                | Hdrs... | | | GlueM |
                +----+ | +----------------------------------------------+---------+ | +-------+
                   ^     \----------------------+---------------------------------/       ^
                   |                            |                                         |
                   |                            |                                         +-- Msg data (payload) , i.e. Glue message body
                   |                            +----------------------------- Transport Frame with optional var length headers
                   +-------------------------------------------------------- Total msg size 4 bytes
            </remarks>
        </member>
        <member name="M:NFX.Glue.Native.WireMsg.#ctor(NFX.Glue.Native.MemChunk)">
            <summary>
            Creates WireMsg around pre-filled memory chunk that includes msg size - first 4 bytes
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.WireMsg.Data">
            <summary>
            Returns the data chunk received/sent from/to socket INCLUDING the total size (first 4 bytes BEint32)
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.WireMsg.UpdateBufferStats">
            <summary>
            Update buffers statistics
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.WireMsg.Frame">
            <summary>
            Returns frame serialized in data
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.WireMsg.Buffer">
            <summary>
            Returns data byte buffer
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.WireMsg.BufferUsedSize">
            <summary>
            Returns data byte buffer use count, i.w. the buffer may be physically larger, however only BufferUsedSize must be transmitted
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.FrameType">
            <summary>
            Type of transport frame message
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.FrameType.GlueMsg">
            <summary>
            Indicator that following payload is a standard Glue message
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.FrameType.Heartbeat">
            <summary>
            Indicator of the oneway hartbeat message
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.FrameType.Echo">
            <summary>
            Indicator that this is an echo request message and sending party awaits the EchoResponse message
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.FrameType.EchoResponse">
            <summary>
            Indicator that this is an echo response message that sending party awaits after E was sent
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.FrameType.Dummy">
            <summary>
            Indicator that the payload is a one way dummy and should be ignored.
            This may be needed for stress testing the network throughput
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.WireFrame">
             <summary>
             This struct defines a frame transmitted as a part of WireMsg
             which can be used for transport or session management needs
             </summary>
             <remarks>
             Frame Content:
               -----------------------------------------
               MAGIC       ushort               2  byte   -  0xABBA
               VESRION     byte                 1  byte
               TYPE        {G|H|E|R|D}          1  byte
               FORMAT      int32BE              4  bytes
               ONEWAY      {0|!0}               1  byte
               REQID       FID                  8  bytes
               HDRSLEN     int32BE              4  bytes
                                            ------------
                                               21  bytes
            
               HDRSCONTENT  utf8_char[x]  HDRSLEN  bytes
               -----------------------------------------
                                     21 + HDRSLEN  bytes total size
             </remarks>
        </member>
        <member name="M:NFX.Glue.Native.WireFrame.#ctor(System.IO.Stream)">
            <summary>
            Reconstruct (deserializes) frame from the stream. May throw on error
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.WireFrame.Serialize(System.IO.Stream)">
            <summary>
            Serialize the frame to the given stream returning the byte size of the frame
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.WireFrame.Type">
            <summary>
            Returns type of this frame
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.WireFrame.Format">
            <summary>
            Format used for payload encoding, use FORMAT_SLIM as a default constant
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.WireFrame.RequestID">
            <summary>
            RequestID of the request in following message or echo response message
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.WireFrame.OneWay">
            <summary>
            True if the requesting party does not expect a response
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.WireFrame.HeadersContent">
            <summary>
            Optional frame headers content - an unparsed XML string
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.WireFrame.Headers">
            <summary>
            Optional frame headers parsed from XML HeadersContent
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.WireFrame.Length">
            <summary>
            The total byte size of the frame that includes the length of headers (if any)
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.ClientSite">
            <summary>
            Represents a client call site identifier which gets generated on client and sent to server upon handshake.
            This struct identifies the calling client by supplying machine/host name and calling application instance ID
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.ClientSite.MachineName">
            <summary>
            Sets process-global machine name for client site identification.
            Assign on client to cluster/other machine names, by default the .ctor will use local computer name
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.ClientSite.#ctor(System.IO.Stream)">
            <summary>
            Deserializes ClientSite from stream. The stream position must be past total size
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.ClientSite.Serialize(System.IO.Stream)">
            <summary>
            Writes ClientSite into stream including total size in bytes. Returns total size
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.ClientSite.Name">
            <summary>
            Returns host name+app instance guid suitable for registry operations
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.ClientSite.Host">
            <summary>
            Returns host name for where calling application runs
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.ClientSite.AppInstanceID">
            <summary>
            Returns instance ID for the calling application container
            </summary>
        </member>
        <member name="T:NFX.Glue.Tools.GluecCompiler">
            <summary>
            Generates code from glue contracts
            </summary>
        </member>
        <member name="T:NFX.Glue.Tools.CSharpGluecCompiler">
            <summary>
            CS Gluec compiler
            </summary>
        </member>
        <member name="T:NFX.IGuidTypeResolver">
            <summary>
            Describe an entity that resolve type guids into local CLR types
            </summary>
        </member>
        <member name="M:NFX.IGuidTypeResolver.TryResolve(System.Guid)">
            <summary>
            Tries to resolves the GUID into type or return null
            </summary>
        </member>
        <member name="M:NFX.IGuidTypeResolver.Resolve(System.Guid)">
            <summary>
            Resolves the GUID into type or throws
            </summary>
        </member>
        <member name="T:NFX.GuidTypeAttribute">
            <summary>
            Provides information about the decorated type: assignes a globally-unique immutable type id
            </summary>
        </member>
        <member name="M:NFX.GuidTypeAttribute.GetGuidTypeAttribute``2(System.Guid,NFX.IGuidTypeResolver)">
            <summary>
            Returns TypeGuidAttribute for a type encapsulated in guid.
            If type is not decorated by the attribute then exception is thrown
            </summary>
        </member>
        <member name="M:NFX.GuidTypeAttribute.GetGuidTypeAttribute``2(System.Type)">
            <summary>
            Returns TypeGuidAttribute for a type.
            If type is not decorated by the attribute then exception is thrown
            </summary>
        </member>
        <member name="T:NFX.GuidTypeResolver`2">
            <summary>
            Provides default type resolver implementation which looks for types in listed assemblies
            looking for types decorated with specified attribute
            </summary>
        </member>
        <member name="M:NFX.GuidTypeResolver`2.TryResolve(System.Guid)">
            <summary>
            Resolves the GUID into type object or return null
            </summary>
        </member>
        <member name="M:NFX.GuidTypeResolver`2.Resolve(System.Guid)">
            <summary>
            Resolves the GUID into type object or throws
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.DecimalGauge">
            <summary>
            Represents a general-purpose decimal measurement datum
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.DecimalGauge.Value">
            <summary>
            Gets gauge value
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.AmountGauge">
            <summary>
            Represents a general-purpose financial Amount measurement datum
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IFinancialLogic">
            <summary>
            A class of operations related to financial transactions / business logic
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IBusinessLogic">
            <summary>
            A class of operations related to business logic that instrument measures
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.AmountGauge.Value">
            <summary>
            Gets gauge value
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.CompositeInstrumentationProvider">
            <summary>
            Represents a provider that writes aggregated datums to multiple destination provider
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.InstrumentationProvider">
            <summary>
            Defines a base provider for InstrumentationService
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationProvider.ExternalGetParameter(System.String,System.Object@,System.String[])">
            <summary>
            Gets external parameter value returning true if parameter was found
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationProvider.ExternalSetParameter(System.String,System.Object,System.String[])">
            <summary>
            Sets external parameter value returning true if parameter was found and set
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationProvider.ExternalParametersForGroups(System.String[])">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationProvider.ExternalParameters">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.CompositeInstrumentationProvider.Providers">
            <summary>
            Returns destinations that this destination wraps. This call is thread safe
            </summary>
        </member>
        <member name="M:NFX.IO.ImageUtils.ExtractMainColors2Iter(System.Drawing.Bitmap,System.Int32,System.Int32,System.Single,System.Single)">
            <summary>
            Extracts three main colors and background color from source image.
            Does the same as <see cref="M:NFX.IO.ImageUtils.ExtractMainColors(System.Drawing.Bitmap,System.Int32,System.Int32,System.Single)"/> method but performs the second extraction attempt if the first attempt returns almost the same colors
            </summary>
            <param name="srcBmp">Source image</param>
            <param name="dwnFactor1">Main downgrade factor
            (source image color quality reduced down to 256/<paramref name="dwnFactor1"/> color per each of RGB channel (2*2*2=8 base colors used as default))</param>
            <param name="dwnFactor2">Secondary downgrade factor for inner-area main color selection</param>
            <param name="interiorPct">Value within (0,1) range that indicates portion of image interior,
            i.e. 0.9 means that 10% part of the image will be used for boundary detection</param>
            <param name="imgDistEps">Color similarity factor. If less that specified value, then the second extraction attempt will be performed</param>
            <returns>Three main colors and background volor</returns>
        </member>
        <member name="M:NFX.IO.ImageUtils.ExtractMainColors(System.Drawing.Bitmap,System.Int32,System.Int32,System.Single)">
             <summary>
             Extracts three main colors and background color from source image by the following algorithm:
             1. source image color quality reduced down to 256/<paramref name="dwnFactor1"/> color per each of RGB channel
                (2*2*2=8 base colors used as default)
             2. four areas (three main and one background) with the biggest color frequencies are taken
             3. color frequency analisys is performed in each area which gives area main color
                (image color quality reduced down to 256/<paramref name="dwnFactor2"/> color per each of RGB channel)
            
             Background area search is limited to [1-<paramref name="interiorPct"/>, <paramref name="interiorPct"/>] portion of image interior
             </summary>
             <param name="srcBmp">Source image</param>
             <param name="dwnFactor1">Main downgrade factor
             (source image color quality reduced down to 256/<paramref name="dwnFactor1"/> color per each of RGB channel (2*2*2=8 base colors used as default))</param>
             <param name="dwnFactor2">Secondary downgrade factor for inner-area main color selection</param>
             <param name="interiorPct">Value within (0,1) range that indicates portion of image interior,
             i.e. 0.9 means that 10% part of the image will be used for boundary detection</param>
             <returns>Three main colors and background volor</returns>
        </member>
        <member name="M:NFX.IO.ImageUtils.NormalizeCenteredImage(System.Drawing.Image,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Scales source image so it fits in the desired image size preserving aspect ratio.
            This function is usable for profile picture size/aspect normalization
            </summary>
        </member>
        <member name="M:NFX.IO.ImageUtils.FitCenteredImage(System.Drawing.Image,System.Int32,System.Int32,System.Int32,System.Int32,System.Nullable{System.Drawing.Color})">
            <summary>
            Scales source image so it uniformly (without cropping) fits in the desired image size preserving aspect ratio.
            This function is usable for profile picture size/aspect normalization
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IInstrumentationInstrument">
            <summary>
            Instruments that measure instrumentation itself
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.NOPInstrumentationProvider">
            <summary>
            Represents a provider that does nothing
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Telemetry.ITelemetryReceiver">
            <summary>
            Represents a contract for working with remote receiver of telemetry information
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Telemetry.ITelemetryReceiver.Send(System.String,NFX.Instrumentation.Datum)">
            <summary>
            Sends data to remote telemetry receiver
            </summary>
            <param name="siteName">the name/identifier of the reporting site</param>
            <param name="data">Telemetry data</param>
        </member>
        <member name="T:NFX.Instrumentation.Telemetry.TelemetryInstrumentationProvider">
            <summary>
            Represents a provider that writes aggregated datums into remote telemetry receiver
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.LogInstrumentationProvider">
            <summary>
            Represents a provider that writes aggregated datums to log
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Telemetry.TelemetryInstrumentationProvider.UseLog">
            <summary>
            Determines whether to write to log as well
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Telemetry.TelemetryInstrumentationProvider.ReceiverNode">
            <summary>
            Provides remote telemetry receiver node
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Telemetry.TelemetryInstrumentationProvider.SiteName">
            <summary>
            Provides name for reporting site, if this property is blank then App.Name is used instead
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Telemetry.TelemetryReceiverClient">
            <summary>
             Client for glued contract NFX.Instrumentation.Telemetry.ITelemetryReceiver server.
             Each contract method has synchronous and asynchronous versions, the later denoted by 'Async_' prefix.
             May inject client-level inspectors here like so:
               client.MsgInspectors.Register( new YOUR_CLIENT_INSPECTOR_TYPE());
            </summary>
        </member>
        <member name="T:NFX.Glue.ClientEndPoint">
            <summary>
            Represents an ancestor for client classes that make calls to server endpoints.
            This and descendant classes are thread safe ONLY for making non-constructing/destructing remote calls, unless ReserveTransport is set to true
            in which case no operation is thread safe
            </summary>
            <remarks>
            This class is not thread safe in general, however Glue allows for concurrent remote calls via the same endpoint instance
            if the following conditions are met:
             1). The endpoint instance has not reserved its transport (ReserveTransport=false)
             2). Either remote contract is stateless OR none of the concurrent calls are constructing/destructing remote instance
            The second condition ensures that stateful remote instance is consistent, otherwise operations may get executed
             out-of-order in the multithreaded scenario
            </remarks>
        </member>
        <member name="T:NFX.Glue.EndPoint">
            <summary>
            Abstarction of server and client endpoints. And endpoint is a logically-connected entity per: ABC rule - Address/Binding/Contract(s)
            </summary>
        </member>
        <member name="P:NFX.Glue.EndPoint.Glue">
            <summary>
            References glue that this endpoint works under
            </summary>
        </member>
        <member name="P:NFX.Glue.EndPoint.Node">
            <summary>
            Returns a node of this endpoint. "A" component of the "ABC" rule
            </summary>
        </member>
        <member name="P:NFX.Glue.EndPoint.Binding">
            <summary>
            Returns a binding of this endpoint. "B" component of the "ABC" rule
            </summary>
        </member>
        <member name="M:NFX.Glue.ClientEndPoint.ForgetRemoteInstance">
            <summary>
            Sets RemoteInstance to null. This method is needed when the same instance of client endpoint is used to make subsequent statefull calls
             to different server instances. Call this method before calling [Constructor]-decorated remote method or making the first call to
              InstanceLifetime.AutoconstructedStateful servers.
            </summary>
            <remarks>
            The remote instance ID is retained locally even after a call to [Destructor]-decorated remote method. This is needed because
             a call to destructor may be asynchronous and it may be necessary to know the ID of the instance (that has already died on remote host) after call returns.
            Call ForgetRemoteInstance() to deterministically nullify the local cached ID.
            </remarks>
        </member>
        <member name="M:NFX.Glue.ClientEndPoint.DispatchCall(NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Dispatches a call into binding passing message through client inspectors on this endpoint
            </summary>
        </member>
        <member name="P:NFX.Glue.ClientEndPoint.Contract">
            <summary>
            Returns a contract type of this endpoint. "C" component of the "ABC" rule
            </summary>
        </member>
        <member name="P:NFX.Glue.ClientEndPoint.MsgInspectors">
            <summary>
            Returns client message inspectors for this instance
            </summary>
        </member>
        <member name="P:NFX.Glue.ClientEndPoint.Headers">
            <summary>
            Returns headers that get attached in every call
            </summary>
        </member>
        <member name="P:NFX.Glue.ClientEndPoint.RemoteInstance">
            <summary>
            Returns a reference to remote instance or null if service is stateless(no instance created)
            </summary>
        </member>
        <member name="P:NFX.Glue.ClientEndPoint.ReserveTransport">
            <summary>
            Indicates whether transport instance should not be released after a call and be reserved per this endpoint instance.
            Be carefull when setting this property to true as this action can really impede the system performance as transport is reserved
             until this property is either reset to false or endpoint instance is disposed. Transport reservation reduces call latency
              and is mostly beneficial in synchronous bindings. Warning: client endpoint with reserved transport is NOT THREAD SAFE for making
             parallel calls! Set this property to true only when latency is very critical and only 1 dedicated thread is working with this
              client endpoint instance
            </summary>
        </member>
        <member name="P:NFX.Glue.ClientEndPoint.DispatchTimeoutMs">
            <summary>
            Specifies timeout for call invocation
            </summary>
        </member>
        <member name="P:NFX.Glue.ClientEndPoint.TimeoutMs">
            <summary>
            Specifies timeout for the whole call
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Telemetry.TelemetryReceiverClient.Send(System.String,NFX.Instrumentation.Datum)">
            <summary>
             Synchronous invoker for  'NFX.Instrumentation.Telemetry.ITelemetryReceiver.Send'.
             This is a one-way call per contract specification, meaning - the server sends no acknowledgement of this call receipt and
             there is no result that server could return back to the caller.
             ClientCallException is thrown if the call could not be placed in the outgoing queue.
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Telemetry.TelemetryReceiverClient.Async_Send(System.String,NFX.Instrumentation.Datum)">
            <summary>
             Asynchronous invoker for  'NFX.Instrumentation.Telemetry.ITelemetryReceiver.Send'.
             This is a one-way call per contract specification, meaning - the server sends no acknowledgement of this call receipt and
             there is no result that server could return back to the caller.
             CallSlot is returned that can be queried for CallStatus, ResponseMsg.
            </summary>
        </member>
        <member name="T:NFX.IO.BufferSegmentReadingStream">
            <summary>
            Implements a read-only stream wrapper around a segment of byte[].
            Unlike MemoryStream, this class allows for use of long indexes and reuse the same stream instance with different byte[].
            </summary>
        </member>
        <member name="M:NFX.IO.BufferSegmentReadingStream.BindBuffer(System.Byte[],System.Int64,System.Int64)">
            <summary>
            Sets byte[] as stream source
            </summary>
        </member>
        <member name="M:NFX.IO.BufferSegmentReadingStream.UnsafeBindBuffer(System.Byte[],System.Int64,System.Int64)">
            <summary>
            Sets byte[] as stream source this method does the same as BindBuffer without extra if statements, correct data is expected to be supplied
            </summary>
        </member>
        <member name="P:NFX.IO.BufferSegmentReadingStream.Buffer">
            <summary>
            Target stream that this stream wraps
            </summary>
        </member>
        <member name="T:NFX.IO.ErrorHandling.Adler32">
            <summary>
            Implements Adler32 checksum algorithm
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.Adler32.ForEncodedString(System.String,System.Text.Encoding)">
            <summary>
            Computes Adler32 for encoded string
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.Adler32.ForString(System.String)">
            <summary>
            Computes Adler32 for binary string representation (in-memory)
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.Adler32.ForBytes(System.Byte[])">
            <summary>
            Computes Adler32 for byte array
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.Adler32.Add(System.Byte[])">
            <summary>
            Addes byte[] to checksum
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.Adler32.Add(System.String)">
            <summary>
            Addes string to checksum
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.DeleteFilesJob">
            <summary>
            Represents a job(a scheduled event) which deletes FS files
            </summary>
        </member>
        <member name="T:NFX.Time.Event">
            <summary>
            Represents an event manageable by IEventTimer
            </summary>
        </member>
        <member name="F:NFX.Time.Event.EventHandler">
            <summary>
            References event handler that handles events. If it is null then only delegate events are called
            </summary>
        </member>
        <member name="M:NFX.Time.Event.ResetCallCount">
            <summary>
            Resets call count counter. If this event has expired it will eventually transition to Started state.
            Keep in mind that it may expire again if EndDate is set and past due
            </summary>
        </member>
        <member name="M:NFX.Time.Event.Fire(System.Boolean)">
            <summary>
            Calls event regardless of any constraints.
            Invokes a handler right away if syncInvoke is true or BodyAsyncModel is Sync,
            otherwise queues the task on a thread pool either as a regular or long-running task depending on BodyAsyncModel
            </summary>
        </member>
        <member name="M:NFX.Time.Event.UniversalTimeToLocalizedTime(System.DateTime)">
            <summary>
            Converts universal time to local time as of TimeLocation property
            </summary>
        </member>
        <member name="M:NFX.Time.Event.LocalizedTimeToUniversalTime(System.DateTime)">
            <summary>
            Converts localized time to UTC time as of TimeLocation property
            </summary>
        </member>
        <member name="M:NFX.Time.Event.ExternalParametersForGroups(System.String[])">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="M:NFX.Time.Event.ExternalGetParameter(System.String,System.Object@,System.String[])">
            <summary>
            Gets external parameter value returning true if parameter was found
            </summary>
        </member>
        <member name="M:NFX.Time.Event.ExternalSetParameter(System.String,System.Object,System.String[])">
            <summary>
            Sets external parameter value returning true if parameter was found and set
            </summary>
        </member>
        <member name="M:NFX.Time.Event.AdjustDate(System.Nullable{System.DateTime})">
            <summary>
            Adjusts date time Localized time
            </summary>
        </member>
        <member name="M:NFX.Time.Event.VisitAndCheck(System.DateTime)">
            <summary>
            Invoked by timer, checks all conditions and fires/expires event depending on the status.
            Returns true if event was fired, false otherwise
            </summary>
        </member>
        <member name="M:NFX.Time.Event.DoVisit(System.DateTime)">
            <summary>
            Override to perform extra status checks
            </summary>
        </member>
        <member name="P:NFX.Time.Event.TimeLocation">
            <summary>
            Returns time location that this Event instance operates under.
            </summary>
        </member>
        <member name="P:NFX.Time.Event.LocalizedTime">
            <summary>
            Returns current time localized per TimeLocation
            </summary>
        </member>
        <member name="E:NFX.Time.Event.Body">
            <summary>
            Event body that gets called when the event is due. The body is always invoked ASYNCHRONOUSLY
            unless Fire(syncronous=true) is called in which case it gets called on a thread that called Fire(true)
            </summary>
        </member>
        <member name="E:NFX.Time.Event.StatusChange">
            <summary>
            Invoked when timer event status changes. Always called synchronously by the timer thread.
            Subscribers should not block for long
            </summary>
        </member>
        <member name="E:NFX.Time.Event.DefinitionChange">
            <summary>
            Invoked when one of timer event definition parameters changes.
            Always called synchronously on the same thread that made a change.
            Subscribers should not block for long
            </summary>
        </member>
        <member name="P:NFX.Time.Event.Enabled">
            <summary>
            Specifies whether this event will fire/participate in timer loop
            </summary>
        </member>
        <member name="P:NFX.Time.Event.BodyAsyncModel">
            <summary>
            Defines how event body should be invoked
            </summary>
        </member>
        <member name="P:NFX.Time.Event.StartDate">
            <summary>
            Specifies when this event will start firing in the local event time
            </summary>
        </member>
        <member name="P:NFX.Time.Event.EndDate">
            <summary>
            Specifies when this event will stop firing in the local event time
            </summary>
        </member>
        <member name="P:NFX.Time.Event.Interval">
            <summary>
            Specifies how often event fires
            </summary>
        </member>
        <member name="P:NFX.Time.Event.MaxCount">
            <summary>
            Specifies how many times this event can be called. If less or equal than zero then no limit is set
            </summary>
        </member>
        <member name="P:NFX.Time.Event.Context">
            <summary>
            Adds arbitrary context object to the event
            </summary>
        </member>
        <member name="P:NFX.Time.Event.CallCount">
            <summary>
            Returns how many times this event was called
            </summary>
        </member>
        <member name="P:NFX.Time.Event.LastCall">
            <summary>
            Returns when was this event called for the last time in the local event time
            </summary>
        </member>
        <member name="P:NFX.Time.Event.LastError">
            <summary>
            Returns the last exception thrown from event handler or nul if no error happened
            </summary>
        </member>
        <member name="P:NFX.Time.Event.ExternalParameters">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.DeleteFilesJob.FileSystem">
            <summary>
            Returns file system that serves static content for portals
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.DeleteFilesJob.FileSystemRootPath">
            <summary>
            Returns root path for content file system
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.DeleteFilesJob.BodyAsyncModel">
            <summary>
            Due to IO-nature this job is always executted as a long-running separate task
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.FileSystemDirectory">
            <summary>
            Represents a directory item in a file system. This class is NOT thread-safe
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.FileSystemSessionItem">
            <summary>
             Represents an abstraction for items kept in a file system - i.e. directories and files.This class is NOT thread-safe
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.GetSizeAsync">
            <summary>
            Async version of <see cref="P:Size"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.SetCreationTimestampAsync(System.DateTime)">
            <summary>
            Async version of <see cref="P:CreationTimestamp"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.SetModificationTimestampAsync(System.DateTime)">
            <summary>
            Async version of <see cref="P:ModificationTimestamp"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.SetLastAccessTimestampAsync(System.DateTime)">
            <summary>
            Async version of <see cref="P:LastAccessTimestamp"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.GetCreationUserAsync">
            <summary>
            Async version of <see cref="P:CreationUser"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.GetModificationUserAsync">
            <summary>
            Async version of <see cref="P:ModificationUser"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.GetLastAccessUserAsync">
            <summary>
            Async version of <see cref="P:LastAccessUser"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.SetReadOnlyAsync(System.Boolean)">
            <summary>
            Async version of <see cref="P:ReadOnly"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.CheckCanChange">
            <summary>
            Throws when item can not change
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.CheckCanChangeAsync">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemSessionItem.CheckCanChange"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.Rename(System.String)">
            <summary>
            Renames an item. Check file system capabilities to see if renaming is supported
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.RenameAsync(System.String)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemSessionItem.Rename(System.String)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.Delete">
            <summary>
            Deletes this item from file system
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.DeleteAsync">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemSessionItem.Delete"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.Refresh">
            <summary>
            Refreshes the state represented by this item, i.e. this may re-read attributes from remote file system
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSessionItem.RefreshAsync">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemSessionItem.Refresh"/>
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.Handle">
            <summary>
            Returns file system handle for this entity
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.Modified">
            <summary>
            Indicates whether anything has changed since last transaction has started
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.Path">
            <summary>
            Returns an absolute path for this item
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.ParentPath">
            <summary>
            Returns path to directory that contains this item
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.FileSystem">
            <summary>
            Returns filesystem - this is a shortcut to Session.FileSystem
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.Session">
            <summary>
            Returns session through which this object was obtained
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.PermissionsStream">
            <summary>
            Returns item permissions stream
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.MetadataStream">
            <summary>
            Returns item metadata stream
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.Size">
            <summary>
            Returns the byte size of the item, depending on implementation this property may return approximate sizes for files and directories
            (i.e in distributed systems)
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.CreationTimestamp">
            <summary>
            Gets/sets UTC creation timestamp
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.ModificationTimestamp">
            <summary>
            Gets/sets UTC modification timestamp
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.LastAccessTimestamp">
            <summary>
            Gets/sets UTC last access timestamp
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.CreationUser">
            <summary>
            Gets the user who created this item
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.ModificationUser">
            <summary>
            Gets the user who modified this item
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.LastAccessUser">
            <summary>
            Gets the last user who accessed the item
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.ReadOnly">
            <summary>
            Gets/sets readonly attribute
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSessionItem.IsReadOnly">
            <summary>
            Indicates whether this item can change and file system supports modifications
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.#ctor(NFX.IO.FileSystem.FileSystemSession,System.String,System.String,NFX.IO.FileSystem.IFileSystemHandle)">
            <summary>
            Internal method that should not be called by developers
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.GetSubDirectoryNamesAsync">
            <summary>
            Async version of <see cref="P:SubDirectoryNames"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.GetFileNamesAsync">
            <summary>
            Async version of <see cref="P:FileNames"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.GetRecursiveSubDirectoryNamesAsync">
            <summary>
            Async version of <see cref="P:RecursiveSubDirectoryNames"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.GetRecursiveFileNamesAsync">
            <summary>
            Async version of <see cref="P:RecursiveFileNames"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.GetItemAsync(System.String)">
            <summary>
            Async version of Item(string)
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.GetFile(System.String)">
            <summary>
            Gets file in this directory or null if it does not exist or not a file
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.GetFileAsync(System.String)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemDirectory.GetFile(System.String)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.GetSubDirectory(System.String)">
            <summary>
            Gets dubdirectory in this directory or null if it does not exist or not a directory
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.GetSubDirectoryAsync(System.String)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemDirectory.GetFile(System.String)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.CreateFile(System.String,System.Int32)">
            <summary>
            Creates a new file optionally pre-allocating te specified number of bytes
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.CreateFileAsync(System.String,System.Int32)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemDirectory.CreateFile(System.String,System.Int32)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.CreateFile(System.String,System.String,System.Boolean)">
            <summary>
            Puts local existing file into file system
            </summary>
            <param name="name">File system file name</param>
            <param name="localFilePath">Local system file name</param>
            <param name="readOnly">Indictaes whether the newly created file should be readonly</param>
            <returns>FileSystemFile instance</returns>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.CreateFileAsync(System.String,System.String,System.Boolean)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemDirectory.CreateFile(System.String,System.String,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.CreateDirectory(System.String)">
            <summary>
            Creates a directory in this directory
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.CreateDirectoryAsync(System.String)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemDirectory.CreateDirectory(System.String)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.DeepCopyTo(NFX.IO.FileSystem.FileSystemDirectory,NFX.IO.FileSystem.FileSystemDirectory.DirCopyFlags,System.Int32,System.Func{NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean},System.Func{NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean})">
            <summary>
            Performs a deep copy of this directory into another directory that may belong to a different file system.
            This method allows to copy directory trees between different file systems i.e. from SVN into AmazonS3 or local file system etc.
            </summary>
            <param name="target">Target directory where the files will be placed. It's name does not have to be the same as the source's name</param>
            <param name="flags">Copy flags that specify what to copy</param>
            <param name="bufferSize">Copy buffer size</param>
            <param name="filter">Optional filter function</param>
            <param name="cancel">Optional cancellation function. Return true to abort copying</param>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemDirectory.DeepCopyToAsync(NFX.IO.FileSystem.FileSystemDirectory,NFX.IO.FileSystem.FileSystemDirectory.DirCopyFlags,System.Int32,System.Func{NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean},System.Func{NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean})">
            <summary>
            Async version of DeepCopyTo(...)
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemDirectory.SubDirectoryNames">
            <summary>
            Returns directory names contained in this directory
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemDirectory.FileNames">
            <summary>
            Returns file names contained in this directory
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemDirectory.RecursiveSubDirectoryNames">
            <summary>
            Returns directory names contained in this directory and all subdirectories
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemDirectory.RecursiveFileNames">
            <summary>
            Returns file names contained in this directory and all subdirectories
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemDirectory.Item(System.String)">
            <summary>
            Navigates to the specified path relative to this directory
            </summary>
            <param name="path">Path relative to this directory to navigate to</param>
            <returns>FileSystemSessionItem instance - a directory or a file</returns>
        </member>
        <member name="T:NFX.IO.FileSystem.FileSystemException">
            <summary>
            General NFX file system specific exception
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.FileSystemFile">
            <summary>
            Represents a file in a file system. This class is NOT thread-safe
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemFile.#ctor(NFX.IO.FileSystem.FileSystemSession,System.String,System.String,NFX.IO.FileSystem.IFileSystemHandle)">
            <summary>
            Internal method that should not be called by developers
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemFile.ReadAllText">
            <summary>
            Reads all text from file using byte order mark detection with UTF8 encoding
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemFile.ReadAllTextAsync">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemFile.ReadAllText"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemFile.ReadAllText(System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Reads all text from stream using the specified parameters
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemFile.ReadAllTextAsync(System.Text.Encoding,System.Boolean,System.Int32)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemFile.ReadAllText(System.Text.Encoding,System.Boolean,System.Int32)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemFile.WriteAllText(System.String)">
            <summary>
            Sets file content to supplied string using default UTF8 encoding
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemFile.WriteAllTextAsync(System.String)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemFile.WriteAllText(System.String)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemFile.WriteAllText(System.String,System.Text.Encoding,System.Int32)">
            <summary>
            Sets file content to supplied string using the specified parameters
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemFile.WriteAllTextAsync(System.String,System.Text.Encoding,System.Int32)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemFile.WriteAllText(System.String,System.Text.Encoding,System.Int32)"/>
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemFile.FileStream">
            <summary>
            Returns a stream usable for file content access. If the file has not opened stream yet it will be opened and cached
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.IFileSystemCapabilities">
            <summary>
            Supplies capabilities for the file system. The implementation must be thread safe
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.SupportsVersioning">
            <summary>
            Indicates whether a file system supports versioning
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.SupportsTransactions">
            <summary>
            Indicates whether a file system supports transactions
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.MaxFilePathLength">
            <summary>
            Returns maximum allowed length of the whole path that includes directory name/s and/or separator chars and/or file name
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.MaxFileNameLength">
            <summary>
            Returns maximum allowed length of a file name
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.MaxDirectoryNameLength">
            <summary>
            Returns maximum allowed length of a directory name
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.MaxFileSize">
            <summary>
            Returns the maximum size of a file
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.PathSeparatorCharacters">
            <summary>
            Returns understood path separator characters
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.IsReadonly">
            <summary>
            Indicates whether file system supports modification of its files and structure
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.SupportsSecurity">
            <summary>
            Indicates whether the file system supports security permissions
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.SupportsCustomMetadata">
            <summary>
            Indicates whether the file system supports custom metadata for files and folders
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystemCapabilities.SupportsAsyncronousAPI">
            <summary>
            Defines if this FileSystem implements Async methods in real asynchronous manner.
            By default asynchronous methods are actually executed syncronously and return Task with execution result or exception
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.FileSystem">
            <summary>
            Provides a base for various file system abstractions.
            FileSystem abstractions are mostly useful for working with components/classes that may need to inter-operate not only with local file system
             but also with distributed systems like ApacheHDFS, SVN, GIT, or Aum Cluster Big-Transactional File System (BoltFS).
             NFX library provides compatibility wrapper 'NFX.IO.FileSystem.Local.LocalFileSystem' for access to local machine file system
             (which is based on this class and is implemented using a traditional System.IO.* set of classes).
            The FileSystem abstraction supports the following concepts: versioning, transactions, metadata, security; however it does not guarantee that
             every implementation is capable of providing all of these functions. Query "GeneralCapabilities" and "InstanceCapabilities" to see what functions
              are supported by a particular instance.
            This class is not thread-safe unless stated otherwise on method level, however multiple threads are allowed to obtain their own FileSystemSession
             object via a call to StartSession() which is thread safe
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.IFileSystem">
            <summary>
            Stipulates contract for various file system abstractions.
            FileSystem abstractions are mostly useful for working with components/classes that may need to inter-operate not only with local file system
             but also with distributed systems like ApacheHDFS, SVN, GIT, or Aum Cluster File System (ACFS).
             NFX library provides compatibility wrapper 'NFX.IO.FileSystem.Local.LocalFileSystem' for access to local machine file system
             (which is based on this class and is implemented using a traditional System.IO.* set of classes).
            The FileSystem abstraction supports the following concepts: versioning, transactions, metadata, security; however it does not guarantee that
             every implementation is capable of providing all of these functions. Query "GeneralCapabilities" and "InstanceCapabilities" to see what functions
              are supported by a particular instance.
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.IFileSystem.StartSession(NFX.IO.FileSystem.FileSystemSessionConnectParams)">
            <summary>
            Creates a new session for the specified user and version
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.IFileSystem.CombinePaths(System.String,System.String[])">
            <summary>
            Combines two or more path segments joining them using primary file system path separator
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystem.Sessions">
            <summary>
            Returns a list of sessions
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystem.GeneralCapabilities">
            <summary>
            Returns capabilities for this file system in general
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.IFileSystem.InstanceCapabilities">
            <summary>
            Returns capabilities for this file system instance, that may or may not be the same as GeneralCapabilities
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.AutoStartSystems">
            <summary>
            Automatically starts systems designated in config with auto-start attribute
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.Configure(NFX.Environment.IConfigSectionNode)">
            <summary>
            Configures file system. This method is a part of lifecycle management and is intended to be called only by creating thread (not thread-safe)
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.StartSession(NFX.IO.FileSystem.FileSystemSessionConnectParams)">
            <summary>
            Creates a new session for the user. This method is thread-safe, however the returned FileSystemSession object is not.
            Every thread must obtain its own session via this method
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.CombinePaths(System.String,System.String[])">
            <summary>
            Combines two or more path segments joining them using primary file system path separator. This method is thread-safe
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoConfigure(NFX.Environment.IConfigSectionNode)">
            <summary>
            Override to perform custom configuration
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoCheckCanChange(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override in particular file systems to see if item can change, i.e.
             for file systems that support versioning throw exception if item is in session
              which "looks" at a sealed/closed version and can not change. This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoCheckCanChangeAsync(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoCheckCanChange(NFX.IO.FileSystem.FileSystemSessionItem)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoCheckCanChange(NFX.IO.FileSystem.FileSystemSessionItem)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoCheckCanChange(NFX.IO.FileSystem.FileSystemSessionItem)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetLatestVersion(NFX.IO.FileSystem.FileSystemSession)">
            <summary>
            Override in particular file systems that support versioning to get latest version object that this session can work with.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetLatestVersionAsync(NFX.IO.FileSystem.FileSystemSession)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetLatestVersion(NFX.IO.FileSystem.FileSystemSession)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetLatestVersion(NFX.IO.FileSystem.FileSystemSession)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetLatestVersion(NFX.IO.FileSystem.FileSystemSession)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetVersion(NFX.IO.FileSystem.FileSystemSession)">
            <summary>
            Override in particular file systems that support versioning to get version object for session.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetVersionAsync(NFX.IO.FileSystem.FileSystemSession)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetVersion(NFX.IO.FileSystem.FileSystemSession)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetVersion(NFX.IO.FileSystem.FileSystemSession)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetVersion(NFX.IO.FileSystem.FileSystemSession)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoSetVersion(NFX.IO.FileSystem.FileSystemSession,NFX.IO.FileSystem.IFileSystemVersion)">
            <summary>
            Override in particular file systems that support versioning to set seesion to specific version.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoSetVersionAsync(NFX.IO.FileSystem.FileSystemSession,NFX.IO.FileSystem.IFileSystemVersion)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetVersion(NFX.IO.FileSystem.FileSystemSession,NFX.IO.FileSystem.IFileSystemVersion)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetVersion(NFX.IO.FileSystem.FileSystemSession,NFX.IO.FileSystem.IFileSystemVersion)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetVersion(NFX.IO.FileSystem.FileSystemSession,NFX.IO.FileSystem.IFileSystemVersion)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoBeginTransaction(NFX.IO.FileSystem.FileSystemSession)">
            <summary>
            Override in particular file systems that support transactions to begin transaction in specified session.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoBeginTransactionAsync(NFX.IO.FileSystem.FileSystemSession)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoBeginTransaction(NFX.IO.FileSystem.FileSystemSession)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoBeginTransaction(NFX.IO.FileSystem.FileSystemSession)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoBeginTransaction(NFX.IO.FileSystem.FileSystemSession)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoCommitTransaction(NFX.IO.FileSystem.FileSystemSession)">
            <summary>
            Override in particular file systems that support transactions to commit transaction in specified session.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoCommitTransactionAsync(NFX.IO.FileSystem.FileSystemSession)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoCommitTransaction(NFX.IO.FileSystem.FileSystemSession)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoCommitTransaction(NFX.IO.FileSystem.FileSystemSession)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoCommitTransaction(NFX.IO.FileSystem.FileSystemSession)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoRollbackTransaction(NFX.IO.FileSystem.FileSystemSession)">
            <summary>
            Override in particular file systems that support transactions to rollback transaction in specified session.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoRollbackTransactionAsync(NFX.IO.FileSystem.FileSystemSession)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoRollbackTransaction(NFX.IO.FileSystem.FileSystemSession)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoRollbackTransaction(NFX.IO.FileSystem.FileSystemSession)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoRollbackTransaction(NFX.IO.FileSystem.FileSystemSession)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoRefresh(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override to refresh item state, i.e. re-fetch remote information.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoRefreshAsync(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoRefreshAsync(NFX.IO.FileSystem.FileSystemSessionItem)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoRefreshAsync(NFX.IO.FileSystem.FileSystemSessionItem)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoRefreshAsync(NFX.IO.FileSystem.FileSystemSessionItem)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetSubDirectoryNames(NFX.IO.FileSystem.FileSystemDirectory,System.Boolean)">
            <summary>
            Override to get subdirectory names of directory. If directory is null then root is assumed.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetSubDirectoryNamesAsync(NFX.IO.FileSystem.FileSystemDirectory,System.Boolean)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetSubDirectoryNames(NFX.IO.FileSystem.FileSystemDirectory,System.Boolean)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetSubDirectoryNames(NFX.IO.FileSystem.FileSystemDirectory,System.Boolean)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetSubDirectoryNames(NFX.IO.FileSystem.FileSystemDirectory,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetFileNames(NFX.IO.FileSystem.FileSystemDirectory,System.Boolean)">
            <summary>
            Override to get file names in directory. If directory is null then root is assumed.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetFileNamesAsync(NFX.IO.FileSystem.FileSystemDirectory,System.Boolean)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetFileNames(NFX.IO.FileSystem.FileSystemDirectory,System.Boolean)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetFileNames(NFX.IO.FileSystem.FileSystemDirectory,System.Boolean)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetFileNames(NFX.IO.FileSystem.FileSystemDirectory,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoNavigate(NFX.IO.FileSystem.FileSystemSession,System.String)">
            <summary>
            Override to get file or directory from specified path. Return null if item does not exist.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoNavigateAsync(NFX.IO.FileSystem.FileSystemSession,System.String)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoNavigate(NFX.IO.FileSystem.FileSystemSession,System.String)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoNavigate(NFX.IO.FileSystem.FileSystemSession,System.String)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoNavigate(NFX.IO.FileSystem.FileSystemSession,System.String)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoRenameItem(NFX.IO.FileSystem.FileSystemSessionItem,System.String)">
            <summary>
            Override to rename item return true on success.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoRenameItemAsync(NFX.IO.FileSystem.FileSystemSessionItem,System.String)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoRenameItem(NFX.IO.FileSystem.FileSystemSessionItem,System.String)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoRenameItem(NFX.IO.FileSystem.FileSystemSessionItem,System.String)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoRenameItem(NFX.IO.FileSystem.FileSystemSessionItem,System.String)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoDeleteItem(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override to delete item.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoDeleteItemAsync(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoDeleteItem(NFX.IO.FileSystem.FileSystemSessionItem)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoDeleteItem(NFX.IO.FileSystem.FileSystemSessionItem)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoDeleteItem(NFX.IO.FileSystem.FileSystemSessionItem)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoCreateFile(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.Int32)">
            <summary>
            Override to create a file.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoCreateFileAsync(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.Int32)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoCreateFile(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.Int32)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoCreateFile(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.Int32)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoCreateFile(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.Int32)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoCreateFile(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.String,System.Boolean)">
            <summary>
            Override to create a file from local file.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoCreateFileAsync(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.String,System.Boolean)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoCreateFile(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.String,System.Boolean)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoCreateFile(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.String,System.Boolean)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoCreateFile(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.String,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoCreateDirectory(NFX.IO.FileSystem.FileSystemDirectory,System.String)">
            <summary>
            Override to create a directory.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoCreateDirectoryAsync(NFX.IO.FileSystem.FileSystemDirectory,System.String)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoCreateDirectory(NFX.IO.FileSystem.FileSystemDirectory,System.String)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoCreateDirectory(NFX.IO.FileSystem.FileSystemDirectory,System.String)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoCreateDirectory(NFX.IO.FileSystem.FileSystemDirectory,System.String)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoDirectoryDeepCopyAsync(NFX.IO.FileSystem.FileSystemDirectory,NFX.IO.FileSystem.FileSystemDirectory,NFX.IO.FileSystem.FileSystemDirectory.DirCopyFlags,System.Int32,System.Func{NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean},System.Func{NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean})">
            <summary>
            Implements asynchronous deep copy of folders where destination folder may belong to a different file system.
            The specifics of implementation may be dictated by particular file systems, i.e.: asynchronous strategies for getting file
            lists may depend on the particular system.
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetItemSize(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override to get the byte size of item (directory or file).
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetItemSizeAsync(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetItemSize(NFX.IO.FileSystem.FileSystemSessionItem)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetItemSize(NFX.IO.FileSystem.FileSystemSessionItem)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetItemSize(NFX.IO.FileSystem.FileSystemSessionItem)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetPermissionsStream(NFX.IO.FileSystem.FileSystemSessionItem,System.Action{NFX.IO.FileSystem.FileSystemStream})">
            <summary>
            Override to get permissions stream for item (directory or file).
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetPermissionsStreamAsync(NFX.IO.FileSystem.FileSystemSessionItem,System.Action{NFX.IO.FileSystem.FileSystemStream})">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetPermissionsStream(NFX.IO.FileSystem.FileSystemSessionItem,System.Action{NFX.IO.FileSystem.FileSystemStream})"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetPermissionsStream(NFX.IO.FileSystem.FileSystemSessionItem,System.Action{NFX.IO.FileSystem.FileSystemStream})"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetPermissionsStream(NFX.IO.FileSystem.FileSystemSessionItem,System.Action{NFX.IO.FileSystem.FileSystemStream})"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetMetadataStream(NFX.IO.FileSystem.FileSystemSessionItem,System.Action{NFX.IO.FileSystem.FileSystemStream})">
            <summary>
            Override to get metadata stream for item (directory or file).
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetMetadataStreamAsync(NFX.IO.FileSystem.FileSystemSessionItem,System.Action{NFX.IO.FileSystem.FileSystemStream})">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetMetadataStream(NFX.IO.FileSystem.FileSystemSessionItem,System.Action{NFX.IO.FileSystem.FileSystemStream})"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetMetadataStream(NFX.IO.FileSystem.FileSystemSessionItem,System.Action{NFX.IO.FileSystem.FileSystemStream})"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetMetadataStream(NFX.IO.FileSystem.FileSystemSessionItem,System.Action{NFX.IO.FileSystem.FileSystemStream})"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetFileStream(NFX.IO.FileSystem.FileSystemFile,System.Action{NFX.IO.FileSystem.FileSystemStream})">
            <summary>
            Override to get file stream.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetFileStreamAsync(NFX.IO.FileSystem.FileSystemFile,System.Action{NFX.IO.FileSystem.FileSystemStream})">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetFileStream(NFX.IO.FileSystem.FileSystemFile,System.Action{NFX.IO.FileSystem.FileSystemStream})"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetFileStream(NFX.IO.FileSystem.FileSystemFile,System.Action{NFX.IO.FileSystem.FileSystemStream})"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetFileStream(NFX.IO.FileSystem.FileSystemFile,System.Action{NFX.IO.FileSystem.FileSystemStream})"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetCreationTimestamp(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override to get item creation timestamp.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetModificationTimestamp(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override to get item modification timestamp.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetLastAccessTimestamp(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override to get item last access timestamp.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoSetCreationTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)">
            <summary>
            Override to set item creation timestamp.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoSetCreationTimestampAsync(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetCreationTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetCreationTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetCreationTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoSetModificationTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)">
            <summary>
            Override to set item modification timestamp.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoSetModificationTimestampAsync(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetModificationTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetModificationTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetModificationTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoSetLastAccessTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)">
            <summary>
            Override to set item last access timestamp.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoSetLastAccessTimestampAsync(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetLastAccessTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetLastAccessTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetLastAccessTimestamp(NFX.IO.FileSystem.FileSystemSessionItem,System.DateTime)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetReadOnly(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override to get item readonly status.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoSetReadOnly(NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean)">
            <summary>
            Override to set item readonly status.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoSetReadOnlyAsync(NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetReadOnly(NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetReadOnly(NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoSetReadOnly(NFX.IO.FileSystem.FileSystemSessionItem,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetCreationUser(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override in particular file systems to get user who created item.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetCreationUserAsync(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetCreationUser(NFX.IO.FileSystem.FileSystemSessionItem)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetCreationUser(NFX.IO.FileSystem.FileSystemSessionItem)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetCreationUser(NFX.IO.FileSystem.FileSystemSessionItem)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetModificationUser(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override in particular file systems to get user who was the last user modifying the item.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetModificationUserAsync(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetModificationUser(NFX.IO.FileSystem.FileSystemSessionItem)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetModificationUser(NFX.IO.FileSystem.FileSystemSessionItem)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetModificationUser(NFX.IO.FileSystem.FileSystemSessionItem)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetLastAccessUser(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Override in particular file systems to get user who was the last user accessing the item.
            This method may be called by miltiple threads
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystem.DoGetLastAccessUserAsync(NFX.IO.FileSystem.FileSystemSessionItem)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetLastAccessUser(NFX.IO.FileSystem.FileSystemSessionItem)"/>.
            This base/default implementation just synchronously calls <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetLastAccessUser(NFX.IO.FileSystem.FileSystemSessionItem)"/> and
            returns already completed Task with result returned by <see cref="M:NFX.IO.FileSystem.FileSystem.DoGetLastAccessUser(NFX.IO.FileSystem.FileSystemSessionItem)"/>
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystem.Instances">
            <summary>
            Returns the read-only registry view of file systems currently activated
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystem.Name">
            <summary>
            Provides name for file system instance
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystem.Sessions">
            <summary>
            Returns a list of sessions. This accessor is thread-safe
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystem.GeneralCapabilities">
            <summary>
            Returns capabilities for this file system in general
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystem.InstanceCapabilities">
            <summary>
            Returns capabilities for this file system instance, that may or may not be the same as GeneralCapabilities
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.FileSystemSessionConnectParams">
            <summary>
            Provides parameters for new sessions establishment
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.FileSystemSession">
            <summary>
            Represents a user-impersonated session of working with a file system. This class is NOT thread-safe
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.#ctor(NFX.IO.FileSystem.FileSystem,NFX.IO.FileSystem.IFileSystemHandle,NFX.IO.FileSystem.FileSystemSessionConnectParams)">
            <summary>
            Starts new file system session
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.GetItemAsync(System.String)">
            <summary>
            Async version of <see cref="P:Item(string)"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.SetFileSystemVersionAsync(NFX.IO.FileSystem.IFileSystemVersion)">
            <summary>
            Async version of <see cref="P:Version"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.GetLatestVersionAsync">
            <summary>
            Async version of <see cref="P:LatestVersion"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.BeginTransaction">
            <summary>
            Starts a transaction returning its' transaction handle object, otherwise does nothing
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.BeginTransactionAsync">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemSession.BeginTransaction"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.CommitTransaction">
            <summary>
            Commits active transaction, does nothing otherwise
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.CommitTransactionAsync">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemSession.CommitTransaction"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.RollbackTransaction">
            <summary>
            Cancels active transaction changes, does nothing otherwise
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.RollbackTransactionAsync">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemSession.RollbackTransaction"/>
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.GetVersions(NFX.IO.FileSystem.IFileSystemVersion,System.Int32)">
            <summary>
            Returns specified number of versions going back from the specific version. This call is thread-safe
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.FileSystemSession.GetVersionsAsync(NFX.IO.FileSystem.IFileSystemVersion,System.Int32)">
            <summary>
            Async version of <see cref="M:NFX.IO.FileSystem.FileSystemSession.GetVersions(NFX.IO.FileSystem.IFileSystemVersion,System.Int32)"/>
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.Name">
            <summary>
            Returns session name
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.Handle">
            <summary>
            Returns file system handle for this session
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.FileSystem">
            <summary>
            Returns file system instance that this session operates under
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.User">
            <summary>
            Returns user that this file system session is for
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.TransactionHandle">
            <summary>
            Returns transaction object if transaction has been started or null
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.Items">
            <summary>
            Returns file system items initialized through this session
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.Item(System.String)">
            <summary>
            Navigates to the specified path
            </summary>
            <param name="path">Path to navigate to</param>
            <returns>FileSystemSessionItem instance - a directory or a file or null if it does not exist</returns>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.Version">
            <summary>
            Gets/sets version of the file system that this session works against (a changeset that session "sees")
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.LatestVersion">
            <summary>
            Returns latest version for file systems that support versioning, null otherwise
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.SecurityManager">
            <summary>
            Returns security manager that services this file system session. This may be useful in cases when file system implements
             its own permission structure and user directory
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.FileSystemSession.UniqueSequenceProvider">
            <summary>
            Returns unique sequence provider for the system or null if it is not supported
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.FileSystemStarter">
            <summary>
            Represents a starter that launches file systems on startup
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.FileSystemStream">
            <summary>
            Represents a stream that can work with contents of FileSystem. This class is NOT thread-safe
            </summary>
        </member>
        <member name="F:NFX.IO.FileSystem.FileSystemStream.Item">
            <summary>
            Item that this stream is for
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.IFileSystemVersion">
            <summary>
            Decorates entities that represent version for file systems that support versioning
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.IFileSystemHandle">
            <summary>
            Denotes a handle for item in a file system.
            For example: in a distributed system this may be some form of unique file/directory id (i.e. a GUID) or
             object instance internal to implementation
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.IFileSystemTransactionHandle">
            <summary>
            Denotes a handle for transaction in a file system.
            For example: in a distributed system this may be an object instance holding information about transaction which is internal to implementation
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.Local.LocalFileSystem">
            <summary>
            Implements NFX.IO.FileSystem support around local machine file system. This is needed for
             components that may need to work with various file systems i.e. Apache HDFS or Aum Cluster File System (ACFS).
            This particular implementation uses traditional System.IO.* and does not support transactions, versioning, metadata and NFX security
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.Local.LocalFileSystemCapabilities">
            <summary>
            Describes local file system capabilities
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.Packaging.LocalInstallation">
            <summary>
            Represents the local installation - facilitates working with locally installed packages
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.Packaging.LocalInstallation.#ctor(System.String,System.String)">
            <summary>
            Initializes local installation, tries to read local manifest from rootPath or localManifestDir if it is !=null
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.Packaging.LocalInstallation.BeginInstallation">
            <summary>
            Starts the installation so InstallPackage() can be called
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.Packaging.LocalInstallation.InstallPackage(NFX.IO.FileSystem.Packaging.LocalInstallation.PackageInfo)">
            <summary>
            Unconditionally installs a package - copies a set of files contained in the FileSystemDirectory assigning it some mnemonic name
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.Packaging.LocalInstallation.EndInstallation">
            <summary>
            Updates local installation manifest if changes have been made (Modified=true)
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.Packaging.LocalInstallation.FindMissingOrDifferentPackage(System.Collections.Generic.IEnumerable{NFX.IO.FileSystem.Packaging.LocalInstallation.PackageInfo})">
            <summary>
            Finds a package form the install set which is either missing on local machine or is not the same as the one in installSet.
            Returns the package info from install set
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.Packaging.LocalInstallation.CheckLocalAndInstallIfNeeded(System.Collections.Generic.IEnumerable{NFX.IO.FileSystem.Packaging.LocalInstallation.PackageInfo},System.Boolean)">
            <summary>
            Checks local installation first for missing of different packages and if there are no differences then returns false,
            otherwise re-installs all packages defined by in install-set locally and returns true.
            Pass force=true to re-install regardless of manifest comparison (false by default)
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.Packaging.LocalInstallation.RootPath">
            <summary>
            Root path of the installation
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.Packaging.LocalInstallation.InstallationStarted">
            <summary>
            Returns true to indicate that BeginInstallation() has been called
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.Packaging.LocalInstallation.Modified">
            <summary>
            Returns true to indicate that local installation has changed as the result of package installation
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.Packaging.LocalInstallation.PackageNames">
            <summary>
            Gets package names
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.Packaging.LocalInstallation.PackageManifests">
            <summary>
            Gets package manifests
            </summary>
        </member>
        <member name="P:NFX.IO.FileSystem.Packaging.LocalInstallation.Item(System.String)">
            <summary>
            Returns installed package manifest by name or null
            </summary>
        </member>
        <member name="T:NFX.IO.FileSystem.Packaging.LocalInstallation.PackageInfo">
            <summary>
            Provides package descriptor
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.Packaging.LocalInstallation.PackageInfo.#ctor(System.String,NFX.IO.FileSystem.FileSystemDirectory,System.String)">
            <summary>Provides package descriptor</summary>
            <param name="name">Mnemonic name of the package (i.e. application name)</param>
            <param name="source">Source directory where to take files from</param>
            <param name="relPath">Relative path which is appended to the root path where files will be placed</param>
        </member>
        <member name="T:NFX.IO.FileSystem.Packaging.ManifestUtils">
            <summary>
            Provides utilities for manifest generation
            </summary>
        </member>
        <member name="M:NFX.IO.FileSystem.Packaging.ManifestUtils.GeneratePackagingManifest(NFX.IO.FileSystem.FileSystemDirectory,System.String,System.String,System.String)">
            <summary>
            Generates packaging manifest for the specified directory. Optionally may specify root node name
            </summary>
            <param name="directory">Source directory to generate manifest for</param>
            <param name="rootNodeName">Name of root manifest node, if omitted then 'package' is defaulted</param>
            <param name="packageName">Optional 'name' attribute value under root node</param>
            <param name="packageLocalPath">Optional 'local-path' attribute value under root node</param>
        </member>
        <member name="M:NFX.IO.FileSystem.Packaging.ManifestUtils.HasTheSameContent(NFX.Environment.IConfigSectionNode,NFX.Environment.IConfigSectionNode,System.Boolean)">
            <summary>
            Returns true when both config nodes represents the same manifest - that is the same file structure
            </summary>
            <param name="master">Master sample copy</param>
            <param name="comparand">The second manifest being compared to the master</param>
            <param name="oneWay">If true iterates on master, so extra files in comparand will not be detected. False by default in whoch case iterates on master first then on comparand</param>
            <returns>True when comparand has all files/directories that the master lists</returns>
        </member>
        <member name="T:NFX.IO.LEB128">
            <summary>
            Facilitates int64/uint64 LEB128 encode/decode
            See https://en.wikipedia.org/wiki/LEB128
            See http://llvm.org/docs/doxygen/html/LEB128_8h_source.html
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.NetGateException">
            <summary>
            Throw by NetGate
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.GateAction">
            <summary>
            Allow/Deny
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.INetGate">
            <summary>
            Stipulates general contract for nrtwork gates - entities similar to firewall.
            Network gates allow/deny in/out traffic based on a set of rules
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.INetGate.CheckTraffic(NFX.IO.Net.Gate.ITraffic)">
            <summary>
            Checks whether the specified traffic is allowed or denied
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.INetGate.CheckTraffic(NFX.IO.Net.Gate.ITraffic,NFX.IO.Net.Gate.Rule@)">
            <summary>
            Checks whether the specified traffic is allowed or denied.
            Returns the rule that determined the allow/deny outcome or null when no rule matched
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.INetGate.IncreaseVariable(NFX.IO.Net.Gate.TrafficDirection,System.String,System.String,System.Int32)">
            <summary>
            Increases the named variable in the network scope which this specified traffic falls under
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.INetGate.SetVariable(NFX.IO.Net.Gate.TrafficDirection,System.String,System.String,System.Int32)">
            <summary>
            Sets the named variable in the network scope which this specified traffic falls under
            </summary>
        </member>
        <member name="P:NFX.IO.Net.Gate.INetGate.Enabled">
            <summary>
            When gate is not enabled it allows all traffic bypassing any rules
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.NOPNetGate">
            <summary>
            Represents an implementation of INetGate that allows all traffic
            </summary>
        </member>
        <member name="F:NFX.IO.Net.Gate.NOPNetGate.Instance">
            <summary>
            Default instance of INetGate implementation that allows all traffic
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.NetGate">
            <summary>
            Represents a network gate - a logical filter of incoming network traffic.
            Network gate is somewhat similar to a firewall - it allows/denies the int/out traffic based on the set of rules
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.NetGate.CheckTraffic(NFX.IO.Net.Gate.ITraffic)">
            <summary>
            Checks whether the specified traffic is allowed or denied
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.NetGate.CheckTraffic(NFX.IO.Net.Gate.ITraffic,NFX.IO.Net.Gate.Rule@)">
            <summary>
            Checks whether the specified traffic is allowed or denied.
            Returns the rule that determined the allow/deny outcome or null when no rule matched
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.NetGate.IncreaseVariable(NFX.IO.Net.Gate.TrafficDirection,System.String,System.String,System.Int32)">
            <summary>
            Increases the named variable in the network scope which this specified traffic falls under
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.NetGate.SetVariable(NFX.IO.Net.Gate.TrafficDirection,System.String,System.String,System.Int32)">
            <summary>
            Sets the named variable in the network scope which this specified traffic falls under
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.NetGate.Log(NFX.Log.MessageType,System.String,System.String,System.Exception,System.String,System.Nullable{System.Guid})">
            <summary>
            Facilitates net gate logging
            </summary>
        </member>
        <member name="P:NFX.IO.Net.Gate.NetGate.Item(NFX.IO.Net.Gate.TrafficDirection)">
            <summary>
            Returns gate state
            </summary>
        </member>
        <member name="P:NFX.IO.Net.Gate.NetGate.Enabled">
            <summary>
            Enables/diables the protection. When protection is disabled then all traffic is allowed
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.NetGate.State.FindGroupForAddress(System.String)">
            <summary>
            Returns the first matching group for address, or null
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.NetGate.State.FindNetSiteStateForAddress(System.String,NFX.IO.Net.Gate.Group@)">
            <summary>
            Returns existing NetSiteState object for specified address, first checking group membership or null
            </summary>
        </member>
        <member name="T:NFX.IOrdered">
            <summary>
            Denotes an entity that has a relative Order property within a collection of entities
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.Group.Match(System.String)">
            <summary>
            Tries to find an address in group and returns it or null
            </summary>
        </member>
        <member name="P:NFX.IO.Net.Gate.Group.Key">
            <summary>
            Returns group key for lookup in State.NetState object
            </summary>
        </member>
        <member name="P:NFX.IO.Net.Gate.Group.Addresses">
            <summary>
            Addresses that are part of the group
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.Group.Address">
            <summary>
            Represents the address node of the group
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.NetSiteState">
            <summary>
            Represents the state of the metwrk site - it can be a particular address or group
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.ITraffic">
            <summary>
            Represents a traffic that passes through network gate
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.HTTPIncomingTraffic">
            <summary>
            Represents HTTP traffic that arrives via HttpListener
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.GeneralTraffic">
            <summary>
            Represents general kind of traffic not bound to any particular technology
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.Rule">
            <summary>
            Represents the named rule for NetGate
            </summary>
        </member>
        <member name="M:NFX.IO.Net.Gate.Rule.Check(NFX.IO.Net.Gate.NetGate.State,NFX.IO.Net.Gate.ITraffic,NFX.IO.Net.Gate.Group@,NFX.IO.Net.Gate.Group@)">
            <summary>
            Cheks whether the rule is satisfied - all listed conditions are met. May lazily resolve addresses to groups
            </summary>
        </member>
        <member name="T:NFX.IO.Net.Gate.VarDef">
            <summary>
            Provides variable definition - the name and parameters how fast a variable decays - loses its value towards 0 when it gets deleted
            </summary>
        </member>
        <member name="T:NFX.IO.NonClosingStreamWrap">
            <summary>
            Implements a stream wrapper that does not close/get disposed.
            This stream is needed for TextWriter defect that always closes stream in its destructor
            </summary>
        </member>
        <member name="M:NFX.IO.NonClosingStreamWrap.#ctor(System.IO.Stream)">
            <summary>
            Allocates a wrapper around some other stream so it can be used with TextWriter that always closes the underlying stream
            in cases when the underlying stream needs to remain open after TextWriter is done
            </summary>
        </member>
        <member name="F:NFX.IO.NonClosingStreamWrap.Target">
            <summary>
            Target stream that this stream wraps
            </summary>
        </member>
        <member name="T:NFX.IO.SlimFormat">
            <summary>
            A format that writes into binary files in an efficient way using variable-length integers, strings and meta handles.
            Developers may derive new formats that support custom serialization of their business-related types. This may increase performance dramatically.
            For example, in a drawing application a new format may derive from SlimFormat to natively serialize Point and PolarPoint structs to yield faster serialization times.
            NFX.Serialization.Slim.SlimSlimSerializer is capable of SlimFormat-derived format injection, in which case it will automatically discover new types that are directly supported
            by the format.
            </summary>
        </member>
        <member name="T:NFX.IO.StreamerFormat`2">
            <summary>
            Describes a format - apair of readers/writers along with their capabilities.
            Developers may derive new formats that support custom serialization schemes
            </summary>
        </member>
        <member name="T:NFX.IO.StreamerFormat">
            <summary>
            Describes a format - apair of readers/writers along with their capabilities - what types format supports natively
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat.GetReadingStreamer(System.Text.Encoding)">
            <summary>
            Makes new reader instance
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat.GetWritingStreamer(System.Text.Encoding)">
            <summary>
            Makes new writer instance
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat.IsTypeSupported(System.Type)">
            <summary>
            Returns true when the supplied type is natively supported by format
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat.IsRefTypeSupported(System.Type)">
            <summary>
            Returns true when the supplied ref type is natively supported by format
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat.GetReadMethodForType(System.Type)">
            <summary>
            Returns a method info for reading a certain value type for this format or null if type is not supported
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat.GetReadMethodForRefType(System.Type)">
            <summary>
            Returns a method info for reading a certain ref type for this format or null if type is not supported
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat.GetWriteMethodForType(System.Type)">
            <summary>
            Returns a method info for writing a certain value type for this format or null if type is not supported
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat.GetWriteMethodForRefType(System.Type)">
            <summary>
            Returns a method info for writing a certain ref type for this format or null if type is not supported
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.GetReadingStreamer(System.Text.Encoding)">
            <summary>
            Makes new reader instance
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.GetWritingStreamer(System.Text.Encoding)">
            <summary>
            Makes new writer instance
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.MakeReadingStreamer(System.Text.Encoding)">
            <summary>
            Makes new reader instance
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.MakeWritingStreamer(System.Text.Encoding)">
            <summary>
            Makes new writer instance
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.IsTypeSupported(System.Type)">
            <summary>
            Returns true when the supplied value type is natively supported by format, that is - when this format
             can directly write instances of this type without reflection/complex graph walk.
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.IsRefTypeSupported(System.Type)">
            <summary>
            Returns true when the supplied reference type is natively supported by format, that is - when this format
             can directly write instances of this type without reflection/complex graph walk.
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.GetReadMethodForType(System.Type)">
            <summary>
            Returns a method info for reading a certain value type for this format or null if this type is not directly supported.
            Use IsTypeSupported(type) to see if the type is native to this format.
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.GetReadMethodForRefType(System.Type)">
            <summary>
            Returns a method info for reading a certain reference type for this format or null if this type is not directly supported.
            Use IsRefTypeSupported(type) to see if the ref type is native to this format.
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.GetWriteMethodForType(System.Type)">
            <summary>
            Returns a method info for writing a certain value type for this format.
            Use IsTypeSupported(type) to see if the type is native to this format.
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.GetWriteMethodForRefType(System.Type)">
            <summary>
            Returns a method info for writing a certain ref type for this format.
            Use IsRefTypeSupported(type) to see if the type is native to this format.
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.GetReadActionForType(System.Type)">
            <summary>
            Returns a function that reads the specified value type and returns it as object
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.GetReadActionForRefType(System.Type)">
            <summary>
            Returns a function that reads the specified ref type and returns it as object
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.GetWriteActionForType(System.Type)">
            <summary>
            Returns an action that writes the value of the specified value type
            </summary>
        </member>
        <member name="M:NFX.IO.StreamerFormat`2.GetWriteActionForRefType(System.Type)">
            <summary>
            Returns an action that writes the value of the specified ref type
            </summary>
        </member>
        <member name="F:NFX.IO.SlimFormat.TypeSchema">
            <summary>
            Internally references type schema
            </summary>
        </member>
        <member name="P:NFX.IO.SlimFormat.Instance">
            <summary>
            Returns a singleton format instance
            </summary>
        </member>
        <member name="T:NFX.KeyedMonitor`1">
            <summary>
            Provides Monitor thread synchronization functionality over lock objects addressable by key(name).
            This class is thread-safe. The internal implementation is based on a fixed-size array of Dictionary objects
            to minimize inter-locking. Do not allocate/deallocate this class often, instead allocate
            once per service that needs to synchronize by keys and call methods on the instance.
            </summary>
        </member>
        <member name="M:NFX.KeyedMonitor`1.Synchronized(`0,System.Action)">
            <summary>
            Executes an action under a lock() taken on TKey value
            </summary>
        </member>
        <member name="M:NFX.KeyedMonitor`1.Synchronized``1(`0,System.Func{``0})">
            <summary>
            Executes a function under a lock() taken on TKey value
            </summary>
        </member>
        <member name="M:NFX.KeyedMonitor`1.Enter(`0)">
            <summary>
            Performs Monitor.Enter() on TKey value.
            Unlike TryEnter() this method does block
            </summary>
        </member>
        <member name="M:NFX.KeyedMonitor`1.TryEnter(`0)">
            <summary>
            Tries to perform Monitor.TryEnter() on TKey value.
            Returns true when lock was taken. Unlike Enter() this method does not block
            </summary>
        </member>
        <member name="M:NFX.KeyedMonitor`1.Exit(`0)">
            <summary>
            Performs Monitor.Exit() on TKey value. Returns false in cases when lock was not taken which indicates an error
            in the calling control flow
            </summary>
        </member>
        <member name="T:NFX.Log.Bin.BinLogException">
            <summary>
            Base exception thrown by the binlog-related framework
            </summary>
        </member>
        <member name="T:NFX.Log.Bin.ILogMetadata">
            <summary>
            Denotes entities that represent metadata - extra information about data such as timestamps and corruptions
            </summary>
        </member>
        <member name="T:NFX.Log.Bin.LogUTCTimeStamp">
            <summary>
            Denotes a special surrogate structure that wraps DatTime in log.
            These structures get inserted in log automatically by binary log writers to indicate te point in time
            </summary>
        </member>
        <member name="T:NFX.Log.Bin.LogCorruption">
            <summary>
            Denotes a special surrogate structure that indicates log corruption
            </summary>
        </member>
        <member name="F:NFX.Log.Bin.LogCorruption.Instance">
            <summary>
            Singleton instance of LogCorruption
            </summary>
        </member>
        <member name="T:NFX.Log.Bin.Format">
            <summary>
            Facilittates reading primitive values from stream
            </summary>
        </member>
        <member name="T:NFX.Log.Bin.SlimLogWriter">
            <summary>
            Writes bin log in Slim format. The format does not support object versioning however it is
            very efficient in both space and speed
            </summary>
        </member>
        <member name="T:NFX.Log.Bin.SlimLogReader">
            <summary>
            Reads bin log in Slim format. The format does not support object versioning however it is
            very efficient in both space and speed
            </summary>
        </member>
        <member name="T:NFX.Log.Bin.LogReader">
            <summary>
            Provides abstraction for binary object log readers. Use Open(stream method) to obtain the
            instance of the reader type appropriate for particular content.
            This class is NOT thread safe
            </summary>
        </member>
        <member name="M:NFX.Log.Bin.LogReader.Open(System.IO.Stream)">
            <summary>
            Opens the appropriate reader type from the stream
            </summary>
        </member>
        <member name="M:NFX.Log.Bin.LogReader.ReadFromStart(System.Boolean)">
            <summary>
            Returns the lazy enumerable that fetches data from the very log start, optionally including time stamps
            </summary>
        </member>
        <member name="M:NFX.Log.Bin.LogReader.ReadFromAround(System.DateTime,System.Boolean)">
            <summary>
            Returns the lazy enumerable that fetches data from the point in time, optionally including time stamps
            </summary>
        </member>
        <member name="P:NFX.Log.Bin.LogReader.Stream">
            <summary>
            Returns the underlying stream
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.DocumentModel.IPdfObject">
            <summary>
            Object that can be placed in PDF document
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.IPdfObject.GetReference">
            <summary>
            Returns PDF object indirect reference
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.IPdfObject.ObjectId">
            <summary>
            Document-wide unique object Id
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.DocumentModel.IPdfResource">
            <summary>
            Object that can be placed in PDF document as a resource
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.IPdfResource.GetResourceReference">
            <summary>
            Returns PDF object indirect reference
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.IPdfResource.ResourceId">
            <summary>
            Document-wide unique resource Id
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.DocumentModel.IPdfWritable">
            <summary>
            Represents entities that has string representation in PDF
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.IPdfWritable.ToPdfString">
            <summary>
            Returns PDF string representation
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.DocumentModel.IPdfXObject">
            <summary>
            XObject that can be placed in PDF document
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.IPdfXObject.GetXReference">
            <summary>
            Returns PDF x-object indirect reference
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.IPdfXObject.XObjectId">
            <summary>
            Document-wide unique x-object Id
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.DocumentModel.PdfDocument">
            <summary>
            Model for PDF document
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfDocument.AddPage(NFX.Media.PDF.Styling.PdfUnit)">
            <summary>
            Adds new page to document
            </summary>
            <returns>Page</returns>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfDocument.AddPage(NFX.Media.PDF.Styling.PdfSize)">
            <summary>
            Adds new page to document
            </summary>
            <returns>Page</returns>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfDocument.Save(System.String)">
            <summary>
            Save document to file
            </summary>
            <param name="filePath">File path</param>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfDocument.prepare">
            <summary>
            Supplies document objects with unique sequential Ids
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfDocument.Fonts">
            <summary>
            Used fonts
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfDocument.Meta">
            <summary>
            PDF document meta
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfDocument.Info">
            <summary>
            Document info
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfDocument.Outlines">
            <summary>
            Document outlines
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfDocument.Root">
            <summary>
            Document header
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfDocument.Pages">
            <summary>
            Document pages
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfDocument.Trailer">
            <summary>
            Document trailer
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfDocument.PageTree">
            <summary>
            Document page tree
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfDocument.PageSize">
            <summary>
            Size for all pages created after it's setting
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfDocument.Unit">
            <summary>
            User units for all pages created after it's setting
            (the default user space unit is 1/72 inch)
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.DocumentModel.PdfFont">
            <summary>
            PDF Font
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.DocumentModel.PdfObject">
            <summary>
            PDF document header
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfObject.GetReference">
            <summary>
            Returns PDF object indirect reference
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfObject.ObjectId">
            <summary>
            Document-wide unique object Id
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfFont.ByName(System.String)">
            <summary>
            Returns existing font by name or creates and registers a new one
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfFont.GetResourceReference">
            <summary>
            Returns PDF object indirect reference
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfFont.Name">
            <summary>
            Font name
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfFont.ResourceId">
            <summary>
            Document-wide unique resource Id
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.DocumentModel.PdfHeader">
            <summary>
            PDF document header
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfHeader.OutlinesId">
            <summary>
            Document outlines' object Id
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfHeader.InfoId">
            <summary>
            Document info's object Id
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfHeader.PageTreeId">
            <summary>
            Document page tree's object Id
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.DocumentModel.PdfInfo">
            <summary>
            PDF document info
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfInfo.Title">
            <summary>
            Document's title
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfInfo.Subject">
            <summary>
            Document's subject
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfInfo.Keywords">
            <summary>
            Document's keywords
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfInfo.Author">
            <summary>
            Document's author
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfInfo.CreationDate">
            <summary>
            Document's creation date
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfInfo.ModificationDate">
            <summary>
            Document's modification date
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfInfo.Creator">
            <summary>
            Document's creator program
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfInfo.Producer">
            <summary>
            Document's producer (if it started as another program)
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.DocumentModel.PdfMeta">
            <summary>
            PDF document metadata
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfMeta.Version">
            <summary>
            PDF document version
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.DocumentModel.PdfOutlines">
            <summary>
            PDF document outlines
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.DocumentModel.PdfPage">
            <summary>
            PDF Page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.Add(NFX.Media.PDF.Elements.PdfElement)">
            <summary>
            Adds PDF element to page's elements collection
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddText(System.String)">
            <summary>
            Add raw text to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddText(System.String,System.Single,NFX.Media.PDF.DocumentModel.PdfFont)">
            <summary>
            Add raw text to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddText(System.String,System.Single,NFX.Media.PDF.DocumentModel.PdfFont,NFX.Media.PDF.Styling.PdfColor)">
            <summary>
            Add raw text to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddPath(System.Single,System.Single)">
            <summary>
            Add path to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddPath(System.Single,System.Single,System.Single)">
            <summary>
            Add path to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddPath(System.Single,System.Single,System.Single,NFX.Media.PDF.Styling.PdfColor)">
            <summary>
            Add path to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddPath(System.Single,System.Single,System.Single,NFX.Media.PDF.Styling.PdfColor,NFX.Media.PDF.Styling.PdfLineType)">
            <summary>
            Add path to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddPath(System.Single,System.Single,NFX.Media.PDF.Styling.PdfDrawStyle)">
            <summary>
            Add path to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddLine(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Add line primitive to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddLine(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Add line primitive to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddLine(System.Single,System.Single,System.Single,System.Single,System.Single,NFX.Media.PDF.Styling.PdfColor)">
            <summary>
            Add line primitive to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddLine(System.Single,System.Single,System.Single,System.Single,System.Single,NFX.Media.PDF.Styling.PdfColor,NFX.Media.PDF.Styling.PdfLineType)">
            <summary>
            Add line primitive to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddLine(System.Single,System.Single,System.Single,System.Single,NFX.Media.PDF.Styling.PdfDrawStyle)">
            <summary>
            Add line primitive to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddCircle(System.Single,System.Single,System.Single,NFX.Media.PDF.Styling.PdfColor)">
            <summary>
            Add circle primitive to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddCircle(System.Single,System.Single,System.Single,NFX.Media.PDF.Styling.PdfColor,System.Single)">
            <summary>
            Add circle primitive to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddCircle(System.Single,System.Single,System.Single,NFX.Media.PDF.Styling.PdfColor,System.Single,NFX.Media.PDF.Styling.PdfColor)">
            <summary>
            Add circle primitive to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddCircle(System.Single,System.Single,System.Single,NFX.Media.PDF.Styling.PdfColor,System.Single,NFX.Media.PDF.Styling.PdfColor,NFX.Media.PDF.Styling.PdfLineType)">
            <summary>
            Add circle primitive to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddCircle(System.Single,System.Single,System.Single,NFX.Media.PDF.Styling.PdfDrawStyle)">
            <summary>
            Add circle primitive to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddRectangle(System.Single,System.Single,System.Single,System.Single,NFX.Media.PDF.Styling.PdfColor)">
            <summary>
            Add rectangle primitive to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddRectangle(System.Single,System.Single,System.Single,System.Single,NFX.Media.PDF.Styling.PdfColor,System.Single)">
            <summary>
            Add rectangle primitive to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddRectangle(System.Single,System.Single,System.Single,System.Single,NFX.Media.PDF.Styling.PdfColor,System.Single,NFX.Media.PDF.Styling.PdfColor)">
            <summary>
            Add rectangle primitive to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddRectangle(System.Single,System.Single,System.Single,System.Single,NFX.Media.PDF.Styling.PdfColor,System.Single,NFX.Media.PDF.Styling.PdfColor,NFX.Media.PDF.Styling.PdfLineType)">
            <summary>
            Add rectangle primitive to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddRectangle(System.Single,System.Single,System.Single,System.Single,NFX.Media.PDF.Styling.PdfDrawStyle)">
            <summary>
            Add rectangle primitive to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddImage(System.String)">
            <summary>
            Add image to the page
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPage.AddImage(System.String,System.Single,System.Single)">
            <summary>
            Add image to the page
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfPage.Height">
            <summary>
            Page's height
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfPage.Width">
            <summary>
            Page's width
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfPage.Elements">
            <summary>
            Page elements
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfPage.UserUnit">
            <summary>
            User space units
            (the default user space unit is 1/72 inch)
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfPage.Parent">
            <summary>
            Page tree
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfPage.Fonts">
            <summary>
            Fonts used on the page
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.DocumentModel.PdfPageTree">
            <summary>
            PDF Page Tree document object
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfPageTree.CreatePage(NFX.Media.PDF.Styling.PdfSize)">
            <summary>
            Creates new page and adds it to the page tree
            </summary>
            <returns></returns>
        </member>
        <member name="T:NFX.Media.PDF.DocumentModel.PdfRoot">
            <summary>
            PDF document header
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfRoot.Outlines">
            <summary>
            Document outlines' object Id
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfRoot.Info">
            <summary>
            Document info's object Id
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfRoot.PageTree">
            <summary>
            Document page tree's object Id
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.DocumentModel.PdfTrailer">
            <summary>
            PDF Trailer document object
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.DocumentModel.PdfTrailer.AddObjectOffset(System.Int64)">
            <summary>
            Add inserted object offset to offsets collection
            </summary>
            <param name="offset">Offset</param>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfTrailer.LastObjectId">
            <summary>
            Id of the last inserted document object
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfTrailer.Root">
            <summary>
            PDF document's root
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfTrailer.ObjectOffsets">
            <summary>
            Inserted objects offest in PDF format
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.DocumentModel.PdfTrailer.XRefOffset">
            <summary>
            The offset of the XREF table
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.Elements.BezierPrimitive">
            <summary>
            PDF Bezier curve primitive as a part of path
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.Elements.PathPrimitive">
            <summary>
            PDF path primitive (a line, Bezier curve,...) as a part of path
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.Elements.PathPrimitive.ToPdfString">
            <summary>
            Returns PDF string representation
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.Elements.BezierPrimitive.ToPdfString">
            <summary>
            Returns PDF string representation on the line primitive
            </summary>
            <returns></returns>
        </member>
        <member name="P:NFX.Media.PDF.Elements.BezierPrimitive.FirstControlX">
            <summary>
            X coordinate of Bezier's curve first control point
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.Elements.BezierPrimitive.FirstControlY">
            <summary>
            Y coordinate of Bezier's curve first control point
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.Elements.BezierPrimitive.SecondControlX">
            <summary>
            X coordinate of Bezier's curve second control point
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.Elements.BezierPrimitive.SecondControlY">
            <summary>
            Y coordinate of Bezier's curve second control point
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.Elements.BezierPrimitive.EndX">
            <summary>
            X coordinate of Bezier's curve last point
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.Elements.BezierPrimitive.EndY">
            <summary>
            Y coordinate of Bezier's curve last point
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.Elements.ImageElement">
            <summary>
            PDF image element
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.Elements.PdfElement">
            <summary>
            Base class for all PDF primitives
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.Elements.PdfElement.Write(NFX.Media.PDF.PdfWriter)">
            <summary>
            Writes element into file stream
            </summary>
            <param name="writer">PDF writer</param>
        </member>
        <member name="P:NFX.Media.PDF.Elements.PdfElement.X">
            <summary>
            X-coordinate
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.Elements.PdfElement.Y">
            <summary>
            Y-coordinate
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.Elements.ImageElement.GetXReference">
            <summary>
            Returns PDF x-object indirect reference
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.Elements.ImageElement.Write(NFX.Media.PDF.PdfWriter)">
            <summary>
            Writes element into file stream
            </summary>
            <param name="writer">PDF writer</param>
            <returns>Written bytes count</returns>
        </member>
        <member name="P:NFX.Media.PDF.Elements.ImageElement.XObjectId">
            <summary>
            Image unique object Id
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.Elements.ImageElement.Width">
            <summary>
            PDF displayed image width
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.Elements.ImageElement.Height">
            <summary>
            PDF displayed image height
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.Elements.ImageElement.Content">
            <summary>
            Image bytes
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.Elements.ImageElement.OwnWidth">
            <summary>
            Image's own widht
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.Elements.ImageElement.OwnHeight">
            <summary>
            Image's own height
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.Elements.ImageElement.BitsPerPixel">
            <summary>
            Returns image's bits per pixel
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.Elements.LinePrimitive">
            <summary>
            PDF line primitive as a part of path
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.Elements.LinePrimitive.ToPdfString">
            <summary>
            Returns PDF string representation on the line primitive
            </summary>
            <returns></returns>
        </member>
        <member name="P:NFX.Media.PDF.Elements.LinePrimitive.EndX">
            <summary>
            Line's end X coordinate
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.Elements.LinePrimitive.EndY">
            <summary>
            Line's end Y coordinate
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.Elements.PathElement">
            <summary>
            PDF path element as a collection of path primitives (lines, Bezier curves etc.)
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.Elements.TextElement">
            <summary>
            PDF text element
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.Elements.TextElement.Write(NFX.Media.PDF.PdfWriter)">
            <summary>
            Writes element into file stream
            </summary>
            <param name="writer">PDF writer</param>
            <returns>Written bytes count</returns>
        </member>
        <member name="P:NFX.Media.PDF.Elements.TextElement.Content">
            <summary>
            Text content
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.Elements.TextElement.FontSize">
            <summary>
            Font size
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.Elements.TextElement.Font">
            <summary>
            PDF Font
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.Elements.TextElement.Color">
            <summary>
            PDF Color
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.PdfException">
            <summary>
            Base exception thrown by the PDF framework
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.ObjectRepository">
            <summary>
            Class that generates document-wide unique object Id-s
            (the class is not thread-safe)
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.PdfWriter">
            <summary>
            Class that aggregates PDF format-specific writing logic
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.PdfWriter.Write(NFX.Media.PDF.DocumentModel.PdfDocument)">
            <summary>
            Writes PDF document into file stream
            </summary>
            <param name="document">PDF document</param>
        </member>
        <member name="M:NFX.Media.PDF.PdfWriter.Write(NFX.Media.PDF.DocumentModel.PdfFont)">
            <summary>
            Writes PDF font into file stream
            </summary>
            <param name="font">PDF font</param>
        </member>
        <member name="M:NFX.Media.PDF.PdfWriter.Write(NFX.Media.PDF.DocumentModel.PdfRoot)">
            <summary>
            Writes PDF header into file stream
            </summary>
            <param name="root">PDF document root</param>
        </member>
        <member name="M:NFX.Media.PDF.PdfWriter.Write(NFX.Media.PDF.DocumentModel.PdfInfo)">
            <summary>
            Writes PDF info into file stream
            </summary>
            <param name="info">PDF document info</param>
        </member>
        <member name="M:NFX.Media.PDF.PdfWriter.Write(NFX.Media.PDF.DocumentModel.PdfOutlines)">
            <summary>
            Writes PDF document outlines into file stream
            </summary>
            <param name="outlines">PDF document outlines</param>
        </member>
        <member name="M:NFX.Media.PDF.PdfWriter.Write(NFX.Media.PDF.DocumentModel.PdfPageTree)">
            <summary>
            Writes PDF document page tree into file stream
            </summary>
            <param name="pageTree">PDF document page tree</param>
        </member>
        <member name="M:NFX.Media.PDF.PdfWriter.Write(NFX.Media.PDF.DocumentModel.PdfPage)">
            <summary>
            Writes PDF page into file stream
            </summary>
            <param name="page">PDF page</param>
        </member>
        <member name="M:NFX.Media.PDF.PdfWriter.Write(NFX.Media.PDF.DocumentModel.PdfTrailer)">
            <summary>
            Writes PDF document trailer into file stream
            </summary>
            <param name="trailer">PDF document trailer</param>
        </member>
        <member name="M:NFX.Media.PDF.PdfWriter.Write(NFX.Media.PDF.Elements.ImageElement)">
            <summary>
            Writes PDF image element into file stream
            </summary>
            <param name="image">PDF image element</param>
        </member>
        <member name="M:NFX.Media.PDF.PdfWriter.WriteXObject(NFX.Media.PDF.Elements.ImageElement)">
            <summary>
            Writes PDF image xObject element into file stream
            </summary>
            <param name="image">PDF image xObject element</param>
        </member>
        <member name="M:NFX.Media.PDF.PdfWriter.Write(NFX.Media.PDF.Elements.PathElement)">
            <summary>
            Writes PDF path into file stream
            </summary>
            <param name="path">PDF path element</param>
        </member>
        <member name="M:NFX.Media.PDF.PdfWriter.Write(NFX.Media.PDF.Elements.RectangleElement)">
            <summary>
            Writes PDF rectangle element into file stream
            </summary>
            <param name="rectangle">PDF rectangle element</param>
        </member>
        <member name="M:NFX.Media.PDF.PdfWriter.Write(NFX.Media.PDF.Elements.TextElement)">
            <summary>
            Writes PDF text element into file stream
            </summary>
            <param name="text">PDF text element</param>
        </member>
        <member name="P:NFX.Media.PDF.PdfWriter.PrettyFormatting">
            <summary>
            Insert nonnecessary tabs and returns for a pretty output look file
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.ResourceRepository">
            <summary>
            Class that generates document-wide unique resource Id-s
            (the class is not thread-safe)
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.Styling.PdfHorizontalAlign">
            <summary>
            PDF element's horizontal alignment enumeration
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.Styling.PdfLineType">
            <summary>
            PDF line's style enumeration
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.Styling.PdfColor">
            <summary>
            PDF Color
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.Styling.PdfColor.ByName(System.String)">
            <summary>
            Returns existing color by name or throws if it is not found
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.Styling.PdfColor.ByName(System.String,System.Byte,System.Byte,System.Byte)">
            <summary>
            Returns existing color by name or creates and registers a new one
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.Styling.PdfColor.ToPdfString">
            <summary>
            Returns PDF string representation
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.Styling.PdfDrawStyle">
            <summary>
            PDF line's style
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.Styling.PdfDrawStyle.ToPdfString">
            <summary>
            Returns PDF string representation
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.Styling.PdfPageSize">
            <summary>
            Page size definitions (ISO and others)
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.Styling.PdfSize">
            <summary>
            PDF size with its units
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.Styling.PdfSize.ChangeUnits(NFX.Media.PDF.Styling.PdfUnit)">
            <summary>
            Change unit of the size and recalculate height and width
            </summary>
            <param name="unit">New unit</param>
        </member>
        <member name="P:NFX.Media.PDF.Styling.PdfSize.Unit">
            <summary>
            Pdf unit measured in default points (1 pt = 1/72 inch)
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.Styling.PdfSize.Height">
            <summary>
            Height measured in values calculated according to Unit property
            (by default: 1 pt = 1/72 inch)
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.Styling.PdfSize.Width">
            <summary>
            Width measured in values calculated according to Unit property
            (by default: 1 pt = 1/72 inch)
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.Styling.PdfUnit">
            <summary>
            Represents a unit of PDF coordinates. Units are relative to standard pdf point, which is 1/72 inch by default.
            Use ByName() accessor to get/create units, or use one of the stock units: PdfUnit.Inch|Millimeter|Point...
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.Styling.PdfUnit.ByName(System.String)">
            <summary>
            Returns existing unit by name or throws if it is not found
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.Styling.PdfUnit.ByName(System.String,System.Single)">
            <summary>
            Returns existing unit by name or creates and registers a new one
            </summary>
        </member>
        <member name="P:NFX.Media.PDF.Styling.PdfUnit.Points">
            <summary>
            Number of default user space units in current unit
            (1 default user space unit is 1/72 inch)
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.Text.PdfTrivialEncoding">
            <summary>
            The trivial encoding is simply the identity relation between characters and bytes.
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.Text.PdfUnicodeEncoding">
            <summary>
            Unicode strings encoding.
            </summary>
        </member>
        <member name="T:NFX.Media.PDF.Text.TextAdapter">
            <summary>
            Utility class for operations with text
            </summary>
        </member>
        <member name="M:NFX.Media.PDF.Text.TextAdapter.FormatHexStringLiteral(System.Byte[])">
            <summary>
            Converts the specified byte array into a byte array representing a unicode hex string literal.
            </summary>
            <param name="bytes">The bytes of the string.</param>
            <returns>The PDF bytes.</returns>
        </member>
        <member name="M:NFX.Media.PDF.Text.TextAdapter.FormatFloat(System.Double)">
            <summary>
            Formats given float with a dot as fraction part delimeter and foors it to 4 digits after dot
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:NFX.Media.TagCodes.QR.QREncoderMatrix.WriteTerminationSection(System.Int32,NFX.Collections.BitList)">
            <summary>
            Write termination section according 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).
            </summary>
        </member>
        <member name="M:NFX.Media.TagCodes.QR.QREncoderMatrix.GetNumDataBytesAndNumCorrectionBytesByBlockID(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32[])">
            <summary>
            According to JISX0510:2004 (p.30) tbl 12 in 8.5.1
            Calculate data and correction bytes for block
            </summary>
            <param name="numTotalBytes">Total bytes count</param>
            <param name="numDataBytes">Data bytes count</param>
            <param name="numRSBlocks">Reed/Solomon blocks count</param>
            <param name="blockID">Block Id</param>
            <param name="numDataBytesInBlock">Data bytes count in this block</param>
            <param name="numECBytesInBlock">Correction bytes count in this block</param>
        </member>
        <member name="M:NFX.Media.TagCodes.QR.QREncoderMatrix.MixWithCorrectionBytes(NFX.Collections.BitList,System.Int32,System.Int32,System.Int32)">
            <summary>
            According to JISX0510:2004 8.6 p.37 bits are mixed mixes with their correction bytes.
            </summary>
            <param name="bits">Data bits</param>
            <param name="numTotalBytes">Total bytes count</param>
            <param name="numDataBytes">Data bytes count</param>
            <param name="rsBlocksQty">Reed/Solomon blocks count</param>
            <returns>Mixed bits</returns>
        </member>
        <member name="T:NFX.Log.Destinations.MemoryBufferDestination">
            <summary>
            Implements a destination that caches up to specified number of latest log messages in memory
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.Destination">
            <summary>
            Represents logging message destination - an abstract entity that messages are written to by LogService.
            Destinations must be efficient as they block logger thread. They provide failover mechanism when
             processing can not be completed. Once failed, the processing can try to be resumed after configurable interval.
            Destinations also provide optional SLA on the time it takes to perform actual message write - once exceeded destination is considered to have failed.
            Basic efficient filtering is provided for times, dates and levels. Complex C# expression-based filtering is also supported
            </summary>
        </member>
        <member name="F:NFX.Log.Destinations.Destination.PROCESSING_TIME_EMA_FILTER">
            <summary>
            Defines how much smoothing the processing time filter does - the lower the number the more smoothing is done.
            Smoothing makes MaxProcessingTimeMs detection insensitive to some seldom delays that may happen every now and then
            while destination performs actual write into its sink
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.ExternalParametersForGroups(System.String[])">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.Configure(NFX.Environment.IConfigSectionNode)">
            <summary>
            Configures specified destination
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.Open">
            <summary>
            Activates destination by preparing it to start operation
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.Close">
            <summary>
            Deactivates destination
            </summary>
        </member>
        <member name="F:NFX.Log.Destinations.Destination.Before">
            <summary>
            Allows to insert a destination right before this one
            </summary>
        </member>
        <member name="F:NFX.Log.Destinations.Destination.After">
            <summary>
            Allows to insert a destination right after this one
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.Send(NFX.Log.Message)">
            <summary>
            Sends the message into destination doing filter checks first.
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.Pulse">
            <summary>
            Provides periodic notification of destinations from central Log thread even if there are no messages to write.
            Override DoPulse to commit internal batching buffers provided by particular destinations
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.ParseLevels(System.String)">
            <summary>
            Parses levels into a tuple list of level ranges
            </summary>
            <param name="levels">String representation of levels using ',' or ';' or '|'
            as range group delimiters, and '-' as range indicators.  If first/second bound of the range
            is empty, the min/max value of that bound is assumed.
            Examples: "Debug-DebugZ | Error", "-DebugZ | Info | Warning", "Info-", "DebugB-DebugC, Error"</param>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.ExternalGetParameter(System.String,System.Object@,System.String[])">
            <summary>
            Gets external parameter value returning true if parameter was found
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.ExternalSetParameter(System.String,System.Object,System.String[])">
            <summary>
            Sets external parameter value returning true if parameter was found and set
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.DoConfigure(NFX.Environment.IConfigSectionNode)">
            <summary>
            Override to perform derivative-specific configuration
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.SetError(System.Exception,NFX.Log.Message)">
            <summary>
            Notifies log service of exception that surfaced during processing of a particular message
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.DoSend(NFX.Log.Message)">
            <summary>
            Performs physical send, i.e. storage in file for FileDestinations
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.Destination.DoPulse">
            <summary>
            Provides periodic notification of destinations from central Log thread even if there are no messages to write.
            Override to commit internal batching buffers provided by particular destinations
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.Service">
            <summary>
            References a log service that this destination services
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.Owner">
            <summary>
            Returns a composite destination that ownes this destination or null
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.Name">
            <summary>
            Provides mnemonic destination name
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.Filter">
            <summary>
            Gets/sets filter expression for this destination.
            Filter expressions get dynamically compiled into filter assembly,
            consequently it is not a good practice to create too many different filters.
            Filters are heavyweight, and it is advisable to use them ONLY WHEN regular destination filtering (using Min/Max levels, dates and times) can not be used
             to achieve the desired result
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.FilterMethod">
            <summary>
            References message filtering method or null
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.LastError">
            <summary>
            Returns last error that this destination has encountered
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.LastErrorTimestamp">
            <summary>
            Returns last error timestamp (if any)
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.MinLevel">
            <summary>
            Imposes a minimum log level constraint
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.MaxLevel">
            <summary>
            Imposes a maximum log level constraint
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.DaysOfWeek">
            <summary>
            Imposes a filter on days when this destination handles messages
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.StartDate">
            <summary>
            Imposes a filter that specifies the starting date and time
            after which this destination will start processing log messages
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.EndDate">
            <summary>
            Imposes a filter that specifies the ending date and time
            before which this destination will be processing log messages
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.StartTime">
            <summary>
            Imposes a filter that specifies the starting time of the day
            after which this destination will start processing log messages
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.EndTime">
            <summary>
            Imposes a filter that specifies the ending time of the day
            before which this destination will be processing log messages
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.OnlyFailures">
            <summary>
            Indicates whether this destination should only process failures - messages that crashed other destinations.
            When set to true regular messages (dispatched by Send(msg)) are ignored
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.GenerateFailoverMessages">
            <summary>
            Determines whether additional co-related error message should be generated when this destination fails or when it is
             used as failover by some other destination. When this property is true an additional error message gets written into failover destination that
              describes what message caused failure (error is co-related to original) at what destination. False by default.
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.Failover">
            <summary>
            Sets destination name used for failover of this one
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.TestOnStart">
            <summary>
            Indicates whether this destination should try to test the underlying sink on startup.
            For example DB-based destinations will try to connect to server upon log service launch when this property is true
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.MaxProcessingTimeMs">
            <summary>
            Imposes a time limit on internal message processing (writing into actual sink) by this destination.
            If this limit is exceeded, this destination fails and processing is re-tried to be resumed after RestartProcessingAfterMs interval.
            The minimum value for this property is 25 ms as lower values compromise timer accuracy
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.AverageProcessingTimeMs">
            <summary>
            Returns average time it takes destination implementation to write the log message to actual sink.
            This property is only computed when MaxProcessingTimeMs limit is imposed, otherwise it returns 0f
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.RestartProcessingAfterMs">
            <summary>
            Specifies how much time must pass before processing will be tried to resume after failure.
            The default value is 60000 ms
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.Destination.ExternalParameters">
            <summary>
            Returns named parameters that can be used to control this component
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.MemoryBufferDestination.ClearBuffer">
            <summary>
            Deletes all buffered messages
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.MemoryBufferDestination.Buffered">
            <summary>
            Returns all buffered log messages, where X = BufferSize property
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.MemoryBufferDestination.BufferedTimeAscending">
            <summary>
            Returns all buffered log messages ordered by timestamp ascending
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.MemoryBufferDestination.BufferedTimeDescending">
            <summary>
            Returns all buffered log messages ordered by timestamp descending
            </summary>
        </member>
        <member name="T:NFX.ConvertErrorHandling">
            <summary>
            Specifies how to handle errors during object value conversion
            </summary>
        </member>
        <member name="T:NFX.ObjectValueConversion">
            <summary>
            Provides extension methods for converting object values to different scalar types
            </summary>
        </member>
        <member name="T:NFX.ObjectValueConversion.TriStateBool">
            <summary>
            A "hack" enum used to provide tri-state checkbox functionality in some systems, i.e. HTML checkmarks
            do not understand "nulls". This is a surrogate type not used in server-side programming
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.QueryResolver">
            <summary>
            Infrastructure class - not for app developers.
            Resolves Query objects into query handlers. Query names are case-insensitive.
            This class is thread-safe
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.ICRUDQueryResolver">
            <summary>
            Represents a class that resolves Query into suitable handler that can execute it
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.ICRUDQueryResolver.Resolve(NFX.DataAccess.CRUD.Query)">
            <summary>
            Retrieves a handler for supplied query. The implementation must be thread-safe
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.ICRUDQueryResolver.RegisterHandlerLocation(System.String)">
            <summary>
            Registers handler location.
            The Resolver must be not started yet. This method is NOT thread safe
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.ICRUDQueryResolver.UnregisterHandlerLocation(System.String)">
            <summary>
            Unregisters handler location returning true if it was found and removed.
            The Resolve must be not started yet. This method is NOT thread safe
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.QueryResolver.RegisterHandlerLocation(System.String)">
            <summary>
            Registers handler location. The Resolver must be not started yet. This method is NOT thread safe
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.QueryResolver.UnregisterHandlerLocation(System.String)">
            <summary>
            Unregisters handler location returning true if it was found and removed. The Resolve must be not started yet. This method is NOT thread safe
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.QueryResolver.ScriptAssembly">
            <summary>
            Gets sets name of assembly that query scripts resolve from
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.QuerySource">
             <summary>
             Represents query source code with pre-processed pragmas
             </summary>
             <example>
            #pragma
            modify=tbl_patient
            key=counter,ssn
            ignore=doctor_phone,doctor_id
            load=
            store=
            @last_name=lname
            @first_name=fname
            .doctor_id=This is description for column
            
            select
             t1.ssn,
             t1.lname as last_name,
             t1.fname as first_name,
             t1.c_doctor,
             t2.phone as doctor_phone,
             t2.NPI	as doctor_id
            from
             tbl_patient t1
              left outer join tbl_doctor t2 on t1.c_doctor = t2.counter
            where
             t1.lname like ?LN
             </example>
        </member>
        <member name="P:NFX.DataAccess.CRUD.QuerySource.Name">
            <summary>
            Rerurns name of query source
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.QuerySource.OriginalSource">
            <summary>
            Returns original source of query including pragma text (if any)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.QuerySource.StatementSource">
            <summary>
            Returns source of query excluding pragma text (if any was present in the original)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.QuerySource.HasPragma">
            <summary>
            Returns true when #pragma was defined in source
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.QuerySource.ReadOnly">
            <summary>
            Returns true when pragma does not specify any modification target (table name to insert/update/delete against)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.QuerySource.ModifyTarget">
            <summary>
            Returns modification target (table name to insert/update/delete against) if query is not read-only
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.QuerySource.ColumnDefs">
            <summary>
            Returns column definitions defined by #pragma
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.QuerySource.ColumnDef">
            <summary>
            Provides column definition in QuerySource
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.RowChangeType">
            <summary>
            Describes what kind of modification was done
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.RowChange">
            <summary>
            Describes row modification
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.RowsetBase">
            <summary>
            Provides base for rowset implementation.
            Rowsets are mutable lists of rows where all rows must have the same schema, however a rowset may contain a mix of
             dynamic and typed rows as long as they have the same schema.
            Rowsets are not thread-safe
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.FromJSON(System.String,System.Boolean,System.Boolean)">
            <summary>
            Reads either Table or Rowset from JSON created by WriteAsJSON. Metadata must be present
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.FromJSON(NFX.Serialization.JSON.JSONDataMap,System.Boolean,System.Boolean)">
            <summary>
            Reads either Table or Rowset from JSON created by WriteAsJSON. Metadata must be present
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.FromJSON(NFX.Serialization.JSON.JSONDataMap,System.Boolean@,System.Boolean,System.Boolean,NFX.DataAccess.CRUD.SetFieldFunc)">
            <summary>
            Reads either Table or Rowset from JSON created by WriteAsJSON. Metadata must be present.
            allMatched==false when some data did not match schema (i.e. too little fields or extra fields supplied)
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.FromJSON``1(System.String,NFX.DataAccess.CRUD.RowsetBase@,NFX.DataAccess.CRUD.SetFieldFunc)">
            <summary>
            Reads either Table or Rowset from JSON created by WriteAsJSON.
            </summary>
            <returns>Total number of rows found in JSON. If this number is less than
            result.Count, then not all rows matched the schema of the resulting rowset.</returns>
            <remarks>
            The schema of "result" must match the schema of the typed row T.
            It's the responsibility of the caller to clear the "result" prior to
            calling this function - the function appends rows to existing rowset.
            </remarks>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.FromJSON``1(NFX.Serialization.JSON.JSONDataMap,NFX.DataAccess.CRUD.RowsetBase@,NFX.DataAccess.CRUD.SetFieldFunc)">
            <summary>
            Reads either Table or Rowset from JSON created by WriteAsJSON.
            </summary>
            <returns>Total number of rows found in JSON. If this number is less than
            result.Count, then not all rows matched the schema of the resulting rowset.</returns>
            <remarks>
            The schema of "result" must match the schema of the typed row T.
            It's the responsibility of the caller to clear the "result" prior to
            calling this function - the function appends rows to existing rowset.
            </remarks>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.#ctor(NFX.DataAccess.CRUD.Schema)">
            <summary>
            Creates an empty rowset
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Insert(NFX.DataAccess.CRUD.Row)">
            <summary>
            Inserts the row. Returns insertion index
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Update(NFX.DataAccess.CRUD.Row,NFX.DataAccess.IDataStoreKey)">
            <summary>
            Updates the row, Returns the row index or -1
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Upsert(NFX.DataAccess.CRUD.Row,System.Func{NFX.DataAccess.CRUD.Row,System.Boolean})">
            <summary>
            Tries to find a row for update and if found, updates it and returns true,
             otherwise inserts the row (if schemas match) and returns false. Optionally pass updateWhere condition
              that may check whether update needs to be performed
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Delete(NFX.DataAccess.CRUD.Row,NFX.DataAccess.IDataStoreKey)">
            <summary>
            Tries to find a row with the same set of key fields in this table and if found, deletes it and returns its index, otherwise -1
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Delete(System.Object[])">
            <summary>
            Tries to find a row with the same set of key fields in this table and if found, deletes it and returns its index, otherwise -1
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Purge">
            <summary>
            Deletes all rows from table without logging the deleted modifications even when LogModifications=true
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.DeleteAll">
            <summary>
            Deletes all rows from table. This method is similar to Purge() but does logging (when enabled)
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.PurgeChanges">
            <summary>
            Clears modifications accumulated by this instance
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.KeyRowFromValues(System.Object[])">
            <summary>
            Creates key row out of field values for keys
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.FindByKey(NFX.DataAccess.CRUD.Row)">
            <summary>
            Tries to find a row by specified keyset and returns it or null if not found
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.FindByKey(System.Object[])">
            <summary>
            Tries to find a row by specified keyset and returns it or null if not found.
            This method does not perform well on Rowsets instances as a rowset is unordered list which does linear search.
            In contrast, Tables are always ordered and perform binary search instead
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.FindByKey(NFX.DataAccess.CRUD.Row,System.Func{NFX.DataAccess.CRUD.Row,System.Boolean})">
            <summary>
            Tries to find a row by specified keyset and extra WHERE clause and returns it or null if not found.
            This method does not perform well on Rowsets instances as a rowset is unordered list which does linear search.
            In contrast, Tables are always ordered and perform binary search instead
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.FindByKey(System.Func{NFX.DataAccess.CRUD.Row,System.Boolean},System.Object[])">
            <summary>
            Tries to find a row by specified keyset and extra WHERE clause and returns it or null if not found
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.GetChangeAt(System.Int32)">
            <summary>
            Retrievs a change by index or null if index is out of bounds or changes are not logged
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Validate(System.String)">
            <summary>
            Validates all rows in this rowset.
            Override to perform custom validations.
            The method is not expected to throw exception in case of failed validation, rather return exception instance because
             throwing exception really hampers validation performance when many rows need to be validated
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Compare(NFX.DataAccess.CRUD.Row,NFX.DataAccess.CRUD.Row)">
            <summary>
            Compares two rows
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Insert(System.Int32,NFX.DataAccess.CRUD.Row)">
            <summary>
            Inserts row at index
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.RemoveAt(System.Int32)">
            <summary>
            Deletes row
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Add(NFX.DataAccess.CRUD.Row)">
            <summary>
            Inserts a row
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Clear">
            <summary>
            Purges table
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Remove(NFX.DataAccess.CRUD.Row)">
            <summary>
            Performs row delete
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.WriteAsJSON(System.IO.TextWriter,System.Int32,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Writes rowset as JSON including schema information. Do not call this method directly, instead call rowset.ToJSON() or use JSONWriter class
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.Check(NFX.DataAccess.CRUD.Row)">
            <summary>
            Checks argument for being non-null and of the same schema with this rowset
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.SearchForRow(NFX.DataAccess.CRUD.Row,System.Int32@)">
            <summary>
            Provides rowsearching. Override to do binary search in sorted rowsets
            </summary>
            <param name="row">A row to search for</param>
            <param name="index">An index where search collapsed without finding the match. Used for sorted insertions</param>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.DoInsert(NFX.DataAccess.CRUD.Row)">
            <summary>
            Tries to insert a row. If another row with the same set of key fields already in the table returns -1, otherwise
             returns insertion index
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.DoUpdate(NFX.DataAccess.CRUD.Row,NFX.DataAccess.IDataStoreKey)">
            <summary>
            Tries to find a row with the same set of key fields in this table and if found, replaces it and returns its index,
             otherwise returns -1
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.DoUpsert(NFX.DataAccess.CRUD.Row,System.Func{NFX.DataAccess.CRUD.Row,System.Boolean})">
            <summary>
            Tries to find a row with the same set of key fields in this table and if found, replaces it and returns true,
             otherwise inserts the row (if schemas match) and returns false. Optionally pass updateWhere condition
              that may check whether update needs to be performed
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.RowsetBase.DoDelete(NFX.DataAccess.CRUD.Row,NFX.DataAccess.IDataStoreKey)">
            <summary>
            Tries to find a row with the same set of key fields in this table and if found, deletes it and returns its index, otherwise -1
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.RowsetBase.InstanceGUID">
            <summary>
            Returns globaly-unique instance ID.
            This ID is useful as a key for storing rowsets in object stores and posting data back from web client to server.
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.RowsetBase.Schema">
            <summary>
            Returns a schema for rows that this rowset contains
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.RowsetBase.Count">
            <summary>
            Returns row count in this rowset
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.RowsetBase.AsReadonlyIList">
            <summary>
            Returns data as non-generic readonly IList
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.RowsetBase.LogChanges">
            <summary>
            Gets/Sets whether this rowset keeps track of all modifications done to it.
            This property must be set to true to be able to save changes into ICRUDDataStore
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.RowsetBase.Changes">
            <summary>
            Returns accumulated modifications performed on the rowset, or empty enumerator if no modifications have been made or
             LogModifications = false
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.RowsetBase.ChangeCount">
            <summary>
            Returns a count of accumulated modifications performed on the rowset, or zero when no modifications have been made or
             LogModifications = false
             </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.RowsetBase.ContextMap">
            <summary>
            Provides dynamic view as JSONDataMap of rowset's data context - attributes applicable to the whole rowset
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.RowsetBase.Context">
            <summary>
            Provides dynamic view of rowset's data context - attributes applicable to the whole rowset
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.RowsetBase.Item(System.Int32)">
            <summary>
            This method performs update on set
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.TransactionDisposeBehavior">
            <summary>
            Specifies how transaction scope behaves on scope exit
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.TransactionStatus">
            <summary>
            Denotes transaction statuses
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.CRUDTransaction">
            <summary>
            Represents an abstract base for CRUDTransactions that perform particular backend CRUD work in overriden classes
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.CRUDTransaction.DataStore">
            <summary>
            References the store instance that started this transaction
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.CRUDTransaction.Status">
            <summary>
            Returns current transaction status
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.CRUDTransaction.DisposeBehavior">
            <summary>
            Specifies how transaction should be finalized on dispose: comitted or rolledback if it is still open
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.CRUDTransaction.SupportsTrueAsynchrony">
            <summary>
            Returns true when backend supports true asynchronous operations, such as the ones that do not create extra threads/empty tasks
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.CRUDDataStoreType">
            <summary>
            Denotes types of CRUD stores
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.FieldFilterFunc">
            <summary>
            Provides filter predicate for CRUD operations. Return true to include the specified field
            </summary>
            <param name="row">Row instance that filetring is performed on</param>
            <param name="key">If not null, the override key passed to Update() (if any)</param>
            <param name="fdef">A field that filtering is done for</param>
        </member>
        <member name="T:NFX.DataAccess.CRUD.ICRUDQueryExecutionContext">
            <summary>
            Represents a context (such as Sql Server connection + transaction scope, or Hadoop connect string etc.) for query execution.
            This is a marker interface implemented by particular providers
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Query">
            <summary>
            Defines a query sent into ICRUDDataStore implementor to retrieve data.
            A Query is a named bag of paremeters where every parameter has a name and the value.
            </summary>
            <remarks>
             Keep in mind that a particular datastore implementation may have to deal with hybrid distributed backends where different tables get stored
             in different repositories (different architectures i.e. NoSQL, HDFS, and some RDB SQL all in different locations),
             consequently one can not make assumption about writing SQLs of any kind in business code - that is what CRUD concept is for as it abstracts
             this into provider implementation.
             Architectural note: unlike Hibernate, LinqTo* and the like, the NFX.CRUD architecture purposely does not allow developers
             to write query scripts in higher-language like C#. This is because translation of such a high-level language abstraction into
              highly optimized SQL/(and or other script) per particular backend is impossible because such language can not incapsulate
             the optimization features of all possible data backends (i.e. ORACLE vs MongoDB vs Redis vs Files in HDFS).
            CRUD queries need to support selects from tables with millions of rows, or reads from collections with millions of documents,
            or parse millions of lines from files stored in Hadooop servers, thus every particular provider for every particular business app
            must expose custom-written queries by name. Those queries are usually highly optimized for particular platform
            (i.e. using db-specific hints, common table subexpressions, groupping sets etc.).
            Also, a provider may elect to SELECT * from a table named like Query object, when a hand-written script with such name is not found
            </remarks>
        </member>
        <member name="T:NFX.IParameters">
            <summary>
            Represents abstract parameters bag
            </summary>
        </member>
        <member name="M:NFX.IParameters.ParamByName(System.String)">
            <summary>
            Returns a parameter found by name or throws exception if it could not be found
            </summary>
        </member>
        <member name="M:NFX.IParameters.FindParamByName(System.String)">
            <summary>
            Tries to find parameter by name and returns null if parameter could not be found
            </summary>
        </member>
        <member name="P:NFX.IParameters.AllParameters">
            <summary>
            Enumerates all parameters
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Query.Identity">
            <summary>
            Returns the identity of this instance, that is - an ID that UNIQUELY identifies the instance of this query
            including all of the names, parameters, values. This is needed for Equality comparison and cache lookup.
            The identity is either generated by .ctor or supplied to it if it is cached (i.e. in a user session)
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Query.Name">
            <summary>
            Returns Query name, providers use it to locate SQL/scripts particular to backend implementation that they represent.
            QueryResolver resolves query by its name into ICRUDQueryHandler. Name is case-insensitive
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Query.StoreKey">
            <summary>
            Returns the key if one was passed in .ctor when key is set the parameters are ignored
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Query.ResultRowType">
            <summary>
            Returns a type of result row requested in .ctor which is always a TypedRow derivative type, or null
             if no particular type was requested
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Query.Extra">
            <summary>
            Returns extra parameters that provider may need to render the query. May be null
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Query.Item(System.String)">
            <summary>
            Returns parameter by its name or null
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Query.ReadCacheMaxAgeSec">
            <summary>
            If greater than 0 then would allow reading a cached result for up-to the specified number of seconds.
            If =0 uses cache's default span.
            Less than 0 does not try to read from cache
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Query.WriteCacheMaxAgeSec">
            <summary>
            If greater than 0 then writes to cache with the expiration.
            If =0 uses cache's default life span.
            Less than 0 does not write to cache
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Query.WriteCachePriority">
            <summary>
            Relative cache priority which is used when WriteCacheMaxAgeSec>=0
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Query.CacheAbsentData">
            <summary>
            When true would cache the instance of AbsentData to signify the absence of data in the backend for key
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Query.Param">
            <summary>
            Represents a CRUD query parameter
            </summary>
        </member>
        <member name="T:NFX.IParameter">
            <summary>
            Represents abstract parameter
            </summary>
        </member>
        <member name="P:NFX.IParameter.Value">
            <summary>
            Parameter Value
            </summary>
        </member>
        <member name="P:NFX.IParameter.HasValue">
            <summary>
            Indicates whether parameter has a value, even if Value==null parameter may or
             may not have a value (be assigned) in some scenarious
            </summary>
        </member>
        <member name="P:NFX.IParameter.IsInput">
            <summary>
            Indicates whether parameter is purposed as an input for a target
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Query`1">
            <summary>
            Generic version of Query
            </summary>
            <typeparam name="TResultRow">Type of resulting rows</typeparam>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Rowset">
            <summary>
            Implements a rowset that supports row change logging and CRUD operations.
            Rowsets are not optimal for data replication as they perform linear search which is slow, however
            Rowset class supports sorting. In contrast, Tables are kind of rowsets that keep data pre-sorted by key
            thus facilitating quick searching
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Rowset.#ctor(NFX.DataAccess.CRUD.Schema)">
            <summary>
            Creates an empty rowset
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Rowset.#ctor(NFX.DataAccess.CRUD.RowsetBase,System.Func{NFX.DataAccess.CRUD.Row,System.Boolean})">
            <summary>
            Creates a shallow copy from another rowset, optionally applying a filter
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Rowset.SortDefinition">
            <summary>
            Sort definition is a comma-separated field name list where every field may optionally be prefixed with
            `+` for ascending or `-` for descending sort order specifier. Example: "FirstName,-DOB"
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.TargetedAttribute">
            <summary>
            Provides a base for attributes which ar targeted for particular techlology (i.e. "ORACLE")
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.TargetedAttribute.TargetName">
            <summary>
            Returns the name of target, i.e. the name of database engine i.e. "ORACLE11g" or "MySQL"
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.TargetedAttribute.ParseMetadataContent(System.String)">
            <summary>
            Parses content with or without root node
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.TargetedAttribute.MetadataContent">
            <summary>
            Returns metadata content string in Laconic format or null. Root not is not specified. I.e.: 'a=1 b=true c{...}'
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.TargetedAttribute.Metadata">
            <summary>
            Returns structured metadata or null if there is no metadata defined
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.TableAttribute">
            <summary>
            Provides information about table schema that this row is a part of
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.TableAttribute.Name">
            <summary>
            Returns the name of schema that decorated class represents, i.e. the name of database table i.e. "TBL_PERSON".
            This value is set so datastore implementation can use it instead of inferring table name from declaring class name
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.TableAttribute.Immutable">
            <summary>
            Indicates whether the data represented by the decorated instance can only be created (and possibly deleted) but can not change(no update).
            This attribute allows some backends to perform some optimizations (such as better failover data handling and caching) as any version of the data
            that could be found is valid and the latest
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.DataKind">
            <summary>
            Provides hint/classification for field textual data
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.FieldAttribute">
            <summary>
            Provides information about table schema that this typed row is a part of
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.FieldAttribute.#ctor(NFX.Serialization.JSON.JSONDataMap,System.String,NFX.DataAccess.StoreFlag,System.Boolean,NFX.DataAccess.CRUD.DataKind,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Int32,System.Int32,NFX.DataAccess.CharCase,System.String,System.String,System.String,System.String,System.Boolean,System.String,System.String,System.String)">
            <summary>
            Used for injection of pre-parsed value list
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.CloneFromRowType">
            <summary>
            When set, points to a Typed-Row derivative that is used as a full clone
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.StoreFlag">
            <summary>
            Determines whether field should be loaded/stored from/to storage
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.BackendName">
            <summary>
            Provides an overriden name for this field
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.BackendType">
            <summary>
            Provides an overriden type for this field in backend,
            i.e. CLR string may be stored as ErlPid in erlang
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.Key">
            <summary>
            Determines whether this field is a part of the primary key
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.Kind">
            <summary>
            Provides hint/classification for textual field data
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.Required">
            <summary>
            Determines whether the field must have data
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.Visible">
            <summary>
            Determines whether the field is shown to user (i.e. as a grid column)
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.ValueList">
            <summary>
            Returns a ";/,/|"-delimited list of permitted field values - used for lookup validation
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.FieldAttribute.ParseValueList(System.Boolean)">
            <summary>
            Returns a ValueList parsed into key values as:  val1: descr1,val2: desc2...
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.FieldAttribute.ParseValueListString(System.String,System.Boolean)">
            <summary>
            Returns a string parsed into key values as:  val1: descr1,val2: desc2...
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.Min">
            <summary>
            Provides low-bound validation check
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.Max">
            <summary>
            Provides high-bound validation check
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.Default">
            <summary>
            Provides default value
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.MinLength">
            <summary>
            Imposes a limit on minimum amount of characters in a textual field
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.MaxLength">
            <summary>
            Imposes a limit on maximum amount of characters in a textual field
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.CharCase">
            <summary>
            Controls character casing of textual fields
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.FormatRegExp">
            <summary>
            Regular expression used for field format validation if set
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.FormatDescription">
            <summary>
            Description for regular expression used for field format validation if set
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.DisplayFormat">
            <summary>
            Display format string or null
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.Description">
            <summary>
            Provides description
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.NonUI">
            <summary>
            If true indicates that this field is ignored when generating UI and ignored when UI supplies the value to the server.
            Pass true to protect server-only structures from being modified by client
            </summary>
        </member>
        <member name="F:NFX.DataAccess.CRUD.FieldAttribute.IsArow">
            <summary>
            True if this field definition is used by Arow serializer
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.FieldAttribute.HasValueList">
            <summary>
            Returns true if the value list is set or internal JSONDataMap is set
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.UniqueSequenceAttribute">
            <summary>
            Provides information for unique sequence gen: scope and name
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.UniqueSequenceAttribute.GetForRowType(System.Type)">
            <summary>
            Returns UniqueSequenceAttribute or null for row type
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.DynamicRow">
            <summary>
            Represents a row of data which has a schema only known at run-time.
            Dynamic rows store data in object[] internally, providing better flexibility(ability to define schema at runtime) than TypedRows at the expense of performance.
            This class is not sealed so implementors may override configuration persistence
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.DynamicRow.__ctor(NFX.DataAccess.CRUD.Schema)">
            <summary>
            Developers do not call, lazily injects the statr of this object,
            this is needed for speed and other optimizations
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.DynamicRow.Schema">
            <summary>
            References a schema for a table that this row is a part of
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.DynamicRow.Data">
            <summary>
            Provides access to raw array of values that this row contains
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.AmorphousDynamicRow">
            <summary>
            Represents a row of data which has a schema only known at run-time that also implements IAmorphousData
            interface that allows this row to store "extra" data that does not comply with the current schema.
            Dynamic rows store data in object[] internally, providing better flexibility(ability to define schema at runtime) than TypedRows at the expense of performance.
            This class is not sealed so implementors may override configuration persistence
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.AmorphousDynamicRow.BeforeSave(System.String)">
            <summary>
            Invoked to allow the row to transform its state into AmorphousData bag.
            For example, this may be usefull to store extra data that is not a part of established business schema.
            The operation is performed per particular targetName (name of physical backend). Simply put, this method allows
             business code to "specify what to do before object gets saved in THE PARTICULAR TARGET backend store"
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.AmorphousDynamicRow.AfterLoad(System.String)">
            <summary>
            Invoked to allow the row to hydrate its fields/state from AmorphousData bag.
            For example, this may be used to reconstruct some temporary object state that is not stored as a part of established business schema.
            The operation is performed per particular targetName (name of physical backend).
            Simply put, this method allows business code to "specify what to do after object gets loaded from THE PARTICULAR TARGET backend store".
            An example: suppose current MongoDB collection stores 3 fields for name, and we want to collapse First/Last/Middle name fields into one field.
            If we change rowschema then it will only contain 1 field which is not present in the database, however those 'older' fields will get populated
            into AmorphousData giving us an option to merge older 3 fields into 1 within AfterLoad() implementation
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.AmorphousDynamicRow.AmorphousDataEnabled">
            <summary>
            True by default for rows
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.AmorphousDynamicRow.AmorphousData">
            <summary>
            Returns data that does not comply with known schema (dynamic data). The field names are NOT case-sensitive
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.CRUDValidationException">
            <summary>
            Thrown by CRUD data access classes when validation does not pass
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.CRUDRowValidationException">
            <summary>
            Thrown by CRUD data access classes when field validation does not pass
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.CRUDFieldValidationException">
            <summary>
            Thrown by CRUD data access classes when field validation does not pass
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.SetFieldFunc">
            <summary>
            Injects function that tries to set field value. May elect to skip the set and return false to indicate failure(instead of throwing exception)
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Schema">
            <summary>
            Describes a schema for rows: TypedRows and DynamicRows.
            DynamicRows are "shaped" in memory from schema, whereas, TypedRows define schema.
            Schema for Typedrows is cached in static dictionary for speed
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.GetFieldMembers(System.Type)">
            <summary>
            Gets all property members of TypedRow that are tagged as [Field]
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.GetForTypedRow(NFX.DataAccess.CRUD.TypedRow)">
            <summary>
            Returns schema instance for the TypedRow instance by fetching schema object from cache or
             creating it if it has not been cached yet
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.GetForTypedRow``1">
            <summary>
            Returns schema instance for the TypedRow instance by fetching schema object from cache or
             creating it if it has not been cached yet
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.GetForTypedRow(System.Type)">
            <summary>
            Returns schema instance for the TypedRow instance by fetching schema object from cache or
             creating it if it has not been cached yet
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.GetFieldDefByIndex(System.Int32)">
            <summary>
            Finds fielddef by name or throws if name is not found
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.GetFieldDefByName(System.String)">
            <summary>
            Finds fielddef by name or throws if name is not found
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.GetFieldDefByBackendName(System.String,System.String,System.Func{NFX.DataAccess.CRUD.Schema.FieldDef,NFX.DataAccess.CRUD.FieldAttribute,System.Boolean})">
            <summary>
            Returns FieldDef by BackendName for TargetName
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.GetKeyFieldDefsForTarget(System.String)">
            <summary>
            Returns FieldDefs in their order within rows that are declared as key fields for particular target
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.TryFindFieldByTargetedBackendName(System.String,System.String,System.StringComparison)">
            <summary>
            Returns a field def that matches the desired backed name for the specified target or null
            </summary>
            <param name="targetName">Target or null, if null any target assumed</param>
            <param name="backendName">The name of the backend</param>
            <param name="backendNameComparison">The string comparison to use against the backend name, OrdinalIgnoreCase is dflt</param>
            <returns>The desired field or null</returns>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.GetTableAttrForTarget(System.String)">
            <summary>
            Returns a TableAttribute that matches the supplied targetName, or if one was not defined then
             returns TableAttribute which matches any target or null
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.IsEquivalentTo(NFX.DataAccess.CRUD.Schema,System.Boolean)">
            <summary>
            Performs logical equivalence testing of two schemas
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.WriteAsJSON(System.IO.TextWriter,System.Int32,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Writes schema as JSON. Do not call this method directly, instead call rowset.ToJSON() or use JSONWriter class
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.Name">
            <summary>
            For TypedRows, returns a unique fully-qualified row type name, whichs is the global identifier of this schema instance
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.ReadOnly">
            <summary>
            Specifies that target that this schema represents (i.e. db table) is not updatable so DataStore will not be able to save row changes made in ram
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.TypedRowType">
            <summary>
            Returns a type of TypedRow if schema was created for TypedRow, or null
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.TableAttrs">
            <summary>
            Returns table-level attributes
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDefs">
            <summary>
            Returns FieldDefs in their order within rows that this schema describes
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.AnyTargetKeyFieldDefs">
            <summary>
            Returns FieldDefs in their order within rows that are declared as key fields in ANY_TARGET
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.AnyVisibleFieldDefs">
            <summary>
            Returns FieldDefs in their order within rows as
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.Item(System.String)">
            <summary>
            Returns a field definition by a unique case-insensitive field name within schema
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.Item(System.Int32)">
            <summary>
            Returns a field definition by a positional index within the row
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldCount">
            <summary>
            Returns field count
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.ExtraData">
            <summary>
            Returns Extra data that may be associated with schema by various providers.
            The field is lazily allocated
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.SchemaEquivalenceEqualityComparer">
            <summary>
            Returns an instance of IEqualityComparer(Schema) that performs logical equivalence testing
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Schema.FieldDef">
            <summary>
            Provides a definition for a single field of a row
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.FieldDef.ValueDescription(System.Object,System.String,System.Boolean)">
            <summary>
            For fields with ValueList returns value's description per specified schema
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.FieldDef.GetBackendNameForTarget(System.String)">
            <summary>
            Returns the name of the field in backend that was possibly overriden for a particular target
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.FieldDef.GetBackendNameForTarget(System.String,NFX.DataAccess.CRUD.FieldAttribute@)">
            <summary>
            Returns the name of the field in backend that was possibly overriden for a particular target
            along with store flag
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Schema.FieldDef.WriteAsJSON(System.IO.TextWriter,System.Int32,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Writes fielddef as JSON. Do not call this method directly, instead call rowset.ToJSON() or use JSONWriter class
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.Name">
            <summary>
            Returns the name of the field
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.Type">
            <summary>
            Returns the field type
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.NonNullableType">
            <summary>
            For nullable value types returns the field type regardless of nullability, it is the type argument of Nullable struct;
            For reference types returns the same type as Type property
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.Attrs">
            <summary>
            Returns field attributes
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.Order">
            <summary>
            Gets absolute field order index in a row
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.MemberInfo">
            <summary>
            For TypedRow-descendants returns a PropertyInfo object for the underlying property
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.AnyTargetKey">
            <summary>
            Returns true when this field is attributed as being a key field in an attribute that targets ANY_TARGET
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.AnyVisible">
            <summary>
            Returns true when this field is attributed as being a visible in any of the targeted attribute
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.Description">
            <summary>
            Returns description from field attribute or parses it from field name
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.NonUI">
            <summary>
            Returns true when at least one attribute was marked as NonUI - meaning that this field must not be serialized-to/deserialized-from client UI
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Schema.FieldDef.Item(System.String)">
            <summary>
            Returns a FieldAttribute that matches the supplied targetName, or if one was not defined then
             returns FieldAttribute which matches any target or null
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CRUD.Table">
            <summary>
            Implements a master table. Tables are rowsets that are pre-sorted by keys.
            They are used in scenarios when in-memory data replication is needed.
            A table supports efficient FindKey() operation but does not support sorting.
            This class is not thread-safe.
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Table.#ctor(NFX.DataAccess.CRUD.Schema)">
            <summary>
            Creates an empty table
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Table.#ctor(NFX.DataAccess.CRUD.Table,System.Func{NFX.DataAccess.CRUD.Row,System.Boolean})">
            <summary>
            Creates a shallow copy from another table, optionally applying a filter
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Table.#ctor(NFX.DataAccess.CRUD.Rowset,System.Func{NFX.DataAccess.CRUD.Row,System.Boolean})">
            <summary>
            Creates a shallow copy from another rowset resorting data per schema key definition, optionally applying a filter
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Table.SearchForRow(NFX.DataAccess.CRUD.Row,System.Int32@)">
            <summary>
            Performs binary search on a sorted table
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Table.Compare(NFX.DataAccess.CRUD.Row,NFX.DataAccess.CRUD.Row)">
            <summary>
            Compares two rows based on their key fields. Always compares in ascending direction
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Table.CompareRows(NFX.DataAccess.CRUD.Schema,NFX.DataAccess.CRUD.Row,NFX.DataAccess.CRUD.Row)">
            <summary>
            Compares two rows based on their key fields. Always compares in ascending direction
            </summary>
        </member>
        <member name="M:NFX.DataAccess.CRUD.Table.Insert(System.Int32,NFX.DataAccess.CRUD.Row)">
            <summary>
            This is IList member implementation, index is ignored
            </summary>
        </member>
        <member name="P:NFX.DataAccess.CRUD.Table.Item(System.Int32)">
            <summary>
            This method does not support setting rows in table
            </summary>
        </member>
        <member name="T:NFX.OS.OSFamily">
            <summary>
            Denots primary OS Families: Win/Mac/Lin*nix
            </summary>
        </member>
        <member name="T:NFX.OS.MemoryStatus">
            <summary>
            Provides current memory status snapshot
            </summary>
        </member>
        <member name="T:NFX.OS.Computer">
            <summary>
            Facilitates various computer-related tasks such as CPU usage, memory utilization etc.
            </summary>
        </member>
        <member name="P:NFX.OS.Computer.CurrentProcessorUsagePct">
            <summary>
            Returns current computer-wide CPU utilization percentage
            </summary>
        </member>
        <member name="P:NFX.OS.Computer.CurrentAvailableMemoryMb">
            <summary>
            Returns current computer-wide RAM availability in mbytes
            </summary>
        </member>
        <member name="P:NFX.OS.Computer.OSFamily">
            <summary>
            Rsturns OS family for this computer: Linux vs Win vs Mac
            </summary>
        </member>
        <member name="P:NFX.OS.Computer.UniqueNetworkSignature">
            <summary>
            Returns network signature for this machine which is unique in the eclosing network segment (MAC-based)
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.ICPUInstrument">
            <summary>
            CPU-related operations
            </summary>
        </member>
        <member name="T:NFX.OS.ManyReadersOneWriterSynchronizer">
            <summary>
            This struct is for ADVANCED SYSTEM use-cases. DEVELOPERS: do not use this in a business application code.
            Represents an efficient SpinWait/Yield-based lock that allows many readers to operate concurrently
             and only one single concurrent writer. This struct must be used ONLY with a very fast/tight operations that
             do not block on IO and other locks, and are expected to complete under a tenth fraction of a second.
            Warning: this lock CAN NOT be held for longer than 5 hrs by design. DO NOT use this lock with IO-dependent operations.
            This is not really a limitation as this class is used to guard operations which are very fast (fractions of a second) and
            should fail faster otherwise.
            This lock IS NOT REENTRANT!
            </summary>
        </member>
        <member name="M:NFX.OS.ManyReadersOneWriterSynchronizer.GetReadLock(System.Func{System.Object,System.Boolean},System.Object)">
            <summary>
            Obtains a read lock returning true on success.
            Many threads may obtain a read lock at the same time, however a single write lock excludes any read locks,
            corollary any single read lock held excludes anyone obtaining a write lock.
            False is returned if cancel func was supplied and returned true to cancel-out the waiting
            </summary>
        </member>
        <member name="M:NFX.OS.ManyReadersOneWriterSynchronizer.ReleaseReadLock">
            <summary>
            Releases the read lock that was previously obtained by a call to GetReadLock()
            </summary>
        </member>
        <member name="M:NFX.OS.ManyReadersOneWriterSynchronizer.TryGetWriteLock">
            <summary>
            Tries to obtain the write lock returning true on success, false if lock could not be taken -
            either someone reads or writes. Only one thread may hold a write lock at a time
            </summary>
        </member>
        <member name="M:NFX.OS.ManyReadersOneWriterSynchronizer.GetWriteLock(System.Func{System.Object,System.Boolean},System.Object)">
            <summary>
            Obtains a write lock returning true on success. Only one thread may hold a write lock at a time,
            and noone else can obtain a read lock until the write lock is released.
            False is returned if cancel func was supplied and returned true to cancel-out the waiting
            </summary>
        </member>
        <member name="M:NFX.OS.ManyReadersOneWriterSynchronizer.ReleaseWriteLock">
            <summary>
            Releases the write lock that was previously obtained by a call to GetWriteLock()
            </summary>
        </member>
        <member name="T:NFX.OS.NetworkUtils">
            <summary>
            Provides network-related utilities
            </summary>
        </member>
        <member name="M:NFX.OS.NetworkUtils.GetMachineUniqueMACSignature">
            <summary>
            Gets a string which represents a unique signature of this machine based on MAC addresses of interfaces.
            The signature has a form of: [intf.count]-[CRC32 of all MACs]-[convoluted MD5 of all MACs]
            </summary>
        </member>
        <member name="T:NFX.OS.HostNetInfo">
            <summary>
            Provides information about IP network host
            </summary>
        </member>
        <member name="P:NFX.OS.HostNetInfo.Name">
            <summary>
            Full host name including domain
            </summary>
        </member>
        <member name="P:NFX.OS.HostNetInfo.HostNameSegment">
            <summary>
            Host name segment of Name
            </summary>
        </member>
        <member name="P:NFX.OS.HostNetInfo.DomainNameSegment">
            <summary>
            Domain name segment of Name
            </summary>
        </member>
        <member name="P:NFX.OS.HostNetInfo.Adapters">
            <summary>
            Network adapters on the host
            </summary>
        </member>
        <member name="T:NFX.OS.HostNetInfo.NetAddrInfo">
            <summary>
            Describes an address supported by net adapter
            </summary>
        </member>
        <member name="T:NFX.OS.HostNetInfo.NetAdapterInfo">
            <summary>
            Describes a network adapter on subordinate host
            </summary>
        </member>
        <member name="T:NFX.Security.HashedPassword">
            <summary>
            Represents abstraction of a hashed password, the concreate password algorithm provide implementation (i.e. bytebuffer, dictionary, string)
            </summary>
        </member>
        <member name="T:NFX.Security.PasswordStrengthLevel">
            <summary>
            Defines password stregth levels: Minimum, Normal, Maximum etc.
            </summary>
        </member>
        <member name="T:NFX.Security.PasswordFamily">
            <summary>
            Denoutes kinds of passwords i.e.: text that user types on login, short PIN,
            geometrical curve that users need to trace with their finger, select areas of picture
            </summary>
        </member>
        <member name="T:NFX.Security.IPasswordManager">
            <summary>
            Denotes an entity that manages passwords such as: computes and verified hash tokens
            and provides password strength verification
            </summary>
        </member>
        <member name="T:NFX.Security.PasswordHashingAlgorithm">
            <summary>
            Represents an abstraction of password algorithm that performs hashing and verification of passwords supplied as SecureBuffer
            </summary>
        </member>
        <member name="T:NFX.Security.DefaultPasswordManager">
            <summary>
            Provides default implementation for password managment functionality based on injectable algorithms and default password strength calculation
            </summary>
        </member>
        <member name="T:NFX.Security.PasswordRepresentationType">
            <summary>
            Flags denote types of password representation: Text/Image/Audio
            </summary>
        </member>
        <member name="T:NFX.Security.PasswordRepresentation">
            <summary>
            Provides password representation content, i.e. an image with drawn password which is understandable by humans
            </summary>
        </member>
        <member name="T:NFX.Serialization.Arow.ArowAttribute">
            <summary>
            Denotes types that generate Arow ser/deser core
            </summary>
        </member>
        <member name="T:NFX.Serialization.Arow.ITypeSerializationCore">
            <summary>
            Designates classes that register their single instance via a call to ArowSerializer.Register().
            These classes are generated by cl arow compiler
            </summary>
        </member>
        <member name="T:NFX.Serialization.Arow.ArowSerializer">
            <summary>
            Facade for performing Arow serilalization.
            Arow format is purposely designed for "[a]daptable [row]"/version tolerant serialization that eschews creating extra copies and
            object instances. The serializer is used in conjunction with cl compiler that generates type-specific static serializer cores
            for every type that supports the format
            </summary>
        </member>
        <member name="M:NFX.Serialization.Arow.ArowSerializer.Register(System.Type,NFX.Serialization.Arow.ITypeSerializationCore)">
            <summary>
            Registers ITypeSerializationCore so it can be used globaly to serialize TypedRows in Arow format
            </summary>
        </member>
        <member name="T:NFX.Serialization.Arow.CodeGenerator">
            <summary>
            Generates code for serilaizer and deserializer
            </summary>
        </member>
        <member name="M:NFX.Serialization.Arow.CodeGenerator.GetName(System.String)">
            <summary>
            Converts backend name of up to 8 ASCII chars in length
            </summary>
        </member>
        <member name="M:NFX.Serialization.Arow.CodeGenerator.GetName(System.UInt64)">
            <summary>
            Converts backend name of up to 8 ASCII chars in length
            </summary>
        </member>
        <member name="T:NFX.Serialization.Arow.CodeGenerator.GeneratedCodeSegregation">
            <summary>
            Defines how generated files should be stored on disk
            </summary>
        </member>
        <member name="T:NFX.Serialization.Arow.Reader">
            <summary>
            Provides low-level Arow format reading
            </summary>
        </member>
        <member name="T:NFX.Serialization.Arow.ArowException">
            <summary>
            Base exception thrown by the Arow serialization format
            </summary>
        </member>
        <member name="T:NFX.Serialization.NFXSerializationException">
            <summary>
            Base exception thrown by the serialization-related classes
            </summary>
        </member>
        <member name="T:NFX.Serialization.Arow.Writer">
            <summary>
            Provides low-level Arow format writing
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONSerializableAttribute">
            <summary>
            Denotes types that support BSON serialization by GUID
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONTypeResolver">
            <summary>
            Resolves types decorated with BSONSerializableAttribute(guid) attribute
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONParentKnownTypes">
            <summary>
            Provides a scope of fake BSOnWritable parent which indicates what types are known
            this way the serilizer does not have to emit the TypeIDFieldName element.
            Used with root serializations i.e. to database, when storing log messages in the table,
            it is not necessary to store Log.Message type ID in every record.
            Pass the instance to serializer.Serialize(parent: instance).
            Pre-allocate known types before calling serializer.Deserialize(result: instance)
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONParentKnownTypes.#ctor(System.Type[])">
            <summary>
            Specifies the types which are knwon to the parent calling scope, consequently the
            TypeIDFieldNamewill not be emitted to doc.
            Use in cases like writing to database table, where all root types are known by design
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONSerializer">
            <summary>
            Provides serialization/deserialization of types that support direct BSON serialization/deserialization -
             implement IBSONSerializable/IBSONDeserializable
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONSerializer.AddTypeIDField(NFX.Serialization.BSON.BSONDocument,NFX.Serialization.BSON.IBSONSerializable,NFX.Serialization.BSON.IBSONSerializable,System.Object,System.Boolean)">
            <summary>
            Adds a field named TypeIDFieldName with the type id of the object instance, force=true to emit the field even if it is a known type.
            Returns true if type id element was added
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONSerializer.Serialize(NFX.Serialization.BSON.IBSONSerializable,NFX.Serialization.BSON.IBSONSerializable)">
            <summary>
            Serializes an instance directly into BSONDocument
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONSerializer.Deserialize(NFX.Serialization.BSON.BSONDocument,NFX.Serialization.BSON.IBSONDeserializable)">
            <summary>
            Deserilizes an instance from BSONDocument.
            If instance is not pre-allocated (result=null) tries to create a type
            decorated with BSONSerializableAttribute(guid)
            </summary>
        </member>
        <member name="P:NFX.Serialization.BSON.BSONSerializer.Flags">
            <summary>
            Defines the purpose/level of detail of serialization
            </summary>
        </member>
        <member name="P:NFX.Serialization.BSON.BSONSerializer.TypeIDFieldName">
            <summary>
            Returns the name of the field which is used to store type ID, by default DEFAULT_TYPE_ID_FIELD/"__t" is assumed
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONSerializationFlags">
            <summary>
            Specifies the purpose of BSON serialization so the level of detail may be dynamically adjusted.
            Depending on this parameter IBSONWritable implementors may include additional details
            that are otherwise not needed
            </summary>
        </member>
        <member name="F:NFX.Serialization.BSON.BSONSerializationFlags.UIOnly">
            <summary>
            UI Only - minimum date only needed for ui
            </summary>
        </member>
        <member name="F:NFX.Serialization.BSON.BSONSerializationFlags.KeepNull">
            <summary>
            Include as much data as possible for remote object reconstruction
            </summary>
        </member>
        <member name="T:NFX.Parsing.NaturalTextGenerator">
            <summary>
            Generates human-readable English text for tests
            </summary>
        </member>
        <member name="M:NFX.Parsing.NaturalTextGenerator.Generate(System.Int32)">
            <summary>
            Generates human-readable English text of up to specified length which is of 10 chars at minimum.
            If zero passed then generates msg of random length
            </summary>
        </member>
        <member name="M:NFX.Parsing.NaturalTextGenerator.GenerateWord(System.Int32,System.Int32)">
            <summary>
            Generates a random English word which is of the specified size. The min size must be of at least 4 chars
            </summary>
        </member>
        <member name="M:NFX.Parsing.NaturalTextGenerator.GenerateFirstName">
            <summary>
            Generates a string that resembles a human first name
            </summary>
        </member>
        <member name="M:NFX.Parsing.NaturalTextGenerator.GenerateLastName">
            <summary>
            Generates a string that resembles a human last name
            </summary>
        </member>
        <member name="M:NFX.Parsing.NaturalTextGenerator.GenerateCityName">
            <summary>
            Generates a string that resembles a city name
            </summary>
        </member>
        <member name="M:NFX.Parsing.NaturalTextGenerator.GenerateUSCityStateZip">
            <summary>
            Generates a string that resembles a city/state/zip in a US address.
            The states/zips are NOT consistent
            </summary>
        </member>
        <member name="M:NFX.Parsing.NaturalTextGenerator.GenerateAddressLine">
            <summary>
            Generates a string that resembles an address line
            </summary>
        </member>
        <member name="M:NFX.Parsing.NaturalTextGenerator.GenerateFullName(System.Boolean)">
            <summary>
            Generates a string that looks like a human name
            </summary>
        </member>
        <member name="M:NFX.Parsing.NaturalTextGenerator.GenerateEMail">
            <summary>
            Generates a string that looks like an email
            </summary>
        </member>
        <member name="T:NFX.FID">
             <summary>
             Represents an ultra-efficient 64 bit in-process-wide unique identifier "Fast Id".
             The ID is going to wrap-around after at least 2 weeks (19 days).
             The ID consists of 3 segments: [timestamp: 24bit][threadseed: 24bit][counter: 16 bit].
             This is needed because:
              a). FID stays unique after process restarts
              b). This design does not use interlock on global seed, but uses thread-static vars which is 10-20 times faster
            
             The timestamp is the number of 100ms intervals elapsed since Jan 1 2015 expressed as a 24 bit unsigned int, which gives 2^24 = 16,777,216 combinations
             which covers 19 days (around 2 weeks) at 100 msec resolution, consequently the ID will generate duplicates after this period.
             This struct is useful for creating unique IDs for protocol/traffic messages that live for a limited time (no more than 2 weeks).
             Caution: This ID does not identify the machine or process, only items within the process, however when a hosting process restarts(i.e. crash or reboot)
             the new IDs will not collide with IDs generated right before the crash for at least 14 days (14 day sliding window).
             In a parallel test on 6 Core i7 3.2 GHz this class generates 405 million IDs/sec, which is 57 times faster than Guid that only generates 7 million IDs/sec
             </summary>
        </member>
        <member name="M:NFX.FID.#ctor(System.UInt64)">
            <summary>
            Creates instance from ULONG value. Use FID.Generate() to create new IDs instead
            </summary>
        </member>
        <member name="F:NFX.FID.ID">
            <summary>
            Returns 64 bit process-wide unique ID which is unique for up to 2 weeks
            </summary>
        </member>
        <member name="M:NFX.FID.Generate">
            <summary>
            Generates new process-wide unique ID which is unique for up to 2 weeks
            </summary>
        </member>
        <member name="M:NFX.FID.ToGuid">
            <summary>
            Converts to Guid by copying ID twice
            </summary>
        </member>
        <member name="T:NFX.SealedString">
            <summary>
            Represents an immutable string data that is stored in an efficient way that relieves the GC pressure.
            The string can not be changed or deleted. Once created it stays as-is until the process is terminated.
            This structure is used to store much dictionary data (100s of millions of strings) in the process without causing GC overload.
            Note: The default .ctor DOES NOT check whether the same string is already present in memory. Use SealedString.Scope to
             store unique strings only (do not store the repetitions).
            This struct is THREAD SAFE and NOT SERIALIZABLE.
            </summary>
        </member>
        <member name="M:NFX.SealedString.#ctor(System.String)">
            <summary>
            Creates a sealed copy of string data. This .ctor DOES NOT check whether this string was already sealed
            </summary>
        </member>
        <member name="P:NFX.SealedString.TotalBytesUsed">
            <summary>
            Returns the total number of bytes used
            </summary>
        </member>
        <member name="P:NFX.SealedString.TotalCount">
            <summary>
            Returns the total count of strings allocated
            </summary>
        </member>
        <member name="P:NFX.SealedString.TotalBytesAllocated">
            <summary>
            Returns the total number of bytes allocated
            </summary>
        </member>
        <member name="P:NFX.SealedString.TotalSegmentCount">
            <summary>
            Total number of segments
            </summary>
        </member>
        <member name="P:NFX.SealedString.Unassigned">
            <summary>
            Returns a SealedString that is IsAssigned==false - a special invalid value
            </summary>
        </member>
        <member name="P:NFX.SealedString.IsAssigned">
            <summary>
            Returns true if this instance represents an assigned valid string (is not equal to Unassigned)
            </summary>
        </member>
        <member name="P:NFX.SealedString.Value">
            <summary>
            Returns the original string copy
            </summary>
        </member>
        <member name="T:NFX.SealedString.Scope">
            <summary>
            Represents a scope of a SealedString creation that tracks the existing strings.
            Use Seal(string) to get an existing string or create a new one.
            Do not persist the instance of Scope for a long time as it accumulates references (string keys) that pressure the GC.
            This class is used in batched that create many sealed strings. Once those strings rae created the scope can be released.
            </summary>
        </member>
        <member name="M:NFX.SealedString.Scope.#ctor">
            <summary>
            Create a Scope with InvariantCultureIgnoreCase comparer
            </summary>
        </member>
        <member name="M:NFX.SealedString.Scope.#ctor(System.StringComparer)">
            <summary>
             Create a Scope with the specified comparer or InvariantCultureIgnoreCase comparer if the supplied one is null
            </summary>
        </member>
        <member name="M:NFX.SealedString.Scope.Contains(System.String)">
            <summary>
            Returns true if a unique string is in the scope
            </summary>
        </member>
        <member name="M:NFX.SealedString.Scope.Seal(System.String)">
            <summary>
            Returns an existing SealedString instance for existing data or allocates a new one.
            This method is thread-safe
            </summary>
        </member>
        <member name="M:NFX.SealedString.Scope.Seal(System.String,System.Boolean@)">
            <summary>
            Returns an existing SealedString instance for existing data or allocates a new one.
            This method is thread-safe
            </summary>
        </member>
        <member name="P:NFX.SealedString.Scope.Count">
            <summary>
            Returns the number of unique strings in scope
            </summary>
        </member>
        <member name="P:NFX.SealedString.Scope.Item(System.String)">
            <summary>
            Returns a SealedString for an existing key in scope or SealedString.Unassigned for a non-exisiting string
            </summary>
        </member>
        <member name="T:NFX.Security.CAPTCHA.PuzzleKeypad">
            <summary>
            Provides methods for generation, storing, and interpretation of user actions with a keypad of random layout.
            This .ctor is supplied some code that user has to punch-in(touch/click) on a randomly laid-out keypad which is usually rendered as
             an image. Use DecipherCoordinates() methods to convert user click/touch coordinates into characters
            </summary>
        </member>
        <member name="M:NFX.Security.CAPTCHA.PuzzleKeypad.DecipherCoordinates(NFX.Serialization.JSON.JSONDataArray,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Translates user action coordinates (i.e. screen touches or mouse clicks) into a string.
            The coordinates must be supplied as a JSON array of json objects that have '{x: [int], y: [int]}' structure
            </summary>
        </member>
        <member name="M:NFX.Security.CAPTCHA.PuzzleKeypad.DecipherCoordinates(System.Collections.Generic.IEnumerable{System.Drawing.Point},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Translates user action coordinates (i.e. screen touches or mouse clicks) into a string.
            The coordinates are supplied as IEnumerable(Point)
            </summary>
        </member>
        <member name="M:NFX.Security.CAPTCHA.PuzzleKeypad.DefaultRender(System.Nullable{System.Drawing.Color},System.Boolean)">
            <summary>
            Renders default image of the keypad suitable for user entry (i.e. touch or mouse clicks)
            </summary>
        </member>
        <member name="P:NFX.Security.CAPTCHA.PuzzleKeypad.Code">
            <summary>
            Returns the original secret code that this keypad was created for
            </summary>
        </member>
        <member name="P:NFX.Security.CAPTCHA.PuzzleKeypad.Boxes">
            <summary>
            Returns char boxes
            </summary>
        </member>
        <member name="P:NFX.Security.CAPTCHA.PuzzleKeypad.Size">
            <summary>
            Returns the size of rectangle that covers all boxes
            </summary>
        </member>
        <member name="T:NFX.Security.GDIDCredentials">
            <summary>
            Represents credentials based on Global Distributed ID
            </summary>
        </member>
        <member name="T:NFX.Security.Credentials">
            <summary>
            User credentials base class. A credentials may be as simple as user+password, access card codes, door key, Twitter account token etc...
            </summary>
        </member>
        <member name="M:NFX.Security.Credentials.Forget">
            <summary>
            Deletes sensitive information (such as password).
            This method is mostly used on client (vs. server) to prevent process memory-inspection attack.
            Its is usually called right after Login() was called.
            Implementers may consider forcing post-factum GC.Collect() on all generations to make sure that orphaned
            memory buff with sensitive information, that remains in RAM even after all references are killed, gets
            compacted; consequently, this method may take considerable time to execute.
            </summary>
        </member>
        <member name="P:NFX.Security.Credentials.Forgotten">
            <summary>
            Indicates whether Forget() was called on this instance
            </summary>
        </member>
        <member name="T:NFX.Security.SocialNetTokenCredentials">
            <summary>
            Represents credentials supplied from/to Social Net site (i.e. Facebook, Twitter etc.)
            </summary>
        </member>
        <member name="P:NFX.Security.SocialNetTokenCredentials.NetName">
            <summary>
            Name of social network that returned the token
            </summary>
        </member>
        <member name="P:NFX.Security.SocialNetTokenCredentials.Token">
            <summary>
            Auth token returned by the network
            </summary>
        </member>
        <member name="P:NFX.Security.SocialNetTokenCredentials.UserName">
            <summary>
            Optional user name as returned from social network (i.e. email or account screen name)
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BinUtils">
            <summary>
            Facilitates read.writing binary BSON primitives. Developers should not normally use this class
            as it is used by serializers and socket low-level code
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.WriteTerminator(System.IO.Stream)">
            <summary>
            Writes terminator 0x00 symbol to stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.WriteCString(System.IO.Stream,System.String)">
            <summary>
             Writes BSON cstring to stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.WriteByte(System.IO.Stream,System.Byte)">
            <summary>
            Writes byte to stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.WriteDouble(System.IO.Stream,System.Double)">
            <summary>
            Writes double to stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.WriteInt16(System.IO.Stream,System.Int16)">
            <summary>
            Writes 16-bit int to stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.WriteInt16(System.Byte[],System.Int16,System.Int32)">
            <summary>
            Writes 16-bit int to byte array
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.WriteUInt16(System.IO.Stream,System.UInt16)">
            <summary>
            Writes unsigned 16-bit int to stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.WriteUInt16(System.Byte[],System.UInt16,System.Int32)">
            <summary>
            Writes unsigned 16-bit int to byte array
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.WriteInt32(System.IO.Stream,System.Int32)">
            <summary>
            Writes 32-bit int to stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.WriteInt32(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes 32bit int to byte array
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.WriteUInt24(System.Byte[],System.UInt32,System.Int32)">
            <summary>
            Writes unsigned 24bit int (less than 2^24) to byte array
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.WriteUInt32(System.IO.Stream,System.UInt32)">
            <summary>
            Writes unsigned 32-bit int to stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.WriteUInt32(System.Byte[],System.UInt32,System.Int32)">
            <summary>
            Writes unsigned 32bit int to byte array
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.WriteInt64(System.IO.Stream,System.Int64)">
            <summary>
            Writes 64-bit int to stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.WriteInt64(System.Byte[],System.Int64,System.Int32)">
            <summary>
            Writes 64-bit int to byte array
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.WriteUInt64(System.IO.Stream,System.UInt64)">
            <summary>
            Writes unsigned 64-bit int to stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.WriteUInt64(System.Byte[],System.UInt64,System.Int32)">
            <summary>
            Writes unsigned 64-bit int to byte array
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.ReadElementType(System.IO.Stream)">
            <summary>
            Reads BSON element type from stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.ReadInt16(System.IO.Stream)">
            <summary>
            Reads 16-bit int from stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.ReadInt16(System.Byte[],System.Int32)">
            <summary>
            Reads 16-bit int from byte array
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.ReadUInt16(System.IO.Stream)">
            <summary>
            Reads unsigned 16-bit int from stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.ReadUInt16(System.Byte[],System.Int32)">
            <summary>
            Reads unsigned 16-bit int from byte array
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.ReadInt32(System.IO.Stream)">
            <summary>
            Reads 32-bit int from stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.ReadInt32(System.Byte[],System.Int32)">
            <summary>
            Reads 32-bit int from byte array
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.ReadUInt24(System.Byte[],System.Int32)">
            <summary>
            Reads 24-bit int (less than 2^24) from byte array
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.ReadUInt32(System.IO.Stream)">
            <summary>
            Reads unsigned 32-bit int from stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.ReadUInt32(System.Byte[],System.Int32)">
            <summary>
            Reads unsigned 32-bit int from byte array
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.ReadInt64(System.IO.Stream)">
            <summary>
            Reads 64-bit int from stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.ReadInt64(System.Byte[],System.Int32)">
            <summary>
            Reads 64-bit int from byte array
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.ReadUInt64(System.IO.Stream)">
            <summary>
            Reads unsigned 64-bit int from stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.ReadUInt64(System.Byte[],System.Int32)">
            <summary>
            Reads unsigned 64-bit int from byte array
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.ReadCString(System.IO.Stream,System.Int32)">
            <summary>
             Reads BSON cstring from stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.ReadCString(System.IO.Stream)">
            <summary>
             Reads BSON cstring from stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.ReadDouble(System.IO.Stream)">
            <summary>
            Reads double from stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BinUtils.GetIntDigitCount(System.Int32)">
            <summary>
            Returns number of digits in 32-bit integer value
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.TemplateArg">
            <summary>
            Represents template argument
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONDocument">
            <summary>
            Represents a BSON document
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONDocument.#ctor">
            <summary>
            Create an empty document
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONDocument.FromArray(System.Byte[])">
            <summary>
            Creates document from array containing BSON-encoded data
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONDocument.#ctor(System.IO.Stream)">
            <summary>
            Deserializes BSON document from stream containing BSON-encoded data
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONDocument.#ctor(System.String,System.Boolean,NFX.Serialization.BSON.TemplateArg[])">
            <summary>
            Creates an instance of the document from JSON template with parameters populated from args optionally caching the template internal
            representation. Do not cache templates that change often
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONDocument.GetByteSize(System.Boolean)">
            <summary>
            Calculates the BSON binary size of this document expressed in bytes
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONDocument.TryGetObjectValueOf(System.String)">
            <summary>
            Tries to get an element by name and if found returns its object value, null otherwise
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONDocument.IndexOfName(System.String)">
            <summary>
            Returns index of named BSONElement or -1 if it does not exist
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONDocument.Set(NFX.Serialization.BSON.BSONElement,System.Int32)">
            <summary>
            Inserts BSONElement into document
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONDocument.Set(NFX.Serialization.BSON.BSONElement,System.Boolean@,System.Int32)">
            <summary>
            Inserts BSONElement into document
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONDocument.Delete(System.String)">
            <summary>
            Deletes an element by name returning true if it was found and deleted
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONDocument.WriteAsJSON(System.IO.TextWriter,System.Int32,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Serializes this dosument into a TextWriter - this method is used by JSON serializer(JSONWriter)
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONDocument.WriteAsBSON(System.IO.Stream)">
            <summary>
            Serializes this document into BSON-format stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONDocument.WriteAsBSONToNewArray">
            <summary>
            Serializes BSON document to byte[]
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONDocument.setCore(NFX.Serialization.BSON.BSONElement,System.Int32)">
            <summary>
            Returns true when added, false - replaced
            </summary>
        </member>
        <member name="P:NFX.Serialization.BSON.BSONDocument.Item(System.String)">
            <summary>
            Returns BSONElement by name or null if not found
            </summary>
        </member>
        <member name="P:NFX.Serialization.BSON.BSONDocument.Item(System.Int32)">
            <summary>
            Returns BSONElement by index or null if index is out of bounds
            </summary>
        </member>
        <member name="P:NFX.Serialization.BSON.BSONDocument.Count">
            <summary>
            Returns the number of BSONElements in this document
            </summary>
        </member>
        <member name="P:NFX.Serialization.BSON.BSONDocument.ByteSize">
            <summary>
            Recalculates the BSON binary size of this document expressed in bytes
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONElement">
            <summary>
            Very base class for BSON elements
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONElement.GetByteSize(System.Boolean)">
            <summary>
            Returns the BSON binary size of this element expressed in bytes
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONElement.GetValueByteSize">
            <summary>
            Returns the size of this element in bytes
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONElement.WriteToStream(System.IO.Stream)">
            <summary>
            Write element to stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONElement.WriteValueToStream(System.IO.Stream)">
            <summary>
            Override to write this element into a stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONElement.ReadValueFromStream(System.IO.Stream)">
            <summary>
            Override to read element's value from stream
            </summary>
        </member>
        <member name="P:NFX.Serialization.BSON.BSONElement.Name">
            <summary>
            Return the name of this element. The name is immutable.
            Check IaArrayElelemnt first, as this property can not be gotten for array elements
            </summary>
        </member>
        <member name="P:NFX.Serialization.BSON.BSONElement.IsArrayElement">
            <summary>
            Returns true when this element does not have a name - it is a part of the array
            </summary>
        </member>
        <member name="P:NFX.Serialization.BSON.BSONElement.ElementType">
            <summary>
            Provides BSON classification of data type
            </summary>
        </member>
        <member name="P:NFX.Serialization.BSON.BSONElement.ObjectValue">
            <summary>
            Gets/sets the value of this element polymorphically
            </summary>
        </member>
        <member name="P:NFX.Serialization.BSON.BSONElement.ByteSize">
            <summary>
            Recalculates the BSON binary size of this document expressed in bytes
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONElement`1">
            <summary>
            Base class for BSON elements with typed Value property
            </summary>
        </member>
        <member name="P:NFX.Serialization.BSON.BSONElement`1.ObjectValue">
            <summary>
            Gets/sets value as object. In normal cases use typed Value to get/set instead
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONArrayElement">
            <summary>
            Represents a BSON array element with BSONElement[] value
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONArrayElement.#ctor(NFX.Serialization.BSON.BSONElement[])">
            <summary>
            Creates an array element
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONDocumentElement">
            <summary>
            Represents a BSON element with a BSON document value
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONDocumentElement.#ctor(NFX.Serialization.BSON.BSONDocument)">
            <summary>
            Creates an array element
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONStringElement">
            <summary>
            Represents a BSON element with a string value
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONStringElement.#ctor(System.String)">
            <summary>
            Creates an array element
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONInt32Element">
            <summary>
            Represents a BSON element with an int32 value
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONInt32Element.#ctor(System.Int32)">
            <summary>
            Creates an array element
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONBooleanElement">
            <summary>
            Represents a BSON element with an bool value
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONBooleanElement.#ctor(System.Boolean)">
            <summary>
            Creates an array element
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONDateTimeElement">
            <summary>
            Represents a BSON element with an UTC DateTime value
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONDateTimeElement.#ctor(System.DateTime)">
            <summary>
            Creates an array element
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONRegularExpressionElement">
            <summary>
            Represents a BSON element with an regular expression value
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONRegularExpressionElement.#ctor(NFX.Serialization.BSON.BSONRegularExpression)">
            <summary>
            Creates an array element
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONDoubleElement">
            <summary>
            Represents a BSON element with an int32 value
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONDoubleElement.#ctor(System.Double)">
            <summary>
            Creates an array element
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONInt64Element">
            <summary>
            Represents a BSON element with an int64 value
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONInt64Element.#ctor(System.Int64)">
            <summary>
            Creates an array element
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONObjectIDElement">
            <summary>
            Represents a BSON element with an BSONObjectID value
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONObjectIDElement.#ctor(NFX.Serialization.BSON.BSONObjectID)">
            <summary>
            Creates an array element
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONBinaryElement">
            <summary>
            Represents a BSON element with an BSONBinary value
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONBinaryElement.#ctor(NFX.Serialization.BSON.BSONBinary)">
            <summary>
            Creates an array element
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONJavaScriptElement">
            <summary>
            Represents a BSON element with a javascript value
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONJavaScriptElement.#ctor(System.String)">
            <summary>
            Creates an array element
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONJavaScriptWithScopeElement">
            <summary>
            Represents a BSON element with a javascript with scope value
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONJavaScriptWithScopeElement.#ctor(NFX.Serialization.BSON.BSONCodeWithScope)">
            <summary>
            Creates an array element
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONTimestampElement">
            <summary>
            Represents a BSON element with an Timestamp value
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.BSONTimestampElement.#ctor(NFX.Serialization.BSON.BSONTimestamp)">
            <summary>
            Creates an array element
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONMinKeyElement">
            <summary>
            Represents an element with Min Key value
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONMaxKeyElement">
            <summary>
            Represents an element with MaxKey value
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONNullElement">
            <summary>
            Represents an element with NULL value
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONElementType">
            <summary>
             BSON element types: http://bsonspec.org/spec.html
            </summary>
        </member>
        <member name="F:NFX.Serialization.BSON.BSONRegularExpressionOptions.I">
            <summary>Insensitive matching</summary>
        </member>
        <member name="F:NFX.Serialization.BSON.BSONRegularExpressionOptions.M">
            <summary>Multiline matching</summary>
        </member>
        <member name="F:NFX.Serialization.BSON.BSONRegularExpressionOptions.X">
            <summary>Verbose mode</summary>
        </member>
        <member name="F:NFX.Serialization.BSON.BSONRegularExpressionOptions.L">
            <summary>Make \w, \W, etc. locale dependent</summary>
        </member>
        <member name="F:NFX.Serialization.BSON.BSONRegularExpressionOptions.S">
            <summary>Dotall mode ('.' matches everything)</summary>
        </member>
        <member name="F:NFX.Serialization.BSON.BSONRegularExpressionOptions.U">
            <summary>Make \w, \W, etc. match unicode</summary>
        </member>
        <member name="T:NFX.Serialization.BSON.RegularExpressionExtensions">
            <summary>
            Utilities methods for BSON regular expression type
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.RegularExpressionExtensions.ToBSONString(NFX.Serialization.BSON.BSONRegularExpressionOptions)">
            <summary>
            Returns BSON-formatted string for regeax options
            (The options are identified by lower-case characters, which must be stored in alphabetical order).
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.RegularExpressionExtensions.Count(NFX.Serialization.BSON.BSONRegularExpressionOptions)">
            <summary>
            Returns regex options count
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONException">
            <summary>
            Base exception thrown by the BSON framework
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONObjectID">
            <summary>
            Represents an ObjectId as a 12-byte BSON type
            </summary>
        </member>
        <member name="P:NFX.Serialization.BSON.BSONObjectID.AsGDID">
            <summary>
            Interprets BSON/MongoDB object ID as NFX GDID
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONBinary">
            <summary>
            Represents a BSON bynary type
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONRegularExpression">
            <summary>
            Represents a BSON regular expression type
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONCodeWithScope">
            <summary>
            Represents a BSON javascript with the scope type
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.BSONTimestamp">
            <summary>
            Represents a BSON timestamp type
            </summary>
        </member>
        <member name="T:NFX.Serialization.BSON.RowConverter">
            <summary>
            Provides methods for Row to/from BSONDocument conversion
            </summary>
        </member>
        <member name="F:NFX.Serialization.BSON.RowConverter.MAX_BYTE_BUFFER_SIZE">
            <summary>
            Maximum size of a byte[] field.
            Large filed (> 1Mbyte) should not be stored as fields in the database
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.RowConverter.InferSchemaFromBSONDocument(NFX.Serialization.BSON.BSONDocument,System.String)">
            <summary>
            Makes CRUD Schema out of BSON document. The types of all fields are object as documents do not have
             a predictable type of every field (they are dynamic and can change form doc to doc)
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.RowConverter.BSONDocumentToRow(NFX.Serialization.BSON.BSONDocument,NFX.DataAccess.CRUD.Row,System.String,System.Boolean,System.Func{NFX.Serialization.BSON.BSONDocument,NFX.Serialization.BSON.BSONElement,System.Boolean})">
            <summary>
            Converts BSON document into Row by filling the supplied row instance making necessary type transforms to
             suit Row.Schema field definitions per target name. If the passed row supports IAmorphousData, then
            the fields either not found in row, or the fields that could not be type-converted to CLR type will be
            stowed in amorphous data dictionary
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.RowConverter.MapBSONFieldNameToSchemaFieldDef(NFX.DataAccess.CRUD.Schema,System.String,System.String)">
            <summary>
            Maps bsonFieldName to targeted fieldDef from specified schema using cache for TypedRows
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.RowConverter.TryConvertBSONtoCLR(System.Type,NFX.Serialization.BSON.BSONElement,System.String,System.Object@,System.Func{NFX.Serialization.BSON.BSONDocument,NFX.Serialization.BSON.BSONElement,System.Boolean})">
            <summary>
            Tries to convert the BSON value into target CLR type. Returns true if conversion was successfull
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.RowConverter.DirectConvertBSONValue(NFX.Serialization.BSON.BSONElement,System.Func{NFX.Serialization.BSON.BSONDocument,NFX.Serialization.BSON.BSONElement,System.Boolean})">
            <summary>
            Converts BSON to CLR value 1:1, without type change
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.RowConverter.BSONDocumentToJSONMap(NFX.Serialization.BSON.BSONDocument,System.Func{NFX.Serialization.BSON.BSONDocument,NFX.Serialization.BSON.BSONElement,System.Boolean})">
            <summary>
            Converts BSON document to JSON data map by directly mapping
             BSON types into corresponding CLR types. The sub-documents get mapped into JSONDataObjects,
              and BSON arrays get mapped into CLR object[]
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.RowConverter.RowToBSONDocument(NFX.DataAccess.CRUD.Row,System.String,System.Boolean,NFX.DataAccess.CRUD.FieldFilterFunc)">
            <summary>
            Converts row to BSON document suitable for storage in MONGO.DB.
            Pass target name (name of particular store/epoch/implementation) to get targeted field metadata.
            Note: the supplied row MAY NOT CONTAIN REFERENCE CYCLES - either direct or transitive
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.RowConverter.RowToBSONDocumentElement(NFX.DataAccess.CRUD.Row,System.String,System.Boolean,System.String,NFX.DataAccess.CRUD.FieldFilterFunc)">
            <summary>
            Converts row to BSON document suitable for storage in MONGO.DB.
            Pass target name (name of particular store/epoch/implementation) to get targeted field metadata.
            Note: the supplied row MAY NOT CONTAIN REFERENCE CYCLES - either direct or transitive
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.RowConverter.ConvertCLRtoBSON(System.String,System.Object,System.String)">
            <summary>
            Converts CLR value to BSON. The following values are supported:
              primitives+scaled decimal, enums, TypedRows, GDID, Guid, Amount, IDictionary, IEnumerable (including arrays).
            If conversion could not be made then exception is thrown
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.RowConverter.DoConvertCLRtoBSON(System.String,System.Object,System.Type,System.String)">
            <summary>
            override to perform the conversion. the data is never null here, and ref cycles a ruled out
            </summary>
        </member>
        <member name="M:NFX.Serialization.BSON.RowConverter.ByteBufferID_CLRtoBSON(System.String,System.Byte[])">
            <summary>
            Encodes byte buffer purposed for id, using proper binary subtype
            </summary>
        </member>
        <member name="P:NFX.Serialization.BSON.RowConverter.DefaultInstance">
            <summary>
            Returns the default instance
            </summary>
        </member>
        <member name="T:NFX.Serialization.CSV.CSVWritingOptions">
            <summary>
            Specifies how row should be written in CSV.
            Use CSVWritingOptions.Default static property for typical options
            </summary>
        </member>
        <member name="F:NFX.Serialization.CSV.CSVWritingOptions.FieldDelimiter">
            <summary>
            Specifies field delimiter, comma is default
            </summary>
        </member>
        <member name="F:NFX.Serialization.CSV.CSVWritingOptions.NullValue">
            <summary>
            Specifies string that will be used for null values
            </summary>
        </member>
        <member name="F:NFX.Serialization.CSV.CSVWritingOptions.LoadAllFields">
            <summary>
            Indicates if nonUI/non-stored fields must be loaded
            </summary>
        </member>
        <member name="F:NFX.Serialization.CSV.CSVWritingOptions.IncludeHeader">
            <summary>
            Indicates if field names must be included in result
            </summary>
        </member>
        <member name="P:NFX.Serialization.CSV.CSVWritingOptions.Default">
            <summary>
            Writes CSV with comma as field delimiter, empty string for null values,
            skipping nonUI/non-stored fields, including field names
            </summary>
        </member>
        <member name="P:NFX.Serialization.CSV.CSVWritingOptions.AllFields">
            <summary>
            Writes all fields with comma as field delimiter, empty string for null values,
            including field names
            </summary>
        </member>
        <member name="P:NFX.Serialization.CSV.CSVWritingOptions.NoHeader">
            <summary>
            Writes CSV with comma as field delimiter, empty string for null values,
             skipping nonUI/non-stored fields, but without field names
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONExtensions">
            <summary>
            Provides JSON extension methods
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONExtensions.JSONToDynamic(System.String,System.Boolean)">
            <summary>
             Deserializes JSON content into dynamic JSON object
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONExtensions.JSONToDynamic(System.IO.Stream,System.Text.Encoding,System.Boolean)">
            <summary>
             Deserializes JSON content into dynamic JSON object
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONExtensions.JSONToDynamic(NFX.CodeAnalysis.Source.ISourceText,System.Boolean)">
            <summary>
             Deserializes JSON content into dynamic JSON object
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONExtensions.JSONToDataObject(System.String,System.Boolean)">
            <summary>
             Deserializes JSON content into IJSONDataObject
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONExtensions.JSONToDataObject(System.IO.Stream,System.Text.Encoding,System.Boolean)">
            <summary>
             Deserializes JSON content into IJSONDataObject
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONExtensions.JSONToDataObject(NFX.CodeAnalysis.Source.ISourceText,System.Boolean)">
            <summary>
             Deserializes JSON content into IJSONDataObject
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONExtensions.ToJSON(System.Object,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
             Serializes object into JSON string
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONExtensions.ToJSON(System.Object,System.IO.TextWriter,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
             Serializes object into JSON format using provided TextWriter
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONExtensions.ToJSON(System.Object,System.IO.Stream,NFX.Serialization.JSON.JSONWritingOptions,System.Text.Encoding)">
            <summary>
             Serializes object into JSON format using provided stream and optional encoding
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.IJSONReadable">
            <summary>
            Denotes a CLR type-safe entity (class or struct) that can directly read itself from IJSONDataObject which is supplied by JSON parser.
            This mechanism bypasses all of the reflection/dynamic code.
            This approach may be far more performant for some classes that need to de-serialize their state/data from JSON format,
            than relying on general-purpose JSON serializer that can deserialize any type but is slower.
            The particular type has to be allocated first, then it's instance can be hydrated with data/state using this method
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.IJSONReadable.ReadAsJSON(NFX.Serialization.JSON.IJSONDataObject)">
            <summary>
            Reads entitie's data/state from low-level IJSONDataObject which is supplied right by JSONParser.
            An implementer may elect to throw various types of exceptions to signal such conditions as:
             unknown key map, or too many fields not supplied etc.
            </summary>
            <param name="data">JSONParser-supplied object</param>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONPatternMatchAttribute">
            <summary>
            Base class for JSON pattern matching
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.JSON.JSONPatternMatchAttribute.Check(System.Reflection.MemberInfo,NFX.CodeAnalysis.JSON.JSONLexer)">
            <summary>
            Checks all pattern match attributes against specified member info until first match found
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.JSON.JSONPatternMatchAttribute.Match(NFX.CodeAnalysis.JSON.JSONLexer)">
            <summary>
            Override to perform actual pattern matching, i.e. the one that uses FSM
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONWriter">
            <summary>
            Writes primitive types, JSONDataObjects, JSONDynamicObjects, IEnumerable and IDictionary - implementers into string or stream.
            Can also write IJSONWritable-implementing types that directly serialize their state into JSON.
            This class does not serialize regular CLR types (that do not implement IJSONWritable), use JSONSerializer for full functionality
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONWriter.WriteToFile(System.Object,System.String,NFX.Serialization.JSON.JSONWritingOptions,System.Text.Encoding)">
            <summary>
            Writes JSON data to the file
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONWriter.WriteToBuffer(System.Object,NFX.Serialization.JSON.JSONWritingOptions,System.Text.Encoding)">
            <summary>
            Writes JSON data to the byte[]
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONWriter.Write(System.Object,System.IO.Stream,NFX.Serialization.JSON.JSONWritingOptions,System.Text.Encoding)">
            <summary>
            Writes JSON data to the stream
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONWriter.Write(System.Object,NFX.Serialization.JSON.JSONWritingOptions,System.IFormatProvider)">
            <summary>
            Writes JSON data to the string
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONWriter.Write(System.Object,System.IO.TextWriter,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Appends JSON data into the instance of StringBuilder
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONWriter.WriteMap(System.IO.TextWriter,System.Collections.IDictionary,System.Int32,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Appends JSON representation of a map(IDictionary)
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONWriter.WriteMap(System.IO.TextWriter,System.Collections.Generic.IEnumerable{System.Collections.DictionaryEntry},System.Int32,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Appends JSON representation of a map(IEnumerable(DictionaryEntry))
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONWriter.WriteMap(System.IO.TextWriter,System.Int32,NFX.Serialization.JSON.JSONWritingOptions,System.Collections.DictionaryEntry[])">
            <summary>
            Appends JSON representation of a map(IEnumerable(DictionaryEntry))
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONWriter.WriteArray(System.IO.TextWriter,System.Collections.IEnumerable,System.Int32,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Appends JSON representation of an IEnumerable
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONWriter.EncodeString(System.IO.TextWriter,System.String,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Writes a string in JSON format (a la "JSON encode string") - using quotes and escaping charecters that need it
            </summary>
            <param name="wri">TextWriter instance to append data into</param>
            <param name="data">Original string to encode as JSON</param>
            <param name="opt">JSONWriting options instance, if omitted then JSONWritingOptions.Compact is used</param>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONWriter.EncodeDateTime(System.IO.TextWriter,System.DateTime,NFX.Serialization.JSON.JSONWritingOptions,System.Nullable{System.TimeSpan})">
            <summary>
            Writes a string in JSON format (a la "JSON encode string") - using quotes and escaping charecters that need it
            </summary>
            <param name="wri">TextWriter instance to append data into</param>
            <param name="data">Original string to encode as JSON</param>
            <param name="opt">JSONWriting options instance, if omitted then JSONWritingOptions.Compact is used</param>
            <param name="utcOffset">UTC offset override. If not supplied then offset form local time zone is used</param>
        </member>
        <member name="T:NFX.CodeAnalysis.Laconfig.LaconfigData">
            <summary>
            Represets laconfig parser result
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.ObjectResultAnalysisContext`1">
            <summary>
            A context that can hold analysis result as TObject.
            This class is useful for cases like dynamic language parsers (i.e. JSON)
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CommonCodeProcessor">
            <summary>
            Provides base implementation for common code processors
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.ICodeProcessor">
            <summary>
            Describes an entity that may process source code in some language
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.ICodeProcessor.MessageCodeToString(System.Int32)">
            <summary>
            Returns string representation of message code which is output by this processor
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.ICodeProcessor.Context">
            <summary>
            Returns context that this processor operates under
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.ICodeProcessor.Language">
            <summary>
            References language that this entity supports
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.ICodeProcessor.Messages">
            <summary>
            References message list that processor emitts messages into.
            May be null, in which case errors are always thrown because they can not get logged into message list
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.ICodeProcessor.ThrowErrors">
            <summary>
            When true, throws an exception on the first error even when MessageList is set.
            When MessageList is not set any error is always thrown regardless of this parameter
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.CommonCodeProcessor.MessageCodeToString(System.Int32)">
            <summary>
            Returns string representation of message code which is output by this processor
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.CommonCodeProcessor.Context">
            <summary>
            Returns context that this processor operates under -
            an entity that retains state during analysis, such as: module compiler, project compiler, code unit translator etc.
            This entity may also contain compiler/parser/lexer options etc.
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.CommonCodeProcessor.Messages">
            <summary>
            References message list that lexer emitts messages into. May be null
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.CommonCodeProcessor.ThrowErrors">
            <summary>
            When true, throws an exception on the first error even when MessageList is set.
            When MessageList is not set any lexing error is always thrown regardless of this parameter
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.CommonCodeProcessor.Language">
            <summary>
            Returns language that this processor is capable of processing
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.IAnalysisContext">
            <summary>
            Describes an entity that retains state during analysis, such as: module compiler, project compiler, code unit translator etc.
            This entity may also contain compiler/parser/lexer options etc.
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Laconfig.LaconfigKeywords">
            <summary>
            Provides Laconfig keyword resolution services, this class is thread safe
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Laconfig.LaconfigKeywords.Resolve(System.String)">
            <summary>
            Resolves a Laconfig keyword
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Laconfig.LaconfigLanguage">
            <summary>
            Represents Laconic + Config = Laconfig terse configuration language
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Laconfig.LaconfigLexer">
            <summary>
            Performs lexical analysis on source supplied in Laconfig syntax.
            This class supports lazy analysis that happens gradually as result tokens are consumed through IEnumerable interface.
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Lexer`1">
            <summary>
            Performs lexical analysis of the source code in particular language
            Allows to enumerate over source as typed Token stream - depending on implementation enumeration may do
            lexical analysis token-by-token or in chunks with every enumerator advance
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.SourceRefCommonCodeProcessor">
            <summary>
            Provides base implementation for common code processors
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.SourceRefCommonCodeProcessor.SourceCodeReference">
            <summary>
            References source code that is processed
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.ILexer">
            <summary>
            Describes general lexer interface.
            Lexers turn string source input which is obtained via ISourceText implementation (i.e. FileSource,WebSource...)
             into tokenized stream. Some lexer implementations may support lazy analysis, that is - source text analysis which is done
              in chunks when lexer is iterated over, others may lex the whole source text at once
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.ILexer.AnalyzeAll">
            <summary>
            If lexer supports lazy analysis, forces analysis of the whole source
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.ILexer.SourceCodeReference">
            <summary>
            References source code that was lexed
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.ILexer.Source">
            <summary>
            References source code text that was lexed
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.ILexer.TokenStream">
            <summary>
            Enumerates Token stream - depending on implementation enumeration may do
            lexical analysis token-by-token or in chunks with every enumerator advance
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.ILexer.AllAnalyzed">
            <summary>
            Returns true when the shole input source has been analyzed. This property is always true for lexers that do not support lazy analysis
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Lexer`1.AnalyzeAll">
            <summary>
            If lexer supports lazy analysis, forces analysis of the whole source
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Lexer`1.DoLexingChunk">
            <summary>
            Lexes more source and returns true when EOF has been reached.
            Depending on particular implementation, a chunk may contain more than one token.
            Tokens are added into m_Tokens
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Lexer`1.Source">
            <summary>
            References source code text that was lexed
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Lexer`1.AllAnalyzed">
            <summary>
            Returns true when the whole input source has been analyzed. This property is always true for lexers that do not support lazy analysis
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Lexer`1.Tokens">
            <summary>
            Returns tokenized source as indexable list.
            Accessing this property causes lexical analysis to complete on the whole source if it has not been completed yet
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Lexer`1.TokenStream">
            <summary>
            Enumerates Token stream - depending on implementation enumeration may do
            lexical analysis token-by-token or in chunks with every enumerator advance
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Laconfig.LaconfigMsgCode">
            <summary>
            Message codes for Laconfig code processors
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Laconfig.LaconfigParser">
            <summary>
            Parses Laconfig lexer output into laconic configuration node graph
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Parser`1">
            <summary>
            Performs parsing of token streams provided by lexers
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.IParser">
            <summary>
            Describes general parser interface
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.IParser.Parse">
            <summary>
            Performs parsing and sets HasParsed to true if it has not been performed yet
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.IParser.SourceInput">
            <summary>
            Lists source lexers that supply token stream for parsing
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.IParser.HasParsed">
            <summary>
            Indicates whether Parse() already happened
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Parser`1.Parse">
            <summary>
            Performs parsing if it has not been performed yet
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Parser`1.DoParse">
            <summary>
            Override to perform actual parsing
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Parser`1.Input">
            <summary>
            Returns lexers that feed this parser
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Parser`1.SourceInput">
            <summary>
            Lists source lexers that supply token stream for parsing
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Parser`1.HasParsed">
            <summary>
            Indicates whether Parse() already happened
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Laconfig.LaconfigToken">
            <summary>
            Represents a token of Laconfig language
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Token">
            <summary>
            Represents a lexical token of the language. This is an abstract class that particular language implementations must extend
             to define language-specific token types
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.Language">
            <summary>
            Returns language that this token is a part of
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.Kind">
            <summary>
            Provides language-agnostic classification for token type
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsPrimary">
            <summary>
            Returns true for tokens that are primary part of the language, not control, metadata, directive, comment etc...
            For example BOF,EOF markers are not primary part of the language, compiler directives, comments are not either.
            This property is useful for pattern searches, when comments and other non-primary tokens need to be quickly skipped
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsNonLanguage">
            <summary>
            This property is needed due to the fact that language lexers may be used to analyze special supersets of regular
             language grammars i.e. for pattern matches, template parser etc. Code compilers may elect to throw errors when this property is true.
            Returns true for tokens that are not part of the valid language grammar, however they exist for other reasons,
            for example - for pattern capture match analysis, or for template processing
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.OrdinalType">
            <summary>
            Returns token type as a grammar-agnostic ordinal
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsBOF">
            <summary>
            Indicates whether this token indicates an BEGINNING-OF-FILE condition
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsEOF">
            <summary>
            Indicates whether this token indicates an END-OF-FILE condition
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsDirective">
            <summary>
            Indicates whether this token represents a directive
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsComment">
            <summary>
            Indicates whether this token represents a comment
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsLiteral">
            <summary>
            Indicates whether this token represents a literal
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsTextualLiteral">
            <summary>
            Indicates whether this token represents a literal, which is a string or a character sequence.
            This flag is useful for pattern searches that examine comments and strings for sub-patterns
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsNumericLiteral">
            <summary>
            Indicates whether this token represents a literal, which is a numeric literal (i.e. int, double)
            This flag is useful for pattern searches that look for particular constant values in numbers (i.e. year = 2000)
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsIdentifier">
            <summary>
            Indicates whether this token represents an identifier
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsKeyword">
            <summary>
            Indicates whether this token represents a language keyword
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsOperator">
            <summary>
            Indicates whether this token represents an operator
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Token.IsSymbol">
            <summary>
            Indicates whether this token represents a symbol
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Laconfig.LaconfigTokenType">
            <summary>
            Denotes Laconfig token types
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions">
            <summary>
            Specifies how Laconic configuration should be written as text. Use LaconfigWritingOptions.Compact or LaconfigWritingOptions.PrettyPrint
             static properties for typical options
            </summary>
        </member>
        <member name="F:NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions.DontWriteRootSectionDeclaration">
            <summary>
            If true, does not write the very top node declaration: name, value and { }.
            The attributes are still written as usual.
            This is needed for storage conf in db where the root node is not needed to save space
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions.Compact">
            <summary>
            Writes Laconfig without line breaks between members and no indenting. Suitable for data transmission
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions.PrettyPrint">
            <summary>
            Writes Laconfig suitable for printing/screen display
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Laconfig.LaconfigWriter">
            <summary>
            Writes Laconic Configuration into a stream or string
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Laconfig.LaconfigWriter.Write(NFX.Environment.Configuration,System.IO.Stream,NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions,System.Text.Encoding)">
            <summary>
            Writes LaconicConfiguration data to the stream
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Laconfig.LaconfigWriter.Write(NFX.Environment.IConfigSectionNode,System.IO.Stream,NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions,System.Text.Encoding)">
            <summary>
            Writes LaconicConfiguration data to the stream
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Laconfig.LaconfigWriter.Write(NFX.Environment.Configuration,NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions)">
            <summary>
            Writes LaconicConfiguration data to the string
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Laconfig.LaconfigWriter.Write(NFX.Environment.IConfigSectionNode,NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions)">
            <summary>
            Writes LaconicConfiguration data to the string
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Laconfig.LaconfigWriter.Write(NFX.Environment.Configuration,System.Text.StringBuilder,NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions)">
            <summary>
            Appends LaconicConfiguration data into the instance of StringBuilder
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Laconfig.LaconfigWriter.Write(NFX.Environment.IConfigSectionNode,System.Text.StringBuilder,NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions)">
            <summary>
            Appends LaconicConfiguration data into the instance of StringBuilder
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Laconfig.LaconfigWriter.Indent(System.Int32,NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions)">
            <summary>
            Returns a padding string for specified level per set options
            </summary>
        </member>
        <member name="T:NFX.Environment.Behavior">
            <summary>
            Represents a piece of logic that can be applied to different entities declaratively as attribute or through configuration.
            Behaviors are a form of inversion-of-control that allows to configure entities by code which itself can be injected by name from configuration.
            Behaviors are a form of aspect-oriented programming as they allow to proclaim certain "behavior" that knows how to implement itself on various
             application components (i.e. some behavior may inject Glue message inspector or log destination).
            Behaviors can be used to enforce policies by performing pre-run checks  and throw exceptions if certain required providers are not injected/configured
            </summary>
        </member>
        <member name="M:NFX.Environment.Behavior.ApplyConfiguredBehaviors(System.Object,NFX.Environment.IConfigSectionNode)">
            <summary>
            Applies behaviors to instance as configured from config section node
            </summary>
        </member>
        <member name="M:NFX.Environment.Behavior.ApplyBehaviorAttributes(System.Object)">
            <summary>
            Applies behaviors as declared using attributes on target isntance's type
            </summary>
        </member>
        <member name="M:NFX.Environment.Behavior.Apply(System.Object)">
            <summary>
            Override to apply particular behavior to the target
            </summary>
        </member>
        <member name="P:NFX.Environment.Behavior.Order">
            <summary>
            Returns application order
            </summary>
        </member>
        <member name="P:NFX.Environment.Behavior.Cascade">
            <summary>
            Returns true when this instance was configured to cascade down the configuration tree - applied to child items
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CSharp.CSLanguage">
            <summary>
            Represents C# language
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CSharp.CSLexer">
            <summary>
            Performs lexical analysis on source supplied in C# syntax.
            This class supports lazy analysis that happens gradually as result tokens are consumed through IEnumerable interface.
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CSharp.CSMsgCode">
            <summary>
            Message codes for CSharp code processors
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CSharp.CSToken">
            <summary>
            Represents a C# token
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CSharp.CSTokenType">
            <summary>
            Denotes CSharp token types
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CSharp.CSIdentifiers">
            <summary>
            Identifier validation in a context of C# grammar
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.CSharp.CSIdentifiers.ValidateDigit(System.Char)">
            <summary>
            Checks to see whether supplied char is a digit
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.CSharp.CSIdentifiers.ValidateChar(System.Char)">
            <summary>
            Checks whether supplied char is suitable for a part of C# id
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.CSharp.CSIdentifiers.Validate(System.String)">
            <summary>
            Checks whether supplied string is a valid C# ident
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CSharp.CSKeywords">
            <summary>
            Provides C# keyword resolution services, this class is thread safe
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.CSharp.CSKeywords.Resolve(System.String)">
            <summary>
            Resolves a C# keyword - this method IS thread safe
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CSharp.CSNumbers">
            <summary>
            Provides C# number parsing
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.CSharp.CSNumbers.Convert(System.String,NFX.CodeAnalysis.CSharp.CSTokenType@)">
            <summary>
            Tries to convert string to number, returns null if conversion could not be made.
            Raises exception if operand is wider than specifier allows
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.CSharp.CSNumbers.strToInt(System.String,System.UInt64@)">
            <summary>
             Converts number string into int respectibg prefixes
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CSharp.CSStrings">
            <summary>
            Provides C# string escape parsing
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONParser">
            <summary>
            Parses JSON lexer output into object graphs.
            NOTE: Although called JSON, this is really a JSON superset implementation that includes extra features:
             comments, directives, verbatim strings(start with $), ' or " string escapes, unquoted object key names
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.IJSONDataObject">
            <summary>
            Represents a data transfer object (DTO) abstraction used to read/write JSON data
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONDataMap">
            <summary>
            Represents a data transfer object (DTO) JSON map, that associates keys with values
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONDataMap.FromURLEncodedStream(System.IO.Stream,System.Text.Encoding,System.Boolean)">
            <summary>
            Turns URL encoded content into JSONDataMap
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONDataMap.FromURLEncodedString(System.String,System.Boolean)">
            <summary>
            Turns URL encoded content into JSONDataMap
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONDataMap.Append(NFX.Serialization.JSON.JSONDataMap,System.Boolean)">
            <summary>
            Appends contents of another JSONDataMap for keys that do not exist in this one or null.
            Only appends references, does not provide deep reference copy
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONDataMap.ToConfigNode(System.String)">
            <summary>
            Returns this object as a config tree
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONDataArray">
            <summary>
            Represents a data transfer object (DTO) JSON array, that holds a list of values
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONIdentifiers">
            <summary>
            Identifier validation and other utilities in context of JSON grammar
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.JSON.JSONIdentifiers.ValidateChar(System.Char)">
            <summary>
            Checks whether supplied char is suitable for a part of JSON identifier
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.JSON.JSONIdentifiers.ValidateDigit(System.Char)">
            <summary>
            Checks to see whether supplied char is a digit
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.JSON.JSONIdentifiers.Validate(System.String)">
            <summary>
            Checks whether supplied string is a valid JSON grammar identifier
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONData">
            <summary>
            Represents JSONDataParser result
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONMsgCode">
            <summary>
            Message codes for JSON code processors
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONKeywords">
            <summary>
            Provides JSON keyword resolution services, this class is thread safe
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.JSON.JSONKeywords.Resolve(System.String)">
            <summary>
            Resolves a JSON keyword - this method IS thread safe
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.JSON.JSONNumbers.Convert(System.String,NFX.CodeAnalysis.JSON.JSONTokenType@)">
            <summary>
            Tries to convert string to number, returns null if conversion could not be made
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONStrings">
            <summary>
            Provides JSON string escape parsing
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.FSMI">
            <summary>
            Describes transition instructions for Finate State Machine (FSM)
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.LazyFSMPredicate`1">
            <summary>
            Lazy Finate State Machine (FSM) predicate, tries to match condition and returns appropriate next action
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.PatternSearch">
            <summary>
            Provides Token-pattern matching utilities
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LazyFSM``1(System.Collections.Generic.IEnumerable{``0},NFX.CodeAnalysis.LazyFSMPredicate{``0}[])">
            <summary>
            Makes finite state machine fed from IEnumerable(Token) only considering primary language tokens
            </summary>
            <typeparam name="TToken">Concrete language-typed token</typeparam>
            <param name="tokens">Token enumerable</param>
            <param name="predicates">Predicates that supply machine state transition instructions</param>
            <returns>Resulting token fetched by FSMI.Take instruction or null</returns>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LazyFSM``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,NFX.CodeAnalysis.LazyFSMPredicate{``0}[])">
            <summary>
            Makes finite state machine fed from IEnumerable(Token)
            </summary>
            <typeparam name="TToken">Concrete language-typed token</typeparam>
            <param name="tokens">Token enumerable</param>
            <param name="onlyPrimary">Sets filter to consider only primary language tokens (skip comments, directives, etc.)</param>
            <param name="predicates">Predicates that supply machine state transition instructions</param>
            <returns>Resulting token fetched by FSMI.Take instruction or null</returns>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LazyFSM``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,NFX.CodeAnalysis.LazyFSMState{``0}@,NFX.CodeAnalysis.LazyFSMPredicate{``0}[])">
            <summary>
            Makes finite state machine fed from IEnumerable(Token)
            </summary>
            <typeparam name="TToken">Concrete language-typed token</typeparam>
            <param name="tokens">Token enumerable</param>
            <param name="onlyPrimary">Sets filter to consider only primary language tokens (skip comments, directives, etc.)</param>
            <param name="state">Machine's state which will be allocated if null passed</param>
            <param name="predicates">Predicates that supply machine state transition instructions</param>
            <returns>Resulting token fetched by FSMI.Take instruction or null</returns>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.Skip``1(NFX.CodeAnalysis.LazyFSMState{``0},System.Int32)">
            <summary>
            Skips specified number of tokens by returning FSMI.Loop count times
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.TypeIsAnyOf``1(``0,System.Int32[])">
            <summary>
            Returns true when token's type is any of the specified
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.TypeIsAnyOf``2(``0,``1[])">
            <summary>
            Returns true when token's type is any of the specified
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.TextIsAnyOf``1(``0,System.String[])">
            <summary>
            Returns true when token's text is any of specified
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.TextIsAnyOf``1(``0,System.StringComparison,System.String[])">
            <summary>
            Returns true when token's text is any of specified
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.IsAnyOrAbort``1(``0,System.Int32[])">
            <summary>
            Advances FSM when token's type is any of specified or aborts FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.IsAnyOrAbort``2(``0,``1[])">
            <summary>
            Advances FSM when token's type is any of specified or aborts FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.IsAnyOrAbort``1(``0,System.String[])">
            <summary>
            Advances FSM when token's text is any of specified or aborts FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.IsAnyOrAbort``1(``0,System.StringComparison,System.String[])">
            <summary>
            Advances FSM when token's text is any of specified or aborts FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopUntilAny``1(``0,System.Int32[])">
            <summary>
            Advances FSM when token's type is any of specified or loops FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopUntilAny``2(``0,``1[])">
            <summary>
            Advances FSM when token's type is any of specified or loops FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopUntilAny``1(``0,System.String[])">
            <summary>
            Advances FSM when token's text is any of specified or loops FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopUntilAny``1(``0,System.StringComparison,System.String[])">
            <summary>
            Advances FSM when token's text is any of specified or loops FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.DoUntilAny``1(``0,NFX.CodeAnalysis.FSMI,System.Int32[])">
            <summary>
            Performs FSM instruction unless token's type is any of the specified, then advances FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.DoUntilAny``2(``0,NFX.CodeAnalysis.FSMI,``1[])">
            <summary>
            Performs FSM instruction unless token's type is any of the specified, then advances FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.DoUntilAny``1(``0,NFX.CodeAnalysis.FSMI,System.String[])">
            <summary>
            Performs FSM instruction unless token's text is any of the specified, then advances FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.DoUntilAny``1(``0,NFX.CodeAnalysis.FSMI,System.StringComparison,System.String[])">
            <summary>
            Performs FSM instruction unless token's text is any of the specified, then advances FSM
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopWhileAnyOrAbort``1(``0,System.Int32[])">
            <summary>
            Loops FSM while token's type is any of the specified or aborts
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopWhileAnyOrAbort``2(``0,``1[])">
            <summary>
            Loops FSM while token's type is any of the specified or aborts
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopWhileAnyOrAbort``1(``0,System.String[])">
            <summary>
            Loops FSM while token's text is any of the specified or aborts
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopWhileAnyOrAbort``1(``0,System.StringComparison,System.String[])">
            <summary>
            Loops FSM while token's text is any of the specified or aborts
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopUntilMatch``1(NFX.CodeAnalysis.LazyFSMState{``0},NFX.CodeAnalysis.LazyFSMPredicate{``0}[])">
            <summary>
            Loops until token pattern match succeeds, considering only primary language tokens.
            Keeps state machine if match was found on the first matching token
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopUntilMatch``1(NFX.CodeAnalysis.LazyFSMState{``0},System.Boolean,NFX.CodeAnalysis.LazyFSMPredicate{``0}[])">
            <summary>
            Loops until token pattern match succeeds, conditionaly considering only primary language tokens.
            Keeps state machine if match was found on the first matching token
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.PatternSearch.LoopUntilAfterMatch``1(NFX.CodeAnalysis.LazyFSMState{``0},NFX.CodeAnalysis.LazyFSMPredicate{``0}[])">
            <summary>
            Loops until token pattern match succeeds.
            This method matches using the same primary token filter as the parent match.
            Keeps state machine if match was found on the first token that follows the match
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.LazyFSMState`1">
            <summary>
            Represents a state object for Lazy Finate State Machine that enumerates tokes from IEnumerable(Token)
             and does not support a notion of index addressing
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.LazyFSMState`1.Get``1(System.Object)">
            <summary>
            Gets typecasted value for a key
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.LazyFSMState`1.CurrentToken">
            <summary>
            Returns token that machine is at now
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.LazyFSMState`1.OnlyPrimary">
            <summary>
            Returns true when state machine only considers language-primary tokens
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.LazyFSMState`1.CurrentTokenIndex">
            <summary>
            Returns an index for token that machine is on now
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.LazyFSMState`1.PatternTokenLength">
            <summary>
            Returns how many tokens have been covered by the current match pattern, i.e. if we loop until first int literal,
             this property will count how many tokens have been looped + int literal itself
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.LazyFSMState`1.Tokens">
            <summary>
            Returns token enumerable that analysis is performed on
            </summary>
        </member>
        <member name="T:NFX.DataAccess.NOPDataStore">
            <summary>
            Represents data store that does not do anything
            </summary>
        </member>
        <member name="P:NFX.DataAccess.NOPDataStore.Instance">
            <summary>
            Returns a singlelton instance of the data store that does not do anything
            </summary>
        </member>
        <member name="T:NFX.DebugAction">
            <summary>
            Specifies how to handle Assertion and other failures
            </summary>
        </member>
        <member name="F:NFX.DebugAction.Default">
            <summary>Default to the value of Debugging.DefaultDebugAction</summary>
        </member>
        <member name="F:NFX.DebugAction.Throw">
            <summary>Throw exception</summary>
        </member>
        <member name="F:NFX.DebugAction.Log">
            <summary>Write message to log</summary>
        </member>
        <member name="F:NFX.DebugAction.ThrowAndLog">
            <summary>Shortcut for throwing exception and writing a message to log</summary>
        </member>
        <member name="T:NFX.Debug">
            <summary>
            Facilitates debugging tasks enabled by DEBUG conditional define
            </summary>
        </member>
        <member name="M:NFX.Debug.Write(System.Func{System.String},NFX.Log.MessageType,System.Nullable{System.Guid})">
            <summary>
            A simplified method for tracing that doesn't evaluate text generation function
            if tracing is disabled by configuration
            </summary>
            <param name="textFunc">Functor to evaluate to get the text sent to logger</param>
            <param name="type">Message type to log</param>
            <param name="correlationContext">Optional correlation token to relate log entries</param>
        </member>
        <member name="T:NFX.Trace">
            <summary>
            Facilitates debugging tasks enabled by TRACE conditional define
            </summary>
        </member>
        <member name="M:NFX.Trace.Write(System.Func{System.String},NFX.Log.MessageType,System.Nullable{System.Guid})">
            <summary>
            A simplified method for tracing that doesn't evaluate text generation function
            if tracing is disabled by configuration
            </summary>
            <param name="textFunc">Functor to evaluate to get the text sent to logger</param>
            <param name="type">Message type to log</param>
            <param name="correlationContext">Optional correlation token to relate log entries</param>
        </member>
        <member name="M:NFX.Trace.Write``1(System.Func{``0,System.String},``0,NFX.Log.MessageType,System.Nullable{System.Guid})">
            <summary>
            A simplified method for tracing that doesn't evaluate text generation function
            if tracing is disabled by configuration. It takes context argument that can be passed to the
            text-generating textFunc functor
            </summary>
            <param name="textFunc">Functor to evaluate to get the text sent to logger</param>
            <param name="ctx">Context object</param>
            <param name="type">Message type to log</param>
            <param name="correlationContext">Optional correlation token to relate log entries</param>
        </member>
        <member name="T:NFX.Debugging">
            <summary>
            Facilitates debugging tasks that do not depend on any conditional defines
            </summary>
        </member>
        <member name="P:NFX.Debugging.DefaultDebugAction">
            <summary>
            Returns the global default setting, and optionally
            reads default debug action from global application's configuration
            if its value is DefaultFromConfig (default). Application can override
            this value at startup in order to avoid dynamic configuration lookups
            on every call
            </summary>
        </member>
        <member name="P:NFX.Debugging.TraceDisabled">
            <summary>
            Controls wether to send Trace.Write() and Debug.Write() output to LogService
            </summary>
        </member>
        <member name="T:NFX.DumpFormat">
            <summary>
            Format of the String Dump
            </summary>
        </member>
        <member name="F:NFX.DumpFormat.Binary">
            <summary>
            Perform no conversion - data copied as is
            </summary>
        </member>
        <member name="F:NFX.DumpFormat.Decimal">
            <summary>
            Decimal string representation. E.g. "&lt;&lt;39, 16, 25, ...>>"
            </summary>
        </member>
        <member name="F:NFX.DumpFormat.Hex">
            <summary>
            Hex string representation. E.g. "A1 B9 16 ..."
            </summary>
        </member>
        <member name="F:NFX.DumpFormat.Printable">
            <summary>
            Human readable string representation. E.g. "...Test 123\n..."
            </summary>
        </member>
        <member name="T:NFX.Environment.ConfigMacroContextAttribute">
            <summary>
            Decorates classes or structs that act as a context object for macro evaluation - passed as context parameter to MacroRunner.Run(...context) method
            </summary>
        </member>
        <member name="T:NFX.Environment.ConfigAttribute">
            <summary>
            Specifies how to apply configuration values to classes/fields/props
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigAttribute.#ctor">
            <summary>
            Decorates members so that path is defaulted from member's name with prepended '$' attribute symbol
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigAttribute.#ctor(System.String)">
            <summary>
            Decorates members that will be configured from supplied path
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigAttribute.#ctor(System.String,System.Object)">
            <summary>
            Decorates members that will be configured from supplied path and defaulted in case
             the supplied path does not resolve to existing node
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigAttribute.Apply``1(``0,NFX.Environment.IConfigSectionNode)">
            <summary>
            Applies config values to fields/properties as specified by config attributes
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigAttribute.Apply(System.Object,NFX.Environment.IConfigSectionNode)">
            <summary>
            Applies config values to fields/properties as specified by config attributes
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigAttribute.GetConfigPathsForMember(System.Reflection.MemberInfo)">
            <summary>
            Generates 2 attribute paths for named member. This first path is just the member name converted to lower case.
            The seconfd path is "OR"ed with the first one and is taken from member name where all case transitions are prefixed with "-".
            For private fields 'm_' and 's_' prefixes are removed
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigAttribute.Path">
            <summary>
            String path of configuration source i.e. 'log/machine-name'.
            Path is relative to item root
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigAttribute.Default">
            <summary>
            Default value used when configuration does not specify any other value
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigAttribute.Verbatim">
            <summary>
            Takes verbatim value if true
            </summary>
        </member>
        <member name="T:NFX.Environment.ConfigException">
            <summary>
            Configuration-related exception
            </summary>
        </member>
        <member name="T:NFX.Environment.BehaviorApplyException">
            <summary>
            Thrown by Behavior class to indicate behavior apply error
            </summary>
        </member>
        <member name="T:NFX.Environment.LaconicConfiguration">
             <summary>
             Provides implementation of configuration based on Laconic content format
             </summary>
             <example>
             Example Laconic Configuration Content:
            
             nfx //comments are allowed
             {
               log-root=$"c:\nfx\"
               log-csv="NFX.Log.Destinations.CSVFileDestination, NFX"
               debug-default-action="Log,Throw"
            
               log
               {
                 name="Logger"
            
                 destination
                 {
                   type=$(/$log-csv)
                   name="WinFormsTest Log"//strings in dblquotes
                   path=$(/$log-root)
                   name-time-format='yyyyMMdd'//strings in snglquotes
                   generate-failover-msg=false
                 }
               }
               /* multiline comments
                data-store {type="NFX.RecordModel.DataAccess.MongoDB.MongoDBModelDataStore, NFX.MongoDB"
                            connect-string="mongodb://localhost"
                            db-name="test"}
               */
             }
             </example>
        </member>
        <member name="M:NFX.Environment.LaconicConfiguration.#ctor">
            <summary>
            Creates an instance of a new configuration not bound to any laconfig file
            </summary>
        </member>
        <member name="M:NFX.Environment.LaconicConfiguration.#ctor(System.String)">
            <summary>
            Creates an isntance of the new configuration and reads contents from a laconfig file
            </summary>
        </member>
        <member name="M:NFX.Environment.LaconicConfiguration.CreateFromString(System.String)">
            <summary>
            Creates an instance of configuration initialized from laconfig passed as string
            </summary>
        </member>
        <member name="M:NFX.Environment.LaconicConfiguration.SaveAs(System.String)">
            <summary>
            Saves configuration into a file
            </summary>
        </member>
        <member name="M:NFX.Environment.LaconicConfiguration.SaveAs(System.String,NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions)">
            <summary>
            Saves configuration into a file
            </summary>
        </member>
        <member name="M:NFX.Environment.LaconicConfiguration.SaveToString(NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions)">
            <summary>
            Saves laconic configuration into string in Laconfig format and returns it
            </summary>
        </member>
        <member name="T:NFX.Environment.IMacroRunner">
            <summary>
            Represents an entity that runs config var macros
            </summary>
        </member>
        <member name="M:NFX.Environment.IMacroRunner.Run(NFX.Environment.IConfigSectionNode,System.String,System.String,NFX.Environment.IConfigSectionNode,System.Object)">
            <summary>
            Runs macro
            </summary>
        </member>
        <member name="T:NFX.Environment.DefaultMacroRunner">
            <summary>
            Provides default implementation for configuration variable macros.
            NOTE: When serialized a new instance is created which will not equal by reference to static.Instance property
            </summary>
        </member>
        <member name="M:NFX.Environment.DefaultMacroRunner.GetValueAs(System.String,System.String,System.String,System.String)">
            <summary>
            Returns a string value converted to desired type with optional default and format
            </summary>
            <param name="value">String value to convert</param>
            <param name="type">A type to convert string value into i.e. "decimal"</param>
            <param name="dflt">Default value which is used when conversion of original value can not be made</param>
            <param name="fmt">Format string that formats the converted value. Example: 'Goods: {0}'. The '0' index is the value</param>
            <returns>Converted value to desired type then back to string, using optional formatting and default if conversion did not succeed</returns>
        </member>
        <member name="P:NFX.Environment.DefaultMacroRunner.Instance">
            <summary>
            Returns a singleton class instance
            </summary>
        </member>
        <member name="T:NFX.Environment.IEnvironmentVariableResolver">
            <summary>
            Represents an entity that can resolve variables
            </summary>
        </member>
        <member name="M:NFX.Environment.IEnvironmentVariableResolver.ResolveEnvironmentVariable(System.String,System.String@)">
            <summary>
            Turns named variable into its value or null
            </summary>
        </member>
        <member name="T:NFX.Environment.OSEnvironmentVariableResolver">
            <summary>
            Resolves variables using Windows environment variables.
            NOTE: When serialized a new instance is created which will not equal by reference to static.Instance property
            </summary>
        </member>
        <member name="P:NFX.Environment.OSEnvironmentVariableResolver.Instance">
            <summary>
            Returns a singleton class instance
            </summary>
        </member>
        <member name="T:NFX.Environment.Vars">
            <summary>
            Allows for simple ad-hoc environment var passing to configuration
            </summary>
        </member>
        <member name="T:NFX.Environment.OverrideSpec">
            <summary>
            Override specifications that dictate what to do when another node supplies entity with the same name
            </summary>
        </member>
        <member name="F:NFX.Environment.OverrideSpec.All">
            <summary>
            Override everything: attributes, sections, and value
            </summary>
        </member>
        <member name="F:NFX.Environment.OverrideSpec.Attributes">
            <summary>
            Ovveride attributes only
            </summary>
        </member>
        <member name="F:NFX.Environment.OverrideSpec.Sections">
            <summary>
            Override sections only
            </summary>
        </member>
        <member name="F:NFX.Environment.OverrideSpec.Replace">
            <summary>
            Completely replace node
            </summary>
        </member>
        <member name="F:NFX.Environment.OverrideSpec.Stop">
            <summary>
            Stop override at this level
            </summary>
        </member>
        <member name="F:NFX.Environment.OverrideSpec.Fail">
            <summary>
            Fail the process
            </summary>
        </member>
        <member name="T:NFX.Environment.NodeOverrideRules">
            <summary>
            Contains node override rule definitions such as override specifier names and values.
            This class is used for merging/override of configurations/nodes
            </summary>
        </member>
        <member name="M:NFX.Environment.NodeOverrideRules.StringToOverrideSpec(System.String)">
            <summary>
            Tries to convert a string to OverrideSpec enum. If string is null or empty then "All" is returned, otherwise exception is thrown if
             the value does not match any of the expected values. The comparison is case-insensitive
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.Default">
            <summary>
            Default instance that uses default names
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.OverrideAttrName">
            <summary>
            Provides name for override attribute
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.OverrideValue_Attributes">
            <summary>
            Provides value for attributes-only override
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.OverrideValue_Sections">
            <summary>
            Provides value for sections-only override
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.OverrideValue_All">
            <summary>
            Provides value for all(sections and attributes) override
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.OverrideValue_Replace">
            <summary>
            Provides value for replace override - when overriding section replaces base completely
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.OverrideValue_Stop">
            <summary>
            Provides value for stop override - so no section can modify anything in this one
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.OverrideValue_Fail">
            <summary>
            Provides value for fail override - an exception is thrown when a child tries to override this section
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.SectionMatchAttrName">
            <summary>
            Provides attribute name for matching of multiple sections with the same name, i.e. a logger may have many 'destinations'
            subnodes each with different 'name' attribute
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.AppendSectionsWithoutMatchAttr">
            <summary>
            When true will APPEND sections not having SectionMatchAttrName defined,
            otherwise matches section names by SectionMatchAttrName
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.SectionClearName">
            <summary>
            Provides a name for clear section - when present it deletes all existing subsections
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.AttributeClearName">
            <summary>
            Provides a name for clear section - when present it deletes all existing attributes
            </summary>
        </member>
        <member name="P:NFX.Environment.NodeOverrideRules.SectionDeleteName">
            <summary>
            Provides a name for clear section - when present it deletes all existing attributes
            </summary>
        </member>
        <member name="T:NFX.Environment.ScriptRunner">
            <summary>
            Executes configuration scripts which are embedded in configuration
            </summary>
        </member>
        <member name="M:NFX.Environment.ScriptRunner.Execute(NFX.Environment.Configuration,NFX.Environment.Configuration)">
            <summary>
            Runs script on the configuration
            </summary>
        </member>
        <member name="P:NFX.Environment.ScriptRunner.KeywordBLOCK">
            <summary>
            Gets/sets BLOCK keyword - used for unconditional script evaluation block
            </summary>
        </member>
        <member name="P:NFX.Environment.ScriptRunner.KeywordIF">
            <summary>
            Gets/sets IF keyword - used for conditional block
            </summary>
        </member>
        <member name="P:NFX.Environment.ScriptRunner.KeywordELSE">
            <summary>
            Gets/sets ELSE keyword - used for IF-complementary conditional block
            </summary>
        </member>
        <member name="P:NFX.Environment.ScriptRunner.KeywordLOOP">
            <summary>
            Gets/sets LOOP keyword - used for repetition block
            </summary>
        </member>
        <member name="P:NFX.Environment.ScriptRunner.KeywordSET">
            <summary>
            Gets/sets SET keyword - used for variable assignment statement
            </summary>
        </member>
        <member name="P:NFX.Environment.ScriptRunner.KeywordCALL">
            <summary>
            Gets/sets CALL keyword - used for sub-routine invocation
            </summary>
        </member>
        <member name="P:NFX.Environment.ScriptRunner.AttributeScriptOnly">
            <summary>
            Gets/sets attribute name that indicates that marked entity should not be brough over into script output target
            </summary>
        </member>
        <member name="P:NFX.Environment.ScriptRunner.TimeoutMs">
            <summary>
            Gets/sets script execution timeout
            </summary>
        </member>
        <member name="T:NFX.Glue.GluedAttribute">
            <summary>
            Decorates interfaces that represent glued contract points
            </summary>
        </member>
        <member name="T:NFX.Glue.ArgsMarshallingAttribute">
            <summary>
            Decorates methods stipulating type of RequestMsg-derivative used for method call arguments marshalling
            </summary>
        </member>
        <member name="F:NFX.Glue.ArgsMarshallingAttribute.RequestMsgType">
            <summary>
            Thr type of RequestMsg-derivative used to marshall the request arguments
            </summary>
        </member>
        <member name="T:NFX.Glue.OneWayAttribute">
            <summary>
            Decorates methods that do not generate response message after execution.
            They must return void and if exception occurs it is not reported to the caller
            </summary>
        </member>
        <member name="T:NFX.Glue.ConstructorAttribute">
            <summary>
            Decorates methods that initialize instance of the server class and retain class instance
             in the server runtime
            </summary>
        </member>
        <member name="T:NFX.Glue.DestructorAttribute">
            <summary>
            Decorates methods that finalize instance of the server class and release class instance
             in the server runtime
            </summary>
        </member>
        <member name="T:NFX.Glue.ServerInstanceMode">
            <summary>
            Denotes server instance modes - how server instances relate to calls
            </summary>
        </member>
        <member name="F:NFX.Glue.ServerInstanceMode.Singleton">
            <summary>
            Indicates that the same single process-wide instance will serve all request for particular contract.
            The server MUST be thread-safe
            </summary>
        </member>
        <member name="F:NFX.Glue.ServerInstanceMode.PerCall">
            <summary>
            Indicates that every request for a particular contract will create an instance which will live until the method exits
            </summary>
        </member>
        <member name="F:NFX.Glue.ServerInstanceMode.Stateful">
            <summary>
            Indicates that the instance is stateful and will live between a call to
             [Constructor]-decorated method and [Destructor]-decorated method, or until timeout interval has passed.
            The implementation may or may not be thread-safe, if it is, then [ThreadSafe] attribute may be used to avoid instance locking
            </summary>
        </member>
        <member name="F:NFX.Glue.ServerInstanceMode.AutoConstructedStateful">
            <summary>
            Indicates that the instance is stateful and will live between a call to
             either [Constructor]-decorated method or first call to any method, and [Destructor]-decorated method or until timeout interval has passed.
            The implementation may or may not be thread-safe, if it is then [ThreadSafe] attribute may be used to avoid instance locking.
            This mode is simiar to 'Stateful' but does not require the caller to explicitly call the [Constructor]-decorated method first
            </summary>
        </member>
        <member name="T:NFX.Glue.LifeCycleAttribute">
            <summary>
            Specifies the instance mode and timeout values for server classes that implement the decorated contract.
            If server class does not support state then timeout is ignored
            </summary>
        </member>
        <member name="T:NFX.Glue.ThreadSafeAttribute">
            <summary>
            Indicates that server instance should not be lock()-ed by Glue handler because it is implemented in a thread-safe way.
            This attribute has no effect for Glue servers that are not [LifeCycle(Stateful)], because they are never locked.
            Singleton servers must be thread-safe by definition so this attribute is not needed for Singleton servers.
            If the server is implemented in a thread-safe way, then addition of this attribute may give 15-30% performance boost
             from Glue runtime when many parallel requests are trying to work with the same instance, however this benefit
             may be nullified by inefficient user locking code within server implementation. Leaving this attribute out is safer
            </summary>
        </member>
        <member name="T:NFX.Glue.AuthenticationSupportAttribute">
            <summary>
            Indicates that contract supports authentication using AuthenticationHeader.
            When header is passed then Glue server will use its data to set user context through Application.SecurityManager.
            If this attribute not set then Glue runtime will ignore AuthenticationHeader
            </summary>
        </member>
        <member name="T:NFX.Glue.IMsgInspector">
            <summary>
            Denotes an entity that can inspect messages
            </summary>
        </member>
        <member name="T:NFX.Glue.IClientMsgInspector">
            <summary>
            Inspects messages on the client side. ClientInspectors may be registered on ClientEndPoint, Binding or Glue levels
            </summary>
        </member>
        <member name="M:NFX.Glue.IClientMsgInspector.ClientDispatchCall(NFX.Glue.ClientEndPoint,NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Intercepts client call during dispatch and optionaly allows to change the RequestMsg
            </summary>
        </member>
        <member name="M:NFX.Glue.IClientMsgInspector.ClientDeliverResponse(NFX.Glue.CallSlot,NFX.Glue.Protocol.ResponseMsg)">
            <summary>
            Intercepts server response message before it arrives into CallSlot and optionaly allows to change it
            </summary>
        </member>
        <member name="T:NFX.Glue.IServerMsgInspector">
            <summary>
            Inspects messages on the server side. ServerInspectors may be registered on ServerEndPoint, Binding or Glue levels
            </summary>
        </member>
        <member name="M:NFX.Glue.IServerMsgInspector.ServerDispatchRequest(NFX.Glue.ServerEndPoint,NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Intercepts RequestMsg that arrived from particular ServerEndPoint and optionaly allows to change it
            </summary>
        </member>
        <member name="M:NFX.Glue.IServerMsgInspector.ServerReturnResponse(NFX.Glue.ServerEndPoint,NFX.Glue.Protocol.RequestMsg,NFX.Glue.Protocol.ResponseMsg)">
            <summary>
            Intercepts ResponseMsg generated by server before it is sent to client and optionaly allows to change it
            </summary>
        </member>
        <member name="T:NFX.Glue.MsgInspectorConfigurator">
            <summary>
            Provides general configuration reading logic for message inspectors
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.INetInstrument">
            <summary>
            Network operations (i.e. sockets)
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IIOInstrumentClass">
            <summary>
            IO-related operations
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IErrorInstrument">
            <summary>
            Data of this class indicates a definite abnormality, however the system is going to continue functioning
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IProblemClass">
            <summary>
            A class of problem that decorate instrument represents
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.Consts">
            <summary>
            Constants common to Native/Socket-based family of technologies
            </summary>
        </member>
        <member name="F:NFX.Glue.Native.Consts.PACKET_DELIMITER_LENGTH">
            <summary>
            Size of the packet delimiting field
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.InProcBinding">
            <summary>
            Provides synchronous communication pattern based on in-memory message exchange without serialization.
            This binding is usable for interconnection between NFX-native components in the same app domain
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.InProcBinding.OperationFlow">
            <summary>
            InProc binding is synchronous by definition
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.InProcClientTransport">
            <summary>
            Provides client-side functionality for synchronous communication pattern based on
             in-memory message exchange without serialization
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.InProcServerTransport">
            <summary>
            Provides server-side functionality for synchronous communication pattern based on
             in-memory message exchange without serialization
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.AuthenticationHeader">
            <summary>
            Marshalls user authentication information
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.Header">
            <summary>
            Represents a header base - custom headers must inherit from this class
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.AuthenticationHeader.#ctor(NFX.Security.Credentials)">
            <summary>
            Inits header with Credentials instance.
            Note: passing IDPasswordCredentials over public wire is not a good practice,
            pass AuthenticationToken instead
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.AuthenticationHeader.Token">
            <summary>
            Returns AuthenticationToken
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.AuthenticationHeader.Credentials">
            <summary>
            Returns Credentials
            </summary>
        </member>
        <member name="T:NFX.Glue.ServerCallContext">
            <summary>
            Provides access to server call context. Use to access Headers
            </summary>
        </member>
        <member name="M:NFX.Glue.ServerCallContext.__SetThreadLevelContext(NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Internal framework-only method to bind thread-level context
            </summary>
        </member>
        <member name="M:NFX.Glue.ServerCallContext.__ResetThreadLevelContext">
            <summary>
            Internal framework-only method to clear thread-level context
            </summary>
        </member>
        <member name="P:NFX.Glue.ServerCallContext.Request">
            <summary>
            Returns RequestMsg which is being processed. Access incoming headers through Request.Headers
            </summary>
        </member>
        <member name="P:NFX.Glue.ServerCallContext.ResponseHeaders">
            <summary>
            Returns Headers instance that will be appended to response
            </summary>
        </member>
        <member name="T:NFX.Glue.ServerEndPoint">
            <summary>
            Represents a server endpoint that accepts client requests. This is a sealed class
            </summary>
        </member>
        <member name="F:NFX.Glue.ServerEndPoint.m_ContractImplementers">
            <summary>
            INTERNAL! Maps ContractType -> ServerImplementing class. This is a cache used not to recompute everything on every call
            </summary>
        </member>
        <member name="M:NFX.Glue.ServerEndPoint.Open">
            <summary>
            Opens endpoint by allocating transports (if necessary).
            ServerEndpoint can be Close() or Dispose() after it was open
            </summary>
        </member>
        <member name="P:NFX.Glue.ServerEndPoint.Name">
            <summary>
            Returns name of the endpoint. Named endpoints must be unique in the context, if name was not supplied in .ctor then it is auto-generated
            </summary>
        </member>
        <member name="P:NFX.Glue.ServerEndPoint.Transport">
            <summary>
            Returns server transport that services this endpoint
            </summary>
        </member>
        <member name="P:NFX.Glue.ServerEndPoint.MsgInspectors">
            <summary>
            Returns server message inspectors for this instance
            </summary>
        </member>
        <member name="P:NFX.Glue.ServerEndPoint.ContractServers">
            <summary>
            Returns types that implement/serve contracts that this endpoint accepts
            </summary>
        </member>
        <member name="P:NFX.Glue.ServerEndPoint.IsOpen">
            <summary>
            Indicates whether endpoint is open and is accepting incoming requests
            </summary>
        </member>
        <member name="T:NFX.Registry`1">
            <summary>
            Represents a thread-safe registry of T. This class is efficient for concurrent read access and is not designed for cases when frequent modifications happen.
            It is ideal for lookup of named instances (such as components) that have much longer time span than components that look them up.
            Registry performs lock-free lookup which speeds-up many concurrent operations that need to map names into objects.
            The enumeration over registry makes a snapshot of its data, hence a registry may be modified by other threads while being enumerated.
            </summary>
        </member>
        <member name="T:NFX.IRegistry`1">
            <summary>
            Provides read-only named object lookup capabilities
            </summary>
        </member>
        <member name="M:NFX.IRegistry`1.ContainsName(System.String)">
            <summary>
            Returns true if when this registry contains the specified name
            </summary>
        </member>
        <member name="P:NFX.IRegistry`1.Item(System.String)">
            <summary>
            Returns item by name or default item (such as null) if the named instance could not be found
            </summary>
        </member>
        <member name="P:NFX.IRegistry`1.IsCaseSensitive">
            <summary>
            Returns true if the instance differentiates names by case
            </summary>
        </member>
        <member name="P:NFX.IRegistry`1.Count">
            <summary>
            Returns the count of items registered in this instance
            </summary>
        </member>
        <member name="M:NFX.Registry`1.Register(`0)">
            <summary>
            Registers item and returns true if it was registered, false if this named instance already existed in the list
            </summary>
        </member>
        <member name="M:NFX.Registry`1.RegisterOrReplace(`0)">
            <summary>
            Registers item and returns true if it was registered, false if this named instance already existed and was replaced
            </summary>
        </member>
        <member name="M:NFX.Registry`1.RegisterOrReplace(`0,`0@)">
            <summary>
            Registers item and returns true if it was registered, false if this named instance already existed and was replaced
            </summary>
        </member>
        <member name="M:NFX.Registry`1.Unregister(`0)">
            <summary>
            Unregisters item and returns true if it was unregistered, false if it did not exist
            </summary>
        </member>
        <member name="M:NFX.Registry`1.Unregister(System.String)">
            <summary>
            Unregisters item by name and returns true if it was unregistered, false if it did not exist
            </summary>
        </member>
        <member name="M:NFX.Registry`1.Clear">
            <summary>
            Deletes all items from registry
            </summary>
        </member>
        <member name="M:NFX.Registry`1.GetOrRegister``1(System.String,System.Func{``0,`0},``0)">
            <summary>
            Tries to find an item by name, and returns it if it is found, otherwise calls a factory function supplying context value and registers the obtained
             new item. The first lookup is performed in a lock-free way and if an item is found then it is immediately returned.
             The second check and factory call operation is performed atomically under the lock to ensure consistency
            </summary>
        </member>
        <member name="M:NFX.Registry`1.GetOrRegister``1(System.String,System.Func{``0,`0},``0,System.Boolean@)">
            <summary>
            Tries to find an item by name, and returns it if it is found, otherwise calls a factory function supplying context value and registers the obtained
             new item. The first lookup is performed in a lock-free way and if an item is found then it is immediately returned.
             The second check and factory call operation is performed atomically under the lock to ensure consistency
            </summary>
        </member>
        <member name="P:NFX.Registry`1.IsCaseSensitive">
            <summary>
            Returns true if the instance differentiates names by case
            </summary>
        </member>
        <member name="P:NFX.Registry`1.Item(System.String)">
            <summary>
            Returns a value by name or null if not found
            </summary>
        </member>
        <member name="P:NFX.Registry`1.Count">
            <summary>
            Returns the number of entries in the registry
            </summary>
        </member>
        <member name="T:NFX.Glue.Implementation.Calls">
            <summary>
            Provides thread-safe CallSlot registry where items can be gotten and removed by request ID guid
            </summary>
        </member>
        <member name="M:NFX.Glue.Implementation.Calls.Put(NFX.Glue.CallSlot)">
            <summary>
            Tries to pur CallSlot instance in the internal list if instance with same ID is not already in the list
            </summary>
        </member>
        <member name="M:NFX.Glue.Implementation.Calls.TryGetAndRemove(NFX.FID)">
            <summary>
            Tries to get, return and remove CallSlot instance by its RequestID from the list.
            Returns null if CallSlot with such an id does not exist and nothing was removed
            </summary>
        </member>
        <member name="M:NFX.Glue.Implementation.Calls.PurgeTimedOutSlots">
            <summary>
            Deletes CallSlot entries that have already timed-out. Returns count of slots that got removed.
            This method is thread-safe but may take some time as it has to visit all buckets.
            Should be called by Glue manager not frequently (i.e. every few minutes)
            </summary>
        </member>
        <member name="T:NFX.Glue.Implementation.ServerHandler">
            <summary>
            Executes server work - handles requests synchronously or asynchronously.
            </summary>
        </member>
        <member name="F:NFX.Glue.Implementation.ServerHandler.GLUE_CTOR_SIGNATURE">
            <summary>
            Specifies special signature for glue-specific constructors.
            If a server implementer class implements a public ctor with this signature then it will be called
            instead of default .ctor.
            This is useful when server class needs to distinguish Glue allocations from de-serializations and others
            </summary>
        </member>
        <member name="M:NFX.Glue.Implementation.ServerHandler.HandleRequestAsynchronously(NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Handles request in the context of ServerHandler thread, replying back to result queue
            </summary>
        </member>
        <member name="M:NFX.Glue.Implementation.ServerHandler.HandleRequestSynchronously(NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Handles request synchronously in the context of the calling thread. Returns NULL for one-way calls
            </summary>
        </member>
        <member name="M:NFX.Glue.Implementation.ServerHandler.HandleRequestFailure(NFX.FID,System.Boolean,System.Exception,System.Object)">
            <summary>
            Handles request synchronously in the context of the calling thread. Returns NULL for one-way calls
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.SyncBinding">
            <summary>
            Provides synchronous communication pattern based on TCP blocking sockets and Slim serializer
            for maximum serialization performance and lowest latency.
            This binding is usable for interconnection between NFX-native components on LANs (i.e. server clusters)
            in scenarios when low latency is more important than total call invocation throughput
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.SyncBinding.OperationFlow">
            <summary>
            Sync binding is synchronous by definition
            </summary>
        </member>
        <member name="P:NFX.Glue.Native.SyncBinding.MaxMsgSize">
            <summary>
            Imposes a limit on maximum message size in bytes
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.SyncClientTransport">
            <summary>
            Provides client-side functionality for synchronous communication pattern based on TCP blocking sockets and Slim serializer
            for maximum serialization performance and lowest latency.
            The SyncBinding is usable for interconnection between NFX-native components on LANs (i.e. server clusters) in scenarios when
             low latency is more important than total call invocation throughput
            </summary>
        </member>
        <member name="T:NFX.Glue.Native.SyncServerTransport">
            <summary>
            Provides server-side functionality for synchronous communication pattern based on TCP blocking sockets and Slim serializer
            for maximum serialization performance and lowest latency.
            The SyncBinding is usable for interconnection between NFX-native components on LANs (i.e. server clusters) in scenarios when
             low latency is more important than total call invocation throughput.
            SyncServerTransport uses dedicated thread for request processing and is not scalable beyond a few hundred connections by design,
             however it provides low latency benefit
            </summary>
        </member>
        <member name="M:NFX.Glue.Native.SyncServerTransport.#ctor(NFX.Glue.Native.SyncBinding,NFX.Glue.ServerEndPoint,System.Net.IPAddress,System.Int32)">
            <summary>
            Allocates a listener transport
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.CallOptions">
            <summary>
            Specifies additional options for call like timeouts
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.HashUtils">
            <summary>
            Hash helpers used by Glue protocol for type resolution
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.HashUtils.StringIDHash(System.String)">
            <summary>
            Converts string identifier into uint64 stable hash that does not depend on a platform.
            This functions optimized for hashing identifiers/type names
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.HashUtils.TypeHash(System.Type)">
            <summary>
            Returns stable ulong hash for a type that does not depend on a platform
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.TypeSpec">
            <summary>
            Type specification for marshalling contract types between glued peers
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.TypeSpec.GetSpecifiedType">
            <summary>
            Returns the type or throws if it can't be found
            </summary>
            <returns>The type or throws exception if actual type could not be gotten</returns>
        </member>
        <member name="T:NFX.Glue.Protocol.MethodSpec">
            <summary>
            Method specification for marshalling method information between glued peers
            </summary>
        </member>
        <member name="T:NFX.Glue.CallReactor">
            <summary>
            Facilititates execution of asynchronous client calls and their corresponding callback functions.
            This class introduces callback execution latency and is handy for cases where eventual event flow need to execute regardless of timing.
            The latency depends on other callback implementation as the reactor services all calls from a single thread
            </summary>
        </member>
        <member name="M:NFX.Glue.CallReactor.Wait">
            <summary>
            Blocks until all calls managed by this reactor instance have ended
            </summary>
        </member>
        <member name="M:NFX.Glue.CallReactor.WaitAll(System.Collections.Generic.IEnumerable{NFX.Glue.CallReactor})">
            <summary>
            Waits for all reactors to finish
            </summary>
        </member>
        <member name="P:NFX.Glue.CallReactor.Calls">
            <summary>
            Enumerates all calls that this reactor instance services
            </summary>
        </member>
        <member name="P:NFX.Glue.CallReactor.Context">
            <summary>
            Gets/sets reactor-wide context which is originally supplied in .ctor or null
            </summary>
        </member>
        <member name="P:NFX.Glue.CallReactor.Finished">
            <summary>
            Retunrs true when all calls have finished processing
            </summary>
        </member>
        <member name="P:NFX.Glue.CallReactor.Exception">
            <summary>
            Returns an exception surfaced during reactor operation or null
            </summary>
        </member>
        <member name="T:NFX.Glue.Call">
            <summary>
            Describes a flow of events originating from a Glue client call
            </summary>
        </member>
        <member name="P:NFX.Glue.Call.Reactor">
            <summary>
            Returns the reactor that services this call
            </summary>
        </member>
        <member name="P:NFX.Glue.Call.CallSlot">
            <summary>
            Returns CallSlot that represents this call
            </summary>
        </member>
        <member name="P:NFX.Glue.Call.Context">
            <summary>
            Retruns call-dependent context object if one was supplied in call .ctor, or null
            </summary>
        </member>
        <member name="P:NFX.Glue.Call.Ended">
            <summary>
            Returns true when call has ended with all attached events/callbacks
            </summary>
        </member>
        <member name="P:NFX.Glue.Call.CallbackException">
            <summary>
            Returns exception that was thrown from callback or null if no exception happened
            </summary>
        </member>
        <member name="T:NFX.Glue.LogSrc">
            <summary>
            Logging sources - client, server, any
            </summary>
        </member>
        <member name="T:NFX.Glue.CallStatus">
            <summary>
            Stipulates codes returned for contract calls
            </summary>
        </member>
        <member name="F:NFX.Glue.CallStatus.Dispatched">
            <summary>
            Indicates that call was sucessfully queued/dispatched for processing by remote server
            </summary>
        </member>
        <member name="F:NFX.Glue.CallStatus.DispatchError">
            <summary>
            Indicates that operation failed locally because the communication stack is overloaded or some other internal error occured
            </summary>
        </member>
        <member name="F:NFX.Glue.CallStatus.Timeout">
            <summary>
            Indicates that operation timed out before it could be completed
            </summary>
        </member>
        <member name="F:NFX.Glue.CallStatus.ResponseOK">
            <summary>
            Indicates that response came with payload that does not contain error
            </summary>
        </member>
        <member name="F:NFX.Glue.CallStatus.ResponseError">
            <summary>
            Remote server returned response with exception
            </summary>
        </member>
        <member name="T:NFX.Glue.OperationFlow">
            <summary>
            Stipulates operation flow kind - sync/async
            </summary>
        </member>
        <member name="F:NFX.Glue.OperationFlow.Synchronous">
            <summary>
            Every operation blocks until it is completed or times out
            </summary>
        </member>
        <member name="F:NFX.Glue.OperationFlow.Asynchronous">
            <summary>
            Operations do not block and use reactor to correlate request/responses
            </summary>
        </member>
        <member name="T:NFX.Glue.DumpDetail">
            <summary>
            Message/data dumping detail
            </summary>
        </member>
        <member name="F:NFX.Glue.DumpDetail.None">
            <summary>
            No dumping
            </summary>
        </member>
        <member name="F:NFX.Glue.DumpDetail.Message">
            <summary>
            Message-level dumping
            </summary>
        </member>
        <member name="T:NFX.Glue.Implementation.GlueService">
            <summary>
            Provides default implementation for IGlue. This is the root context for all other glue objects
            </summary>
        </member>
        <member name="T:NFX.Glue.IGlue">
            <summary>
            Represents a contract for Glue - a technology that provides asynchronous distributed component interconnection
            </summary>
        </member>
        <member name="M:NFX.Glue.IGlue.GetNodeBinding(NFX.Glue.Node)">
            <summary>
            Retrieves a binding for node and throws if such binding is not known
            </summary>
        </member>
        <member name="M:NFX.Glue.IGlue.GetNodeBinding(System.String)">
            <summary>
            Retrieves a binding for node and throws if such binding is not known
            </summary>
        </member>
        <member name="P:NFX.Glue.IGlue.Providers">
            <summary>
            Performs provider lookup by name
            </summary>
        </member>
        <member name="P:NFX.Glue.IGlue.Bindings">
            <summary>
            Performs binding lookup by name
            </summary>
        </member>
        <member name="P:NFX.Glue.IGlue.Servers">
            <summary>
            Performs ServerEndPoint lookup by name
            </summary>
        </member>
        <member name="P:NFX.Glue.IGlue.ClientMsgInspectors">
            <summary>
            Registry of inspectors that deal with client-side messages
            </summary>
        </member>
        <member name="P:NFX.Glue.IGlue.ServerMsgInspectors">
            <summary>
            Registry of inspectors that deal with server-side messages
            </summary>
        </member>
        <member name="P:NFX.Glue.IGlue.DefaultDispatchTimeoutMs">
            <summary>
            Specifies default ms timout for call dispatch only
            </summary>
        </member>
        <member name="P:NFX.Glue.IGlue.DefaultTimeoutMs">
            <summary>
            Specified default ms timeout for the calls
            </summary>
        </member>
        <member name="P:NFX.Glue.IGlue.ClientLogLevel">
            <summary>
            Determines how much information should be logged about client-side operations
            </summary>
        </member>
        <member name="P:NFX.Glue.IGlue.ServerLogLevel">
            <summary>
            Determines how much information should be logged about server-side operations
            </summary>
        </member>
        <member name="P:NFX.Glue.IGlue.ServerInstanceLockTimeoutMs">
            <summary>
            Specifies ms timout for non-threadsafe server instance lock
            </summary>
        </member>
        <member name="M:NFX.Glue.IGlueImplementation.ServerDispatchRequest(NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Asynchronously dispatch client request
            </summary>
        </member>
        <member name="M:NFX.Glue.IGlueImplementation.ServerHandleRequest(NFX.Glue.Protocol.RequestMsg)">
            <summary>
            Handle client request synchronously
            </summary>
        </member>
        <member name="M:NFX.Glue.IGlueImplementation.ServerHandleRequestFailure(NFX.FID,System.Boolean,System.Exception,System.Object)">
            <summary>
            Handle failure of client request synchronously
            </summary>
        </member>
        <member name="P:NFX.Glue.Implementation.GlueService.InstrumentationEnabled">
            <summary>
            Implements IInstrumentable
            </summary>
        </member>
        <member name="P:NFX.Glue.Implementation.GlueService.ClientMsgInspectors">
            <summary>
            Returns client message inspectors for this instance
            </summary>
        </member>
        <member name="P:NFX.Glue.Implementation.GlueService.ServerMsgInspectors">
            <summary>
            Returns server message inspectors for this instance
            </summary>
        </member>
        <member name="T:NFX.Glue.Provider">
            <summary>
            Represents a base type for providers - providers are facades for some
            low-level implementation that transports use, for example ZeroMQ.
            </summary>
        </member>
        <member name="T:NFX.Glue.Providers">
            <summary>
            A registry of Provider-derived instances
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.InstrumentViewGroup">
            <summary>
            Denotes interface types that participate in instrumentation data grouping.
            Records that implement several classification interfaces which are decorated by this attribute
            get listed in each decorated interface/group
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IWarningInstrument">
            <summary>
            Data of this class indicates some abnormality in operation, i.e. "LowDisk"
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.ICatastropyInstrument">
            <summary>
            Data of this class indicates an abnormality that will most likely lead to system inability to continue functioning as expected
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IDiskInstrument">
            <summary>
            Disk operations (i.e. % drive free)
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.ILockingInstrument">
            <summary>
            Locking/coordination-related operations
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IDatabaseInstrument">
            <summary>
            DB-related operations
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IWebInstrument">
            <summary>
            Web-related operations
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.ISecurityInstrument">
            <summary>
            Security-related operations
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IGDIDInstrument">
            <summary>
            GDID-related operations
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.ISchedulingInstrument">
            <summary>
            Timer/scheduling-related operations
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IQueueInstrument">
            <summary>
            Queue-related operations
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IWorkerInstrument">
            <summary>
            Worker-related operations i.e. Todo queue
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.ISocialLogic">
            <summary>
            A class of operations related to social operations / business logic
            </summary>
        </member>
        <member name="T:NFX.IOMiscUtils">
            <summary>
            Misc utils for I/O
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadLine(System.String)">
            <summary>
            Reads first line from the string
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.GetURL(System.String,System.Int32)">
            <summary>
            Fetch the content of a given URL.
            </summary>
            <returns>
            Return fetched URL as a string, or null string when resulting status code is not HttpStatusCode.OK.
            </returns>
        </member>
        <member name="M:NFX.IOMiscUtils.CopyStream(System.IO.Stream,System.IO.Stream,System.Boolean)">
            <summary>
            Copies one stream into another using temp buffer
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEInt32(System.Byte[])">
            <summary>
            Reads an integer encoded as big endian from buffer at index 0
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadLEInt32(System.Byte[])">
            <summary>
            Reads an integer encoded as little endian from buffer at index 0
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEUInt32(System.Byte[])">
            <summary>
            Reads an unsigned integer encoded as big endian from buffer at index 0
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadLEUInt32(System.Byte[])">
            <summary>
            Reads an unsigned integer encoded as little endian from buffer at index 0
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEInt32(System.Byte[],System.Int64@)">
            <summary>
            Reads an integer encoded as big endian from buffer at the specified index
            and increments the idx by the number of bytes read
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadLEInt32(System.Byte[],System.Int64@)">
            <summary>
            Reads an integer encoded as little endian from buffer at the specified index
            and increments the idx by the number of bytes read
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEInt32(System.Byte[],System.Int32@)">
            <summary>
            Reads an integer encoded as big endian from buffer at the specified index
            and increments the idx by the number of bytes read
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadLEInt32(System.Byte[],System.Int32@)">
            <summary>
            Reads an integer encoded as little endian from buffer at the specified index
            and increments the idx by the number of bytes read
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEUInt32(System.Byte[],System.Int32@)">
            <summary>
            Reads an unsigned integer encoded as big endian from buffer at the specified index
            and increments the idx by the number of bytes read
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadLEUInt32(System.Byte[],System.Int32@)">
            <summary>
            Reads an unsigned integer encoded as little endian from buffer at the specified index
            and increments the idx by the number of bytes read
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEUInt32(System.Byte[],System.Int64@)">
            <summary>
            Reads an unsigned integer encoded as big endian from buffer at the specified index
            and increments the idx by the number of bytes read
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadLEUInt32(System.Byte[],System.Int64@)">
            <summary>
            Reads an unsigned integer encoded as little endian from buffer at the specified index
            and increments the idx by the number of bytes read
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEUInt64(System.Byte[],System.Int32@)">
            <summary>
            Reads an integer encoded as big endian from buffer at the specified index
            and increments the idx by the number of bytes read
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadLEUInt64(System.Byte[],System.Int32@)">
            <summary>
            Reads an integer encoded as little endian from buffer at the specified index
            and increments the idx by the number of bytes read
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEUInt64(System.Byte[],System.Int32)">
            <summary>
            Reads an integer encoded as big endian from buffer at the specified index
            and increments the idx by the number of bytes read
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadLEUInt64(System.Byte[],System.Int32)">
            <summary>
            Reads an integer encoded as little endian from buffer at the specified index
            and increments the idx by the number of bytes read
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEShort(System.Byte[],System.Int32@)">
            <summary>
            Reads a short encoded as big endian from buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadLEShort(System.Byte[],System.Int32@)">
            <summary>
            Reads a short encoded as little endian from buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEShort(System.IO.Stream)">
            <summary>
            Reads a short encoded as big endian from stream
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadLEShort(System.IO.Stream)">
            <summary>
            Reads a short encoded as little endian from stream
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEUShort(System.IO.Stream)">
            <summary>
            Reads an ushort encoded as big endian from stream
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadLEUShort(System.IO.Stream)">
            <summary>
            Reads an ushort encoded as little endian from stream
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEInt32(System.IO.Stream)">
            <summary>
            Reads an integer encoded as big endian from buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadLEInt32(System.IO.Stream)">
            <summary>
            Reads an integer encoded as little endian from buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadBEUInt64(System.IO.Stream)">
            <summary>
            Reads an integer encoded as big endian from buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.ReadLEUInt64(System.IO.Stream)">
            <summary>
            Reads an integer encoded as little endian from buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEInt32(System.Byte[],System.Int32)">
            <summary>
            Writes an integer encoded as big endian to buffer at index 0
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteLEInt32(System.Byte[],System.Int32)">
            <summary>
            Writes an integer encoded as little endian to buffer at index 0
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEInt32(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes an integer encoded as big endian to buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteLEInt32(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes an integer encoded as little endian to buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEUInt32(System.Byte[],System.UInt32)">
            <summary>
            Writes an unsigned integer encoded as big endian to buffer at index 0
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteLEUInt32(System.Byte[],System.UInt32)">
            <summary>
            Writes an unsigned integer encoded as little endian to buffer at index 0
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEUInt32(System.Byte[],System.Int32,System.UInt32)">
            <summary>
            Writes an unsigned integer encoded as big endian to buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteLEUInt32(System.Byte[],System.Int32,System.UInt32)">
            <summary>
            Writes an unsigned integer encoded as little endian to buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEUInt64(System.Byte[],System.UInt64)">
            <summary>
            Writes an unsigned long integer encoded as big endian to buffer at the beginning
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteLEUInt64(System.Byte[],System.UInt64)">
            <summary>
            Writes an unsigned long integer encoded as little endian to buffer at the beginning
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEUInt64(System.Byte[],System.Int32,System.UInt64)">
            <summary>
            Writes an unsigned long integer encoded as big endian to buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteLEUInt64(System.Byte[],System.Int32,System.UInt64)">
            <summary>
            Writes an unsigned long integer encoded as little endian to buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEShort(System.Byte[],System.Int32,System.Int16)">
            <summary>
            Writes a short encoded as big endian to buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteLEShort(System.Byte[],System.Int32,System.Int16)">
            <summary>
            Writes a short encoded as little endian to buffer at the specified index
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEShort(System.IO.Stream,System.Int16)">
            <summary>
            Writes a short encoded as big endian to the given stream
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteLEShort(System.IO.Stream,System.Int16)">
            <summary>
            Writes a short encoded as little endian to the given stream
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEUShort(System.IO.Stream,System.UInt16)">
            <summary>
            Writes an ushort encoded as big endian to the given stream
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteLEUShort(System.IO.Stream,System.UInt16)">
            <summary>
            Writes an ushort encoded as little endian to the given stream
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEInt32(System.IO.Stream,System.Int32)">
            <summary>
            Writes an integer encoded as big endian to the given stream
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteLEInt32(System.IO.Stream,System.Int32)">
            <summary>
            Writes an integer encoded as little endian to the given stream
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteBEUInt64(System.IO.Stream,System.UInt64)">
            <summary>
            Writes an unsigned long integer encoded as big endian to the given stream
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.WriteLEUInt64(System.IO.Stream,System.UInt64)">
            <summary>
            Writes an unsigned long integer encoded as little endian to the given stream
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.EnsureFileEventuallyDeleted(System.String)">
            <summary>
            Deleted file if it exists - does not block until file is deleted, the behavior is up to the OS
            </summary>
            <param name="fileName">Full file name with path</param>
        </member>
        <member name="M:NFX.IOMiscUtils.EnsureDirectoryDeleted(System.String,System.Int32)">
            <summary>
            Tries to delete the specified directory if it exists BLOCKING for up to the specified interval until directory is PHYSICALLY deleted.
            Returns true when directory either did not exist in the first place or was successfully deleted (with confirmation).
            Returns false when directory could not be confirmed to be deleted within the specified timeout, this does not mean
             that the OS will not delete the directory later, so calling this function in a loop is expected.
             NOTE: Directory.Delete() does not guarantee that directory is no longer on disk upon its return
            </summary>
            <param name="dirName">Directory to delete</param>
            <param name="timeoutMs">Timeout in ms</param>
        </member>
        <member name="M:NFX.IOMiscUtils.EnsureAccessibleDirectory(System.String)">
            <summary>
            Creates directory and immediately grants it accessibility rules for everyone if it does not exists,
             or returns the existing directory
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.MemBufferEquals(System.Byte[],System.Byte[])">
            <summary>
            Returns true if both buffers contain the same number of the same bytes.
            The implementation uses quad-word comparison as much as possible for speed.
            Requires UNSAFE switch
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.PackISO3CodeToInt(System.String)">
            <summary>
            Represents an ISO code as 4 byte integer filled with
            up to 3 ASCII chars converted to upper case, the highest byte is free to be used by the application
            </summary>
        </member>
        <member name="M:NFX.IOMiscUtils.UnpackISO3CodeFromInt(System.Int32)">
            <summary>
            Unpacks an ISO code from int which was packed with PackISO3CodeToInt
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CodeAnalysisException">
            <summary>
            Base exception thrown by the framework
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.CodeProcessorException">
            <summary>
            Thrown by code processors such as lexers, parsers ,  symantic analyzers, compilers etc...
            </summary>
        </member>
        <member name="T:NFX.IWrappedExceptionDataSource">
            <summary>
            Provides textual portable data about this exception which will be used in wrapped exception.
            Wrapped exceptions are used to marshall non serializable exceptions
            </summary>
        </member>
        <member name="M:NFX.IWrappedExceptionDataSource.GetWrappedData">
            <summary>
            Gets portable textual representation of exception data for inclusion in wrapped exception
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONLexer">
            <summary>
            Performs lexical analysis on source supplied in JSON syntax.
            This class supports lazy analysis that happens gradually as result tokens are consumed through IEnumerable interface.
            NOTE: Although called JSON, this is really a JSON superset implementation that includes extra features:
             comments, directives, verbatim strings(start with $), ' or " string escapes, unquoted object key names
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.IProjectItem">
            <summary>
            Represents an item that is a part of some project, i.e. a CS source file in CSharp project
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONLanguage">
            <summary>
            Represents JSON language
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONToken">
            <summary>
            Represents a token of JSON language
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.JSON.JSONTokenType">
            <summary>
            Denotes JSON token types.
            NOTE: Although called JSON, this is really a JSON superset implementation that includes extra features:
             comments, directives, verbatim strings(start with $), ' or " string escapes, unquoted object key names
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.LanguageFamily">
            <summary>
            Defines various languages
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.UnspecifiedLanguage">
            <summary>
            Represents Unspecified unknown language
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Message">
            <summary>
            Represents a message emitted from code-analyzing entities such as lexers, parsers, semantic analyzers and compilers.
            Messages have severity type like warning, info or error etc.
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Message.IsInternal">
            <summary>
            Indicates whether this message is an internal message
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Message.IsInfo">
            <summary>
            Indicates whether this message is an info message
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Message.IsWarning">
            <summary>
            Indicates whether this message is a warning message
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Message.IsError">
            <summary>
            Indicates whether this message is an error message
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.ILanguageProcessorNotifications">
            <summary>
            Describes an entity capable of receiving messages as they are emitted by entities such as parsers and compilers
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.MessageList">
            <summary>
            Provides a list of messages, this class is not thread-safe
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.MessageList.Add(NFX.CodeAnalysis.Message)">
            <summary>
            Emits new message
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.MessageList.Internals">
            <summary>
            Enumerates all internal messages
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.MessageList.Infos">
            <summary>
            Enumerates all info messages
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.MessageList.Warnings">
            <summary>
            Enumerates all warning messages
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.MessageList.Errors">
            <summary>
            Enumerates all error messages
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.MessageType">
            <summary>
            Message type like: Info, Warning, Error
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Source.FileSource">
            <summary>
            Represents source code stored in a file
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Source.FileSource.#ctor(System.String)">
            <summary>
            Constructs file source infering source language from file extension
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Source.FileSource.#ctor(NFX.CodeAnalysis.Language,System.String)">
            <summary>
            Constructs file source with specified language ignoring file extension
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Source.FileSource.Name">
            <summary>
            Returns source's file name
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Source.FileNameList">
            <summary>
            Represents a list of file names
            </summary>
        </member>
        <member name="M:NFX.CodeAnalysis.Source.FileNameList.CheckAllNames">
            <summary>
            Checks that all files exist
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Source.SourceCodeRef">
            <summary>
            Represents a reference to the source code which may be named buffer or project source item (i.e. solution project item)
            </summary>
        </member>
        <member name="F:NFX.CodeAnalysis.Source.SourceCodeRef.SourceName">
            <summary>
            Provides name for the source, this property is set to ProjectItem.Name when IProjectItem is supplied in .ctor
            </summary>
        </member>
        <member name="F:NFX.CodeAnalysis.Source.SourceCodeRef.ProjectItem">
            <summary>
            References project source item, this property may be null
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Source.ListOfISourceText">
            <summary>
            Represents a list of strings used as source text
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Source.SourcePosition">
            <summary>
            Represents position in source input
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Source.SourceVector">
            <summary>
            Represents a pointer to the named source code  and character position
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Source.StringSource">
            <summary>
            Provides source code from string
            </summary>
        </member>
        <member name="P:NFX.CodeAnalysis.Source.StringSource.Name">
            <summary>
            Provides a handy way to name an otherwise-anonymous string source code,
            This property is like a "file name" only data is kept in a string
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Source.StringSourceList">
            <summary>
            Represents a list of strings used as source text
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.TokenKind">
            <summary>
            Provides language-agnostic token classification
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.TokenList`1">
            <summary>
            A list of tokens
            </summary>
        </member>
        <member name="T:NFX.CodeAnalysis.Tokenized`1">
            <summary>
            Provides read-only view over TokenList
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.DebugDestination">
            <summary>
            Provides a file storage destination implementation for debug and trace logging
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.TextFileDestination">
            <summary>
            Provides a file storage destination implementation
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.FileDestination">
            <summary>
            Provides a file storage destination implementation
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.FileDestination.DoOpenStream">
            <summary>
            Called after output stream has been opened
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.FileDestination.DoCloseStream">
            <summary>
            Called just before output stream is closed
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.FileDestination.DoWriteMessage(NFX.Log.Message)">
            <summary>
            Called when message is to be written to stream
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.FileDestination.DoSend(NFX.Log.Message)">
            <summary>
            Override DoFormatMessage() instead
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.FileDestination.FileName">
            <summary>
            The name of the file without path may use {0} for date: {0:yyyyMMdd}-$($name).csv.log
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.FileDestination.Path">
            <summary>
            Directory where file should be created. Will create the directory chane if it doesn't exist
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.TextFileDestination.DoWriteMessage(NFX.Log.Message)">
            <summary>
            Warning: don't override this method in derived destinations, use
            DoFormatMessage() instead!
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.TextFileDestination.DoFormatMessage(NFX.Log.Message)">
            <summary>
            Called when message is to be written to stream
            </summary>
        </member>
        <member name="T:NFX.Log.LogServiceBase">
            <summary>
            Based class for implementing test and non-test logging services.
            Destinations may fail and the message will be failed-over into another destination in the same logger
             as specified by 'failover' attribute of destination. This attribute is also present on service level.
            Cascading failover is not supported (failover of failovers). Another consideration is that messages
             get sent into destinations synchronously by internal thread so specifying too many destinations may
             limit overall LogService throughput. In complex scenarios consider using LogServiceDestination instead.
            </summary>
        </member>
        <member name="T:NFX.Log.ILogImplementation">
            <summary>
            Describes entity capable of being written log information to
            </summary>
        </member>
        <member name="T:NFX.Log.ILog">
            <summary>
            Describes entity capable of being written log information to
            </summary>
        </member>
        <member name="M:NFX.Log.LogServiceBase.#ctor">
            <summary>
            Creates a new logging service instance
            </summary>
        </member>
        <member name="M:NFX.Log.LogServiceBase.#ctor(NFX.ServiceModel.Service)">
            <summary>
            Creates a new logging service instance
            </summary>
        </member>
        <member name="M:NFX.Log.LogServiceBase.Write(NFX.Log.MessageType,System.String,System.String,System.String)">
            <summary>
            Writes log message into log
            </summary>
        </member>
        <member name="M:NFX.Log.LogServiceBase.Write(NFX.Log.MessageType,System.String,System.Boolean,System.String,System.String)">
            <summary>
            Writes log message into log
            </summary>
        </member>
        <member name="M:NFX.Log.LogServiceBase.Write(NFX.Log.Message)">
            <summary>
            Writes log message into log
            </summary>
            <param name="msg">Message to write</param>
        </member>
        <member name="M:NFX.Log.LogServiceBase.Write(NFX.Log.Message,System.Boolean)">
            <summary>
            Writes log message into log
            </summary>
            <param name="msg">Message to write</param>
            <param name="urgent">Indicates that the logging service implementation must
            make an effort to write the message to its destinations urgently</param>
        </member>
        <member name="M:NFX.Log.LogServiceBase.RegisterDestination(NFX.Log.Destinations.Destination,System.Int32)">
            <summary>
            Adds a destination to this service active destinations. Negative index to append
            </summary>
        </member>
        <member name="M:NFX.Log.LogServiceBase.UnRegisterDestination(NFX.Log.Destinations.Destination)">
            <summary>
            Removes a destiantion from this service active destinations, returns true if destination was found and removed
            </summary>
        </member>
        <member name="M:NFX.Log.LogServiceBase.GetInstrumentationBuffer(System.Boolean)">
            <summary>
            Returns instrumentation buffer if instrumentation enabled
            </summary>
        </member>
        <member name="M:NFX.Log.LogServiceBase.DoWrite(NFX.Log.Message,System.Boolean)">
            <summary>
            Writes log message into log
            </summary>
            <param name="msg">Message to write</param>
            <param name="urgent">Indicates that the logging service implementation must
            make an effort to write the message to its destinations urgently</param>
        </member>
        <member name="M:NFX.Log.LogServiceBase.FailoverDestination(NFX.Log.Destinations.Destination,System.Exception,NFX.Log.Message)">
            <summary>
            When error=null => error cleared. When msg==null => exceptions surfaced from DoPulse()
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.LastWarning">
            <summary>
            Latches last problematic msg
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.LastError">
            <summary>
            Latches last problematic msg
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.LastCatastrophy">
            <summary>
            Latches last problematic msg
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.Destinations">
            <summary>
            Returns registered destinations. This call is thread safe
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.InstrumentationEnabled">
            <summary>
            Implements IInstrumentable
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.DefaultFailover">
            <summary>
            Sets destination name used for failover on the service-level
            if particular failing destination did not specify its specific failover
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.FailoverErrorDestination">
            <summary>
            Returns a destination that threw last exception that happened durng failover. This kind of exceptions is never propagated and always handled
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.FailoverError">
            <summary>
            Returns last exception that happened during failover. This kind of exceptions is never propagated and always handled
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.Now">
            <summary>
            Returns localized log time
            </summary>
        </member>
        <member name="P:NFX.Log.LogServiceBase.DestinationsAreOptional">
            <summary>
            Indicates whether the service can operate without any destinations registered, i.e. some test loggers may not need
             any destinations to operate as they synchronously write to some buffer without any extra destinations
            </summary>
        </member>
        <member name="T:NFX.IOrderedRegistry`1">
            <summary>
            Provides read-only named ordered object lookup capabilities
            </summary>
        </member>
        <member name="P:NFX.IOrderedRegistry`1.OrderedValues">
            <summary>
            Returns items that registry contains ordered by their Order property.
            The returned sequence is pre-sorted during alteration of registry, so this property access is efficient.
            Note: since registry does reading in a lock-free manner, it is possible to have an inconsistent read snapshot
             of ordered items which may capture items that have already/not yet been added to the registry
            </summary>
        </member>
        <member name="P:NFX.IOrderedRegistry`1.Item(System.Int32)">
            <summary>
            Tries to return an item by its position index in ordered set of items that this registry keeps.
            Null is returned when index is out of bounds.
            Note: since registry does reading in a lock-free manner, it is possible to have an inconsistent read snapshot
             of ordered items which may capture items that have already/not yet been added to the registry
            </summary>
        </member>
        <member name="T:NFX.RegistryDictionary`1">
            <summary>
            Internal dictionary of string-named objects
            </summary>
        </member>
        <member name="T:NFX.OrderedRegistry`1">
            <summary>
            Represents a thread-safe registry of T which is ordered by Order property.
            This class is efficient for concurrent read access and is not designed for cases when frequent modifications happen.
            It is ideal for lookup of named instances that have much longer time span than components that look them up.
            Note: since registry does reading in a lock-free manner, it is possible to have an inconsistent read snapshot
             of ordered items which may capture items that have already/not yet been added to the registry
            </summary>
        </member>
        <member name="M:NFX.OrderedRegistry`1.Clear">
            <summary>
            Deletes all items from ordered registry
            </summary>
        </member>
        <member name="P:NFX.OrderedRegistry`1.OrderedValues">
            <summary>
            Returns items that registry contains ordered by their Order property.
            The returned sequence is pre-sorted during alteration of registry, so this property access is efficient.
            Note: since registry does reading in a lock-free manner, it is possible to have an inconsistent read snapshot
             of ordered items which may capture items that have already/not yet been added to the registry
            </summary>
        </member>
        <member name="P:NFX.OrderedRegistry`1.Item(System.Int32)">
            <summary>
            Tries to return an item by its position index in ordered set of items that this registry keeps.
            Null is returned when index is out of bounds.
            Note: since registry does reading in a lock-free manner, it is possible to have an inconsistent read snapshot
             of ordered items which may capture items that have already/not yet been added to the registry
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.Headers">
            <summary>
            List of headers
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.HeaderConfigurator">
            <summary>
            Provides general configuration reading logic for headers.
            Note: This class is not invoked by default glue runtime, so default application
             configurations that include header injections will be ignored unless this class is specifically called
             from code. This is because conf-based header injection is a rare case that may need to be controlled by a particular application
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.Msg">
            <summary>
            Represents a message base that requests and responses derive from.
            Messages are exchanged between glued tiers
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.Msg.#ctor">
            <summary>
            Constructs new message and allocates unique ID
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.Msg.__SetArrivalTimeStampTicks(System.Int64)">
            <summary>
            Framework method not for developers. Sets arrival ticks stamp. Usually called from transport
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.Msg.__SetBindingSpecificContext(System.Object)">
            <summary>
            Internal method not to be called by app developers.
            Called from custom bindings to inject binding-specific context
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.Msg.__SetBindingSpecificContext(NFX.Glue.Protocol.Msg)">
            <summary>
            Internal method not to be called by app developers.
            Called from custom bindings to inject binding-specific context
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.Msg.CloneState(NFX.Glue.Protocol.Msg,System.Boolean,System.Boolean)">
            <summary>
            Clones message state from another message instance.
            State includes binding-specific context and optionally headers and correlation data
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.Msg.ID">
            <summary>
            Returns a unique ID for this message
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.Msg.ArrivalTimeStamp">
            <summary>
            Returns arrival timestamp expressed in ticks, that is - when message just arrived before its processing started by Glue (before deserialization).
            This property allows for glue-internal latency assessment
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.Msg.RequestID">
            <summary>
            Returns request ID that relates to this message instance. It is the message ID for RequestMsg and related message ID for ResponseMsg
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.Msg.HasHeaders">
            <summary>
            Returns true when this message contains header data
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.Msg.Headers">
            <summary>
            Returns a list of headers that this message contains
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.Msg.HasCorrelationData">
            <summary>
            Returns true when this message contains header data
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.Msg.CorrelationData">
            <summary>
            Arbitrary named object collection that can be used to correlate messages and/or attach extra data.
            This field is NOT transmitted over wire nor is it used by the framework. Message inspectors may use this property
            at their own discretion, for example in cases when the same inspector type is registered on multiple levels (endpoint, binding, glue),
            inspectors may check this property to execute only once per message.
            The collection is lazily allocated at the first reference attempt
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.Msg.BindingSpecificContext">
            <summary>
            Returns a binding-specific context object which is used for message processing/routing by binding.
            This property value is not serialized and used internally by Glue framework. Not all bindings use/need this property
            </summary>
        </member>
        <member name="T:NFX.Glue.GlueException">
            <summary>
            Base exception thrown by the Glue framework
            </summary>
        </member>
        <member name="T:NFX.Glue.InvalidGlueOperationException">
            <summary>
            Base exception thrown by the Glue framework when some operations are invoked that do not apply
            </summary>
        </member>
        <member name="T:NFX.Glue.ClientCallException">
            <summary>
            Thrown by the Glue framework when clients try to perfom a call but that action fails
            </summary>
        </member>
        <member name="F:NFX.Glue.ClientCallException.Status">
            <summary>
            Returns call status enum
            </summary>
        </member>
        <member name="T:NFX.Glue.ClientMsgInspectionException">
            <summary>
            Thrown by the Glue framework when client message inspector fails with exception
            </summary>
        </member>
        <member name="P:NFX.Glue.ClientMsgInspectionException.Inspector">
            <summary>
            Returns inspector that threw exception
            </summary>
        </member>
        <member name="T:NFX.Glue.RemoteException">
            <summary>
            Base exception thrown by the Glue framework when remote errors are reported back to caller
            </summary>
        </member>
        <member name="P:NFX.Glue.RemoteException.Remote">
            <summary>
            Returns remote exception data
            </summary>
        </member>
        <member name="T:NFX.Glue.ProtocolException">
            <summary>
            Exception thrown when there are protocol-related errors like deserialization,
            request message received when response is expected
            </summary>
        </member>
        <member name="P:NFX.Glue.ProtocolException.CloseChannel">
            <summary>
            Returns true when error is not recoverable on the existing channel and it needs to be closed
            </summary>
        </member>
        <member name="T:NFX.Glue.MessageSizeException">
            <summary>
            Exception thrown in client/server when there's an attempt to send a too large message
            </summary>
        </member>
        <member name="T:NFX.Glue.ServerException">
            <summary>
            Exception thrown in Glue server
            </summary>
        </member>
        <member name="T:NFX.Glue.ServerNotRunningException">
            <summary>
            Exception thrown in Glue server when it shuts down/not running
            </summary>
        </member>
        <member name="T:NFX.Glue.ServerContractException">
            <summary>
            Exception thrown when server could not get contract
            </summary>
        </member>
        <member name="T:NFX.Glue.ServerInstanceActivationException">
            <summary>
            Exception thrown when server instance can not be created
            </summary>
        </member>
        <member name="T:NFX.Glue.StatefulServerInstanceDoesNotExistException">
            <summary>
            Exception thrown when statful server identified is not found/has expired/timed-out
            </summary>
        </member>
        <member name="T:NFX.Glue.StatefulServerInstanceLockTimeoutException">
            <summary>
            Exception thrown when statful server instance is not thread safe and could not be locked before set timeout expired
            </summary>
        </member>
        <member name="T:NFX.Glue.ServerMethodInvocationException">
            <summary>
            Exception thrown when server can not invoke method
            </summary>
        </member>
        <member name="T:NFX.Glue.Node">
            <summary>
            Represents a network node. It is a binding, logical address of a host and a service that host provides
            Nodes are not contract-dependent. The componets of address are not case-sensitive.
            The form of the address is: <code>binding://host:service</code>. The "host" and "service" segment syntaxes depend on binding and may not contain the ':' char.
            An example of some 'mytest' binding: 'mytest://adr=1.1.1.1,nic=eth001:job,chat,backup'
            </summary>
        </member>
        <member name="M:NFX.Glue.Node.#ctor(System.String)">
            <summary>
            Inits a node struct. It is a binding, logical address of a host and a service that host provides
            Nodes are not contract-dependent. The componets of address are not case-sensitive.
            The form of the address is: <code>binding://host:service</code>. The "host" and "service" segment syntaxes depend on binding and may not contain the ':' char.
            An example of some 'mytest' binding: 'mytest://adr=1.1.1.1,nic=eth001:job,chat,backup'
            </summary>
        </member>
        <member name="P:NFX.Glue.Node.ConnectString">
            <summary>
            Gets a connection string - a structured URL-like connection descriptor that identifies a host
             along with binding and service. The componets of address are not case-sensitive.
            The form of the address is: <code>binding://host:service</code>. The "host" and "service" segment syntaxes depend on binding and may not contain the ':' char.
            An example of some 'mytest' binding: 'mytest://adr=1.1.1.1,nic=eth001:job,chat,backup'
            </summary>
        </member>
        <member name="P:NFX.Glue.Node.Name">
            <summary>
            INamed shortcut to ConnectString
            </summary>
        </member>
        <member name="P:NFX.Glue.Node.Assigned">
            <summary>
            Returns true when struct has some data assigned i.e. connect string is specified
            </summary>
        </member>
        <member name="P:NFX.Glue.Node.Binding">
            <summary>
            Gets binding portion of ConnectString. This value selects binding adapter
            </summary>
        </member>
        <member name="P:NFX.Glue.Node.Host">
            <summary>
            Gets host portion of ConnectString. This value may have a structure of its own which is understood by binding adapter
            </summary>
        </member>
        <member name="P:NFX.Glue.Node.Service">
            <summary>
            Gets service/port portion of ConnectString. This value may have a structure of its own which is understood by binding adapter
            </summary>
        </member>
        <member name="T:NFX.Glue.Bindings">
            <summary>
            A registry of Binding-derived instances
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.RequestMsg">
            <summary>
            This message is sent from client to server and contains contract type, method specification and invocation arguments
            which are either included as object[] if RequestAnyMsg is used or inlined in RequestMsg- typed derivative for speed to avoid boxing
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.RequestMsg.#ctor(System.Reflection.MethodInfo,System.Nullable{System.Guid})">
            <summary>
            Constructs request message from method information and arguments for call invocation.
            This constructor is slower as it uses reflection
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.RequestMsg.#ctor(NFX.Glue.Protocol.TypeSpec,NFX.Glue.Protocol.MethodSpec,System.Boolean,System.Nullable{System.Guid})">
            <summary>
            Constructs request message from pre-computed  specs obtained by reflection.
            This constructor is the fastest as it does not use reflection
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.RequestMsg.#ctor(NFX.Glue.Protocol.RequestMsg,System.Reflection.MethodInfo,System.Nullable{System.Guid},System.Boolean,System.Boolean)">
            <summary>
            This .ctor is handy for message inspectors.
            Creates a substitute message for the original one with new values.
            Binding-specific context is cloned and headers/correlation data are cloned conditionaly
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.RequestMsg.#ctor(NFX.Glue.Protocol.RequestMsg,NFX.Glue.Protocol.TypeSpec,NFX.Glue.Protocol.MethodSpec,System.Boolean,System.Nullable{System.Guid},System.Boolean,System.Boolean)">
            <summary>
            This .ctor is handy for message inspectors.
            Creates a substitute message for the original one with new values.
            Binding-specific context is cloned and headers/correlation data are cloned conditionaly
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.RequestMsg.__setServerTransport(NFX.Glue.ServerTransport)">
            <summary>
            Implementation-specific internal method not to be used by developers
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RequestMsg.RequestID">
            <summary>
            Returns request ID for this instance. Every request is uniquely identified
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RequestMsg.RemoteInstance">
            <summary>
            If server is stateful then this property contains remote instance ID
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RequestMsg.Contract">
            <summary>
            Returns contract type that this call belongs to. This property throws if actual specified type can not be found
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RequestMsg.ContractSpec">
            <summary>
            Returns contract type spec that this call belongs to
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RequestMsg.MethodName">
            <summary>
            Gets a name of method to be invoked on the other side
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RequestMsg.Method">
            <summary>
            Gets a method specification to be invoked on the other side
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RequestMsg.OneWay">
            <summary>
            Indicates that no response is expected
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RequestMsg.ServerTransport">
            <summary>
            Returns transport that this request arrived through. Property is to be used only on server
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RequestMsg.Session">
            <summary>
            Session reference that can be used to pass session object that was already determined by transport (i.e. HttpServerTransport)
             into Glue server handler. This property is NOT transmitted/serialized over wire
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.RequestAnyMsg">
            <summary>
            Represents request msg that marshalls arguments as object[].
            Although the most convenient and simple, this way of working with glue is slower than
            using RequestTypedMsg which needs to be derived-from for every method
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.RequestAnyMsg.#ctor(System.Reflection.MethodInfo,System.Nullable{System.Guid},System.Object[])">
            <summary>
            Constructs request message from method information and arguments for call invocation.
            This constructor is slower as it uses reflection
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.RequestAnyMsg.#ctor(NFX.Glue.Protocol.TypeSpec,NFX.Glue.Protocol.MethodSpec,System.Boolean,System.Nullable{System.Guid},System.Object[])">
            <summary>
            Constructs request message from pre-computed  specs obtained by reflection.
            This constructor is the fastest as it does not use reflection
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.RequestAnyMsg.#ctor(NFX.Glue.Protocol.RequestMsg,System.Reflection.MethodInfo,System.Nullable{System.Guid},System.Object[],System.Boolean,System.Boolean)">
            <summary>
            This .ctor is handy for message inspectors.
            Creates a substitute message for the original one with new values.
            Binding-specific context is cloned and headers/correlation data are cloned conditionaly
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.RequestAnyMsg.#ctor(NFX.Glue.Protocol.RequestMsg,NFX.Glue.Protocol.TypeSpec,NFX.Glue.Protocol.MethodSpec,System.Boolean,System.Nullable{System.Guid},System.Object[],System.Boolean,System.Boolean)">
            <summary>
            This .ctor is handy for message inspectors.
            Creates a substitute message for the original one with new values.
            Binding-specific context is cloned and headers/correlation data are cloned conditionaly
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.RequestAnyMsg.Arguments">
            <summary>
            Returns call arguments
            </summary>
        </member>
        <member name="T:NFX.Glue.CallSlot">
            <summary>
            Represents a class that is immediately returned after transport sends RequestMsg.
            This class provides CallStatus and RequestID properties where the later is used to match the incoming ResponseMsg.
            CallSlots are kinds of "spirit-less" mailboxes that keep state about the call, but do not posess any threads/call events.
            Working with CallSlots from calling code's existing thread of execution is the most efficient way of working with Glue (in high load cases), as
             it does not create extra object instances (tasks do) for asynchronous coordination and continuation.
            It is possible to obtain an instance of CallSlot.AsTask in which case that instance is registered with the framework-internal reactor
             so task does complete normally even on timeout, however, in high-throughput apps (10K+ calls per second) this method is not the most efficient one
             as it allocates additional objects (task, list entry etc.) that eventually increase GC load for long runs.
             Note: A 3.2 Ghz 4-Core I7 server with 8Gb of ram can easily handle 40K 2-way calls a second (given little business server logic and simple payload).
             See also: CallReactor class
            </summary>
        </member>
        <member name="M:NFX.Glue.CallSlot.#ctor(NFX.Glue.ClientEndPoint,NFX.Glue.ClientTransport,NFX.Glue.Protocol.RequestMsg,NFX.Glue.CallStatus,System.Int32)">
            <summary>
            INTERNAL METHOD. Developers do not call!
            This constructor is used by an Async binding that delivers response after call slot was created
            </summary>
        </member>
        <member name="M:NFX.Glue.CallSlot.#ctor(NFX.Glue.ClientEndPoint,NFX.Glue.ClientTransport,System.Int64,System.DateTime,NFX.Glue.Protocol.RequestMsg,NFX.Glue.Protocol.ResponseMsg,System.Int32)">
            <summary>
            INTERNAL METHOD. Developers do not call!
            This constructor is used by a synchronous binding that delivers response right after sending it.
            ONLY for OneWayCall = false
            </summary>
        </member>
        <member name="M:NFX.Glue.CallSlot.AsTaskReturning``1">
            <summary>
            Creates a wrapper task around CallSlot.AsTask and returns CallSlot.GetValue() as TCallResult-returning Task.
            Note: the created wrapper task is not cached
            </summary>
        </member>
        <member name="M:NFX.Glue.CallSlot.AsTaskReturningVoid">
            <summary>
            Creates a wrapper task around CallSlot.AsTask and returns CallSlot.CheckVoidValue()
            Note: the created wrapper task is not cached
            </summary>
        </member>
        <member name="M:NFX.Glue.CallSlot.DeliverResponse(NFX.Glue.Protocol.ResponseMsg)">
            <summary>
            Called internally by framework to populate the response message when one asynchronously arrives from transport
            </summary>
        </member>
        <member name="M:NFX.Glue.CallSlot.SignalDispatchError(System.String)">
            <summary>
            Signal erroneous completion of request dispatching. This method is used by transports that post outgoing message asynchronously
            </summary>
        </member>
        <member name="M:NFX.Glue.CallSlot.GetValue``1">
            <summary>
            Returns a value from the other side, that is -
            gets the response message and checks it for errors,
            throwing RemoteError exception if one came from server.
            Accessing this property blocks calling thread until either ResponseMsg arrives or timeout expires.
            Check 'Available' property not to block. Accessing this method for [OneWay] methods throws.
            </summary>
        </member>
        <member name="M:NFX.Glue.CallSlot.CheckVoidValue">
            <summary>
            Checks for a valid void value returned from the other side, that is -
            gets the response message and checks it for errors,
            throwing RemoteError exception if one came from server.
            Accessing this property blocks calling thread until either ResponseMsg arrives or timeout expires.
            Check 'Available' property not to block. Accessing this method for [OneWay] methods throws.
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.Client">
            <summary>
            Returns client endpoint that initiated this call
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.ClientTransport">
            <summary>
            Returns client transport that this instance is originated from
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.CallContext">
            <summary>
            General-purpose property that clients can use for attaching an arbitrary context to this instance. This property has no use in the framework
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.CallStatus">
            <summary>
            Returns current call status. Timeout is returned when response has not arrived from the other side in alotted time. This is a non-blocking call
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.DispatchErrorMessage">
            <summary>
            Optionally returns reason of the dispatch message failure
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.OneWay">
            <summary>
            Indicates that this call does not expect a response message from the server side
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.RequestID">
            <summary>
            Returns request ID for the request that was sent and generated this slot instance
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.TimeoutMs">
            <summary>
            Returns timeout for this instance
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.StartTime">
            <summary>
            Returns UTC timestamp of call initiation
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.StatStartTimeTicks">
            <summary>
            When binding's MeasureStatTimes enabled, returns the operation start tick count
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.StatRoundtripEndTimeTicks">
            <summary>
            When binding's MeasureStatTimes enabled, returns the operation end (when response arrives) tick count
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.StatRoundtripTimeKey">
            <summary>
            When binding's MeasureStatTimes enabled, returns the name of the stat key
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.AsTask">
            <summary>
            Gets the CallSlot instance as a task that gets completed either instantly for one-way calls or when result arrives or timeout happens.
            The returned task never gets canceled
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.Available">
            <summary>
            Returns true when response has come and available so no blocking will occur when reading response. This is a non-blocking call.
            Always returns true for operations marked as [OneWay]
            </summary>
        </member>
        <member name="P:NFX.Glue.CallSlot.ResponseMsg">
            <summary>
            Blocks until response comes or timeout happens. Response message inspection happens in the context of a calling thread
            </summary>
        </member>
        <member name="T:NFX.Glue.TimeoutReactor">
            <summary>
            Internal class that polls call slots for timeout
            </summary>
        </member>
        <member name="T:NFX.Glue.Future`1">
            <summary>
            Provides a higher-level wrapper around CallSlot returned value by Glue.
            All property accessors evaluate synchronously on the calling thread.
            This struct should not be used with One-Way calls or calls that return void
            </summary>
        </member>
        <member name="F:NFX.Glue.Future`1.Call">
            <summary>
            Returns the underlying CallSlot object
            </summary>
        </member>
        <member name="P:NFX.Glue.Future`1.Available">
            <summary>
            Non-blocking call that returns true if result arrived, false otherwise
            </summary>
        </member>
        <member name="P:NFX.Glue.Future`1.Value">
            <summary>
            Blocking call that waits for return value. Use non-blocking Available to see if result arrived
            </summary>
        </member>
        <member name="T:NFX.Glue.FutureVoid">
            <summary>
            Provides a higher-level wrapper around CallSlot returned by Glue.
            All property accessors evaluate synchronously on the calling thread.
            This struct should not be used with One-Way calls
            </summary>
        </member>
        <member name="F:NFX.Glue.FutureVoid.Call">
            <summary>
            Returns the underlying CallSlot object
            </summary>
        </member>
        <member name="M:NFX.Glue.FutureVoid.Wait">
            <summary>
            Blocking call that waits for call completion. Use non-blocking Available to see if call has completed
            </summary>
        </member>
        <member name="P:NFX.Glue.FutureVoid.Available">
            <summary>
            Non-blocking call that returns true if result arrived, false otherwise
            </summary>
        </member>
        <member name="T:NFX.Glue.Protocol.ResponseMsg">
            <summary>
            Represents a response message sent by called party
            </summary>
        </member>
        <member name="M:NFX.Glue.Protocol.ResponseMsg.#ctor(NFX.Glue.Protocol.ResponseMsg,System.Object,System.Boolean,System.Boolean)">
            <summary>
            This .ctor is handy for message inspectors.
            Creates a substitute message for the original one with new value.
            Binding-specific context is cloned and headers/correlation data are cloned conditionaly
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.ResponseMsg.RequestID">
            <summary>
            Returns request ID this response is for
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.ResponseMsg.ReturnValue">
            <summary>
            Returns return value of the called method. Note: out and ref params are not supported
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.ResponseMsg.RemoteInstance">
            <summary>
            For stateful servers returns instance ID
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.ResponseMsg.ExceptionData">
            <summary>
            Returns remote exception data if any
            </summary>
        </member>
        <member name="P:NFX.Glue.Protocol.ResponseMsg.OK">
            <summary>
            Returns true when reponse does not contain remote server exception which is represented by WrappedExceptionData
            </summary>
        </member>
        <member name="T:NFX.Glue.TransportKind">
            <summary>
            Defines kinds of trasport
            </summary>
        </member>
        <member name="T:NFX.Health.BaseCheck">
            <summary>
            Base class for all Health Checks. Particular health checks must inherit from
             this class to be invoked
            </summary>
        </member>
        <member name="F:NFX.Health.BaseCheck.Result">
            <summary>
            Results property bag may be used for reporting of additional
            health-check parameters i.e. latency, content size etc...
            </summary>
        </member>
        <member name="M:NFX.Health.BaseCheck.Run(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Runs the check
            </summary>
        </member>
        <member name="M:NFX.Health.BaseCheck.DoRun(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Override to provide particular health check implementation
            </summary>
        </member>
        <member name="P:NFX.Health.BaseCheck.CanRun">
            <summary>
            Indicates whether this check will be executed
            </summary>
        </member>
        <member name="P:NFX.Health.BaseCheck.Name">
            <summary>
            Provides textual name for this check. Base implementation returns full type name
            </summary>
        </member>
        <member name="P:NFX.Health.BaseCheck.Description">
            <summary>
            Provides additional textual description of the check
            </summary>
        </member>
        <member name="T:NFX.Health.CheckListStatus">
            <summary>
            Stipulates status for Health.CheckList
            </summary>
        </member>
        <member name="T:NFX.Health.CheckList">
            <summary>
            Represents a list of health checks to be performed.
            Health checks are classes derived from BaseCheck class and must implement DoRun() method
             that performs application-specific checking. CheckList obtains a list of Check instances
              from assemblies supplied to its constructor.
            Health checks are executed in no predictable order.
            If particular execution order is necessary then a check has to be written to explicitly
             coordinate sub-checks.
            The class is thread safe for all operations.
            </summary>
        </member>
        <member name="M:NFX.Health.CheckList.#ctor(System.String,System.String,NFX.Environment.ConfigSectionNode)">
            <summary>
            Initializaes check list from assembly names separated by semicolons.
            Optional path will be prepended to every assembly name
            </summary>
        </member>
        <member name="M:NFX.Health.CheckList.#ctor(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},NFX.Environment.ConfigSectionNode)">
            <summary>
            Initializaes check list from assemblies
            </summary>
        </member>
        <member name="M:NFX.Health.CheckList.Run(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Runs health checks. Checks are ran in NO PARTICULAR order.
            This method can not be called twice
            </summary>
        </member>
        <member name="M:NFX.Health.CheckList.Report(System.IO.TextWriter,System.String)">
            <summary>
            Dumps check results into writer in on of the supported formats
            </summary>
        </member>
        <member name="P:NFX.Health.CheckList.Status">
            <summary>
            Returns current status - whether checks are running  or have already been run
            </summary>
        </member>
        <member name="P:NFX.Health.CheckList.Checks">
            <summary>
            Returns health checks
            </summary>
        </member>
        <member name="P:NFX.Health.CheckList.Successful">
            <summary>
            Returns true when all checks that could be run have successfuly run
            </summary>
        </member>
        <member name="P:NFX.Health.CheckList.AllSuccessful">
            <summary>
            Returns true when all checks have successfuly run
            </summary>
        </member>
        <member name="P:NFX.Health.CheckList.RunStart">
            <summary>
            Returns when run started
            </summary>
        </member>
        <member name="P:NFX.Health.CheckList.RunFinish">
            <summary>
            Returns when run finished
            </summary>
        </member>
        <member name="T:NFX.Health.CheckResult">
            <summary>
            Property bag to report health check results
            </summary>
        </member>
        <member name="P:NFX.Health.CheckResult.Successful">
            <summary>
            Indicates whether health check succeeded
            </summary>
        </member>
        <member name="P:NFX.Health.CheckResult.Exception">
            <summary>
            Exception that surfaced during check, consequently failing the check
            </summary>
        </member>
        <member name="P:NFX.Health.CheckResult.Skipped">
            <summary>
            Indicates whether check was not run
            </summary>
        </member>
        <member name="T:NFX.Health.HealthException">
            <summary>
            Represents general ancestor for exceptions thrown by health checks
            </summary>
        </member>
        <member name="T:NFX.Health.HealthCheckListException">
            <summary>
            Thrown by Health.CheckList
            </summary>
        </member>
        <member name="T:NFX.Health.HTMLReporter">
            <summary>
            Reports health check results as HTML
            </summary>
        </member>
        <member name="T:NFX.Health.Reporter">
            <summary>
            Base for all reporters - entities that output check list state into TextWriter
            </summary>
        </member>
        <member name="T:NFX.Health.TextReporter">
            <summary>
            Reports health check results in an plain text format
            </summary>
        </member>
        <member name="T:NFX.Health.XMLReporter">
            <summary>
            Reports XML health check results
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.TimeHistogramHelper">
            <summary>
            Helper class used by TimerHistogram
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogramHelper.Title(System.String,System.Int64)">
            <summary>
            Histogram title used for displaying purposes
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogramHelper.Clear">
            <summary>
            Reset internal histogram state
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogramHelper.Start">
            <summary>
            Start sample time measurement
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogramHelper.Stop">
            <summary>
            Stop sample time measurement started by Start() call
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogramHelper.MinTime">
            <summary>
            Minimum time of all sample measurements
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogramHelper.MaxTime">
            <summary>
            Maximum time of all sample measurements
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.TimeDimension">
            <summary>
            A dimension of data type double partitions a range of values
            by mapping the given value into [0 ... PartitionCount] partitions.
            This is a helper class for creating a dimension of TimeHistogram
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.Dimension`1">
            <summary>
            A dimension of data type TData partitions a range of values
            by mapping the given value into [0 ... PartitionCount] partitions
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.Dimension">
            <summary>
            Base class of a histogram dimension.
            of data type TData partitions a range defined by MinValue and MaxValue,
            by mapping the given value into [0 ... PartitionCount] partitions
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Dimension.#ctor(System.String,System.Int32,NFX.Instrumentation.Analytics.PartitionNameFunc)">
            <summary>
            Creates histogram dimension instance. If partitionFunc is null then
            DoPartition must be overriden in the derived class
            </summary>
            <param name="name">Description of this dimension used in reporting</param>
            <param name="partCount">Total number of partitions</param>
            <param name="partitionNameFunc">Used to inject a function in order not to override this class</param>
        </member>
        <member name="F:NFX.Instrumentation.Analytics.Dimension.PartitionCount">
            <summary>
            Number of partitions in
            </summary>
        </member>
        <member name="F:NFX.Instrumentation.Analytics.Dimension.Name">
            <summary>
            Provides meaningful name for displaying
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Dimension.GetPartitionName(System.Int32)">
            <summary>
            Returns the name of a partition identified by idx
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Dimension.DoPartitionName(System.Int32)">
            <summary>
            Override to implement a custom mapping logic to return the names of a given
            partition when its not passed in the .ctor
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Dimension.Index">
            <summary>
            Index of this dimension in the histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Dimension.DataType">
            <summary>
            Returns the type of data that this instance partitions
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Dimension`1.#ctor(System.String,System.Int32,NFX.Instrumentation.Analytics.PartitionFunc{`0},NFX.Instrumentation.Analytics.PartitionNameFunc)">
            <summary>
            Creates a histogram dimension. If partitionFunc is null then DoPartition must be
            overriden in the derived class
            </summary>
            <param name="name">Description of dimension used in reporting</param>
            <param name="partCount">Total number of partitions</param>
            <param name="partitionFunc">Used to inject a function in order not to override this class</param>
            <param name="partitionNameFunc">Used to inject a function in order not to override this class</param>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Dimension`1.DoPartition(`0)">
            <summary>
            Override to implement a custom partitioning logic in case of class derivation
            when its not passed in the .ctor
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Dimension`1.DataType">
            <summary>
            Returns the type of data that this instance partitions
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Dimension`1.Item(`0)">
            <summary>
            Maps a value into partition index
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeDimension.#ctor(System.String,System.Int32,NFX.Instrumentation.Analytics.PartitionFunc{System.Double},NFX.Instrumentation.Analytics.PartitionNameFunc)">
            <summary>
            Creates a histogram dimension. If partitionFunc is null then DoPartition must be
            overriden in the derived class
            </summary>
            <param name="desc">Description of dimension used in reporting</param>
            <param name="partCount">Total number of partitions</param>
            <param name="partitionFunc">Used to inject a function in order not to override this class</param>
            <param name="partitionNameFunc">Used to inject a function in order not to override this class</param>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeDimension.Item(System.Double)">
            <summary>
            Maps a value into partition index
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.TimeHistogram`2">
            <summary>
            Time measurement 3D histogram aggregates measurements in fractions of a second
            for a given 1st and 2nd dimension keys.
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.ITimeHistogram">
            <summary>
            Histogram for measuring latency
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.IHistogram">
            <summary>
            Basic histogram interface to be implemented by all types of
            instrumentation histograms
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.IHistogram.GetDimention(System.Int32)">
            <summary>
            Return a dimension of a histogram identified by index
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.IHistogram.GetPartitionName(System.Int32,System.Int32)">
            <summary>
            Returns the name of a partition in a given histogram dimension
            </summary>
            <param name="dimension">Dimension index</param>
            <param name="partition">Partition index</param>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.IHistogram.TryGet(NFX.Instrumentation.Analytics.HistogramKeys,System.Int32@)">
            <summary>
            Try to get the count of samples for the given histogram keys
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.IHistogram.Clear">
            <summary>
            Reset histogram state
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.IHistogram.Title">
            <summary>
            Histogram title used for displaying purposes
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.IHistogram.TotalSamples">
            <summary>
            Total number of samples in the histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.IHistogram.DimensionCount">
            <summary>
            Number of dimensions in this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.IHistogram.Dimensions">
            <summary>
            Returns the dimension instances of this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.IHistogram.Item(NFX.Instrumentation.Analytics.HistogramKeys)">
            <summary>
            Return the count of samples for the given histogram keys
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.ITimeHistogram.Start">
            <summary>
            Start sample time measurement
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.ITimeHistogram.MinTime">
            <summary>
            Minimum time of all measured samples
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.ITimeHistogram.MaxTime">
            <summary>
            Maximum time of all measured samples
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.ITimeHistogram.AvgTime">
            <summary>
            Average time of all measured samples
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`2.TimeFrame(`0,`1)">
            <summary>
            Returns a disposable instance suitable for time measurement in a "using" block
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`2.Start">
            <summary>
            Start sample time measurement
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`2.Stop(`0,`1)">
            <summary>
            Stop sample time measurement started by Start() call
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`2.Sample(System.Double,`0,`1)">
            <summary>
            Records time measurement in seconds
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`2.Clear">
            <summary>
            Reset internal histogram state
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`2.GetDimention(System.Int32)">
            <summary>
            Return a dimension of a histogram identified by index
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`2.GetPartitionName(System.Int32,System.Int32)">
            <summary>
            Returns the name of a partition in a given histogram dimension
            </summary>
            <param name="dimension">Dimension index</param>
            <param name="partition">Partition index</param>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`2.TryGet(NFX.Instrumentation.Analytics.HistogramKeys,System.Int32@)">
            <summary>
            Try to get the count of samples for the given histogram keys
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`2.Title">
            <summary>
            Histogram title used for displaying purposes
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`2.MinTime">
            <summary>
            Minimum time of all sample measurements
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`2.MaxTime">
            <summary>
            Maximum time of all sample measurements
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`2.AvgTime">
            <summary>
            Average time of all sample measurements
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`2.TotalSamples">
            <summary>
            Total number of samples in the histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`2.Dimensions">
            <summary>
            Returns the dimension instances of this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`2.DimensionCount">
            <summary>
            Number of dimensions in this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`2.Item(NFX.Instrumentation.Analytics.HistogramKeys)">
            <summary>
            Return the count of samples for the given histogram keys
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.TimeHistogram">
            <summary>
            Time measurement 1D histogram aggregates measurements in fractions of a second
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram.Start">
            <summary>
            Start sample time measurement
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram.Stop">
            <summary>
            Stop sample time measurement started by Start() call
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram.Sample(System.Double)">
            <summary>
            Records time measurement in seconds
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram.Clear">
            <summary>
            Reset internal histogram state
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram.GetDimention(System.Int32)">
            <summary>
            Return a dimension of a histogram identified by index
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram.GetPartitionName(System.Int32,System.Int32)">
            <summary>
            Returns the name of a partition in a given histogram dimension
            </summary>
            <param name="dimension">Dimension index</param>
            <param name="partition">Partition index</param>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram.TryGet(NFX.Instrumentation.Analytics.HistogramKeys,System.Int32@)">
            <summary>
            Try to get the count of samples for the given histogram keys
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram.TimeFrame">
            <summary>
            Returns a disposable instance suitable for time measurement in a "using" block
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram.Title">
            <summary>
            Histogram title used for displaying purposes
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram.MinTime">
            <summary>
            Minimum time of all sample measurements
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram.MaxTime">
            <summary>
            Maximum time of all sample measurements
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram.AvgTime">
            <summary>
            Average time of all sample measurements
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram.TotalSamples">
            <summary>
            Total number of samples in the histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram.Dimensions">
            <summary>
            Returns the dimension instances of this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram.DimensionCount">
            <summary>
            Number of dimensions in this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram.Item(NFX.Instrumentation.Analytics.HistogramKeys)">
            <summary>
            Return the count of samples for the given histogram keys
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.TimeHistogram`1">
            <summary>
            Time measurement 2D histogram aggregates measurements in fractions of a second
            for a given 1st dimension key.
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`1.TimeFrame(`0)">
            <summary>
            Returns a disposable instance suitable for time measurement in a "using" block
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`1.Start">
            <summary>
            Start sample time measurement
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`1.Stop(`0)">
            <summary>
            Stop sample time measurement started by Start() call
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`1.Sample(System.Double,`0)">
            <summary>
            Records time measurement in seconds
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`1.Clear">
            <summary>
            Reset internal histogram state
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`1.GetDimention(System.Int32)">
            <summary>
            Return a dimension of a histogram identified by index
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`1.GetPartitionName(System.Int32,System.Int32)">
            <summary>
            Returns the name of a partition in a given histogram dimension
            </summary>
            <param name="dimension">Dimension index</param>
            <param name="partition">Partition index</param>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.TimeHistogram`1.TryGet(NFX.Instrumentation.Analytics.HistogramKeys,System.Int32@)">
            <summary>
            Try to get the count of samples for the given histogram keys
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`1.Title">
            <summary>
            Histogram title used for displaying purposes
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`1.MinTime">
            <summary>
            Minimum time of all sample measurements
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`1.MaxTime">
            <summary>
            Maximum time of all sample measurements
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`1.AvgTime">
            <summary>
            Average time of all sample measurements
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`1.TotalSamples">
            <summary>
            Total number of samples in the histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`1.Dimensions">
            <summary>
            Returns the dimension instances of this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`1.DimensionCount">
            <summary>
            Number of dimensions in this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.TimeHistogram`1.Item(NFX.Instrumentation.Analytics.HistogramKeys)">
            <summary>
            Return the count of samples for the given histogram keys
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.Histogram`3">
            <summary>
            Three-dimensional histogram for storing number of samples for given
            dimension keys
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.Histogram">
            <summary>
            Base histogram to be used by typed histogram generic derived classes.
            The histogram holds a dictionary of integer counts for each measurement
            keys (with number of keys correspondent to the number of dimensions
            in the histogram).
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram.GetDimention(System.Int32)">
            <summary>
            Return a dimension of a histogram identified by index
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram.GetPartitionName(System.Int32,System.Int32)">
            <summary>
            Returns the name of a partition in a given histogram dimension
            </summary>
            <param name="dimension">Dimension index</param>
            <param name="partition">Partition index</param>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram.TryGet(NFX.Instrumentation.Analytics.HistogramKeys,System.Int32@)">
            <summary>
            Try to get the count of samples for the given histogram keys
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram.Clear">
            <summary>
            Reset histogram state
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram.DimensionCount">
            <summary>
            Number of dimensions in this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram.Title">
            <summary>
            Histogram title used for displaying purposes
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram.TotalSamples">
            <summary>
            Total number of samples in the histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram.Dimensions">
            <summary>
            Returns the dimension instances of this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram.Item(NFX.Instrumentation.Analytics.HistogramKeys)">
            <summary>
            Return the count of samples for the given histogram keys
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`3.#ctor(System.String,NFX.Instrumentation.Analytics.Dimension{`0},NFX.Instrumentation.Analytics.Dimension{`1},NFX.Instrumentation.Analytics.Dimension{`2})">
            <summary>
            Constructs a histogram from a given array of dimensions
            </summary>
            <param name="title">Histogram title used for displaying result</param>
            <param name="dimension1">Dimension of the 1st histogram dimension</param>
            <param name="dimension2">Dimension of the 2nd histogram dimension</param>
            <param name="dimension3">Dimension of the 3nd histogram dimension</param>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`3.TryGet(System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Try to get the sample count associated with the given histogram keys.
            If the keys are not present in the histogram dictionary return false
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`3.Sample(`0,`1,`2)">
            <summary>
            Increment histogram statistics for a given triplet of dimension values
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`3.Keys(`0,`1,`2)">
            <summary>
            Convert values to HistogramKeys struct
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`3.Value(`0,`1,`2)">
            <summary>
            Returns number of samples collected for a given key.
            The key is obtained by mapping the given values into the dimensions' partitions.
            Return value of 0 indicates that key is not present in the histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram`3.DimensionCount">
            <summary>
            Number of dimensions in this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram`3.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the sample count associated with given histogram keys
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.Histogram`2">
            <summary>
            Two-dimensional histogram for storing number of samples for given
            dimension keys
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`2.#ctor(System.String,NFX.Instrumentation.Analytics.Dimension{`0},NFX.Instrumentation.Analytics.Dimension{`1})">
            <summary>
            Constructs a histogram from a given array of dimensions
            </summary>
            <param name="title">Histogram title used for displaying result</param>
            <param name="dimension1">Dimension of the 1st histogram dimension</param>
            <param name="dimension2">Dimension of the 2nd histogram dimension</param>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`2.TryGet(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Try to get the sample count associated with the given histogram keys.
            If the keys are not present in the histogram dictionary return false
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`2.Sample(`0,`1)">
            <summary>
            Increment histogram statistics for a given pair of dimension values
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`2.Keys(`0,`1)">
            <summary>
            Convert values to HistogramKeys struct
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`2.Value(`0,`1)">
            <summary>
            Returns number of samples collected for a given key.
            The key is obtained by mapping the given values into the dimensions' partitions.
            Return value of 0 indicates that key is not present in the histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram`2.DimensionCount">
            <summary>
            Number of dimensions in this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram`2.Item(System.Int32,System.Int32)">
            <summary>
            Return the sample count associated with given histogram keys
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.Histogram`1">
            <summary>
            One-dimensional histogram for storing number of samples for a given
            dimension key
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`1.#ctor(System.String,NFX.Instrumentation.Analytics.Dimension{`0})">
            <summary>
            Constructs a histogram from a given array of dimensions
            </summary>
            <param name="title">Histogram title used for displaying result</param>
            <param name="dimension1">Dimension of the histogram dimension</param>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`1.TryGet(System.Int32,System.Int32@)">
            <summary>
            Try to get the sample count associated with the given histogram key.
            If the key is not present in the histogram dictionary return false
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`1.Sample(`0)">
            <summary>
            Increment histogram statistics for a given dimension value
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`1.Keys(`0)">
            <summary>
            Convert a value to HistogramKeys struct
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.Analytics.Histogram`1.Value(`0)">
            <summary>
            Returns number of samples collected for a given key.
            The key is obtained by mapping the given value into the dimension's partition.
            Return value of 0 indicates that key is not present in the histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram`1.DimensionCount">
            <summary>
            Number of dimensions in this histogram
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.Analytics.Histogram`1.Item(System.Int32)">
            <summary>
            Return the sample count associated with given histogram keys
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.HistogramKeys">
            <summary>
            Represents histogram dimension key vector.
            This class is introduced for performance enhancement vs int[] approach
            that would have allocated extra object on heap per call
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.HistogramEntry">
            <summary>
            The placeholder of histogram data that represents a sample count
            for a given set of histogram keys.
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.HistData">
            <summary>
            Helper type representing a dictionary for storing historam data
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.HistogramReporters">
            <summary>
            Maps histogram data into some other representation (such as text, HTML, etc)
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.PartitionFunc`1">
            <summary>
            References a function that maps input value into a partition index
            in the context of a given Partitioner
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.Analytics.PartitionNameFunc">
            <summary>
            Returns a partition name for a given partition index
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.ExceptionEvent">
            <summary>
            Represents an exception event recorded by instrumentation
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.ExceptionEvent.Record(System.Exception)">
            <summary>
            Create event from exception instance
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.ExceptionEvent.Record(System.String,System.Exception)">
            <summary>
            Create event from exception instance and source
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.ExceptionEvent.Record(System.String,System.Exception,System.DateTime)">
            <summary>
            Create event from exception instance as of utcTime
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IInstrumentation">
            <summary>
            Stipulates instrumentation contract
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.IInstrumentation.GetDatumTypeSources(System.Type,NFX.Instrumentation.Datum@)">
            <summary>
            Enumerates sources per Datum type ever recorded by the instance. This property may be used to build
             UIs for instrumentation, i.e. datum type tree. Returned data is NOT ORDERED.
             Returns default instance so caller may get default description/unit name
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.IInstrumentation.Record(NFX.Instrumentation.Datum)">
            <summary>
            Records instrumentation datum
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.IInstrumentation.GetBufferedResults(System.Int32)">
            <summary>
            Returns the specified number of samples from the ring result buffer in the near-chronological order,
            meaning that data is already sorted by time MOST of the TIME, however sorting is NOT GUARANTEED for all
             result records returned as enumeration is a lazy procedure that does not make copies/take locks.
            The enumeration is empty if ResultBufferSize is less or equal to zero entries.
            If count is less or equal to zero then the system returns all results available.
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.IInstrumentation.GetBufferedResultsSince(System.DateTime)">
            <summary>
            Returns samples starting around the the specified UTCdate in the near-chronological order,
            meaning that data is already sorted by time MOST of the TIME, however sorting is NOT GUARANTEED for all
             result records returned as enumeration is a lazy procedure that does not make copies/take locks.
            The enumeration is empty if ResultBufferSize is less or equal to zero entries
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.IInstrumentation.Enabled">
            <summary>
            Indicates whether instrumentation is enabled
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.IInstrumentation.Overflown">
            <summary>
            Returns true to indicate that instrumentation does not have any space left to record more data at the present moment
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.IInstrumentation.RecordCount">
            <summary>
            Returns current record count in the instance
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.IInstrumentation.MaxRecordCount">
            <summary>
            Gets/Sets the maximum record count that this instance can store
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.IInstrumentation.ProcessingIntervalMS">
            <summary>
            Specifies how often aggregation is performed
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.IInstrumentation.OSInstrumentationIntervalMS">
            <summary>
            Specifies how often OS instrumentation such as CPU and RAM is sampled.
            Value of zero disables OS sampling
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.IInstrumentation.SelfInstrumented">
            <summary>
            When true, outputs instrumentation data about the self (how many datum buffers, etc.)
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.IInstrumentation.ResultBufferSize">
            <summary>
            Returns the size of the ring buffer where result (aggregated) instrumentation records are kept in memory.
            The maximum buffer capacity is returned, not how many results have been buffered so far.
             If this property is less than or equal to zero then result buffering in memory is disabled
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.IInstrumentation.DataTypes">
            <summary>
            Enumerates distinct types of Datum ever recorded in the instance. This property may be used to build
             UIs for instrumentation, i.e. datum type tree. Returned data is NOT ORDERED
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.IInstrumentationImplementation">
            <summary>
            Stipulates instrumentation contract
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.InstrumentationService">
            <summary>
            Implements IInstrumentation. This service aggregates data by type,source and sends result into provider
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationService.#ctor">
            <summary>
            Creates a instrumentation service instance
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationService.#ctor(System.Object)">
            <summary>
            Creates a instrumentation service instance
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationService.Record(NFX.Instrumentation.Datum)">
            <summary>
            Records instrumentation datum
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationService.GetBufferedResults(System.Int32)">
            <summary>
            Returns the specified number of samples from the ring result buffer in the near-chronological order,
            meaning that data is already sorted by time MOST of the TIME, however sorting is NOT GUARANTEED for all
             result records returned as enumeration is a lazy procedure that does not make copies/take locks.
            The enumeration is empty if ResultBufferSize is less or equal to zero entries.
            If count is less or equal to zero then the system returns all results available.
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationService.GetBufferedResultsSince(System.DateTime)">
            <summary>
            Returns samples starting around the the specified UTCdate in the near-chronological order,
            meaning that data is already sorted by time MOST of the TIME, however sorting is NOT GUARANTEED for all
             result records returned as enumeration is a lazy procedure that does not make copies/take locks.
            The enumeration is empty if ResultBufferSize is less or equal to zero entries
            </summary>
        </member>
        <member name="M:NFX.Instrumentation.InstrumentationService.GetDatumTypeSources(System.Type,NFX.Instrumentation.Datum@)">
            <summary>
            Enumerates sources per Datum type ever recorded by the instance. This property may be used to build
             UIs for instrumentation, i.e. datum type tree. Returned data is NOT ORDERED
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.Overflown">
            <summary>
            Returns true to indicate that instrumentation does not have any space left to record more data
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.Provider">
            <summary>
            References provider that persists instrumentation data
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.ProcessingIntervalMS">
            <summary>
            Specifies how often aggregation is performed
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.OSInstrumentationIntervalMS">
            <summary>
            Specifies how often OS instrumentation such as CPU and RAM is sampled.
            Value of zero disables OS sampling
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.SelfInstrumented">
            <summary>
            When true, outputs instrumentation data about the self (how many datum buffers, etc.)
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.InstrumentationEnabled">
            <summary>
            Shortcut to SelfInstrumented, implements IInstrumentable
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.RecordCount">
            <summary>
            Returns current record count in the instance
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.MaxRecordCount">
            <summary>
            Gets/Sets the maximum record count that this instance can store
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.ResultBufferSize">
            <summary>
            Returns the size of the ring buffer where result (aggregated) instrumentation records are kept in memory.
            The maximum buffer capacity is returned, not how many results have been buffered so far.
             If this property is less than or equal to zero then result buffering in memory is disabled.
             This property can be set only on a stopped service
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.InstrumentationService.DataTypes">
            <summary>
            Enumerates distinct types of Datum ever recorded in the instance. This property may be used to build
             UIs for instrumentation, i.e. datum type tree. Returned data is NOT ORDERED
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.TypeBucketedData">
            <summary>
            Internal concurrent dictionary used for instrumentation data aggregation
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.SrcBucketedData">
            <summary>
            Internal concurrent dictionary used for instrumentation data aggregation
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.DatumBag">
            <summary>
            Internal concurrent bag used for instrumentation data aggregation
            </summary>
        </member>
        <member name="T:NFX.Instrumentation.NOPInstrumentation">
            <summary>
            Provides IInstrumentation implementation that does nothing
            </summary>
        </member>
        <member name="P:NFX.Instrumentation.NOPInstrumentation.Instance">
            <summary>
            Returns a singlelton instance of the NOPInstrumentation
            </summary>
        </member>
        <member name="T:NFX.Inventorization.BasicInventorization">
            <summary>
            Performs basic inventorization of Inventory-marked types and their members
            </summary>
        </member>
        <member name="T:NFX.Inventorization.IInventorization">
            <summary>
            Defines an abstraction of inventorization
            </summary>
        </member>
        <member name="T:NFX.Inventorization.Strategies">
            <summary>
            Defines a list of inventorization strategies
            </summary>
        </member>
        <member name="T:NFX.Inventorization.InventorizationManager">
            <summary>
            Performs an inventory scan of supplied assemblies using specified options.
            Items to be included in result must be tagged with Inventory attribute, otherwise then will be omitted unless OnlyAttributed == false.
            The scan is performed using options and inventorization strategies.
            This class is NOT THREAD SAFE
            </summary>
        </member>
        <member name="M:NFX.Inventorization.InventorizationManager.#ctor(System.String,System.String)">
            <summary>
            Delimiter assembly names with ';'
            </summary>
        </member>
        <member name="M:NFX.Inventorization.InventorizationManager.Run(NFX.Environment.ConfigSectionNode)">
            <summary>
            Runs inventorization routine dumping result into config node
            </summary>
        </member>
        <member name="M:NFX.Inventorization.InventorizationManager.WriteInventoryAttributes(System.Collections.Generic.IEnumerable{NFX.Inventorization.InventoryAttribute},NFX.Environment.ConfigSectionNode)">
            <summary>
            Adds nodes for InventoryAttributes
            </summary>
        </member>
        <member name="M:NFX.Inventorization.InventorizationManager.WriteType(System.Type,NFX.Environment.ConfigSectionNode)">
            <summary>
            Describes type including generic arguments
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventorizationManager.Strategies">
            <summary>
            References inventorization strategies
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventorizationManager.Options">
            <summary>
            Options for inventorization strategies
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventorizationManager.OnlyAttributed">
            <summary>
            When true, inventorizes ONLY items that have have Inventory attribute applied.
            Even if this property is false but some other inventory filter specified, then an item must be Inventory-tagged to be included
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventorizationManager.Tiers">
            <summary>
            Imposes a filter on system tiers parameter of Inventory attribute
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventorizationManager.Concerns">
            <summary>
            Imposes a filter on system concerns parameter of Inventory attribute
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventorizationManager.Technology">
            <summary>
            Imposes a filter on technology parameter of Inventory attribute
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventorizationManager.Schema">
            <summary>
            Imposes a filter on schema parameter of Inventory attribute
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventorizationManager.Tool">
            <summary>
            Imposes a filter on tool parameter of Inventory attribute
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventorizationManager.StartDate">
            <summary>
            Imposes a filter on StartDate parameter of Inventory attribute
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventorizationManager.EndDate">
            <summary>
            Imposes a filter on EndDate parameter of Inventory attribute
            </summary>
        </member>
        <member name="T:NFX.Inventorization.InventorizationException">
            <summary>
            Base exception thrown by inventorization operations
            </summary>
        </member>
        <member name="T:NFX.IO.WritingStreamer">
            <summary>
            Writes primitives to stream
            </summary>
        </member>
        <member name="T:NFX.IO.Streamer">
            <summary>
            Represents a base for stream readers and writers.
            Streamer object instances ARE NOT THREAD-safe
            </summary>
        </member>
        <member name="M:NFX.IO.Streamer.BindStream(System.IO.Stream)">
            <summary>
            Sets the stream as the target for output/input.
            This call must be coupled with UnbindStream()
            </summary>
        </member>
        <member name="M:NFX.IO.Streamer.UnbindStream">
            <summary>
            Unbinds the current stream. This call is coupled with BindStream(stream)
            </summary>
        </member>
        <member name="P:NFX.IO.Streamer.Format">
            <summary>
            Returns format that this streamer implements
            </summary>
        </member>
        <member name="P:NFX.IO.Streamer.Stream">
            <summary>
            Returns underlying stream if it is bound or null
            </summary>
        </member>
        <member name="P:NFX.IO.Streamer.Encoding">
            <summary>
            Returns stream string encoding
            </summary>
        </member>
        <member name="T:NFX.IO.ReadingStreamer">
            <summary>
            Reads primitives from stream
            </summary>
        </member>
        <member name="T:NFX.IO.VarIntStr">
            <summary>
            Holds either an integer or a string value.
            This is useful for metadata, i.e. types, if type is known an integer is sent, otherwise a full type name is sent
            </summary>
        </member>
        <member name="T:NFX.IO.MetaHandle">
            <summary>
            Represents a tuple of an unsigned integer with optional int or string metadata. If metadata is null then integer is stored by itself in an efficient way.
            The type is useful for storage of handles/indexes (such as pointer surrogates) with optional description of pointed-to data (such as type information).
            A special case is reserved for strings which are immutable yet reference types, in which case a special handle INLINED_STRING_HANDLE is set to indicate that
             "Metadata" really contains string data that this handle should resolve into. Check "IsInlinedString" property to see if string was inlined.
            Check "IsInlinedValueType" is set to true when a struct/valuetype is inlined and "Metadata" contains type spec
            </summary>
        </member>
        <member name="M:NFX.IO.MetaHandle.InlineString(System.String)">
            <summary>
            Inlines string instance instead of pointer handle
            </summary>
        </member>
        <member name="M:NFX.IO.MetaHandle.InlineValueType(System.Nullable{NFX.IO.VarIntStr})">
            <summary>
            Inlines value type instead of pointer handle
            </summary>
        </member>
        <member name="M:NFX.IO.MetaHandle.InlineRefType(System.Nullable{NFX.IO.VarIntStr})">
            <summary>
            Inlines ref type instead of pointer handle
            </summary>
        </member>
        <member name="M:NFX.IO.MetaHandle.InlineTypeValue(System.Nullable{NFX.IO.VarIntStr})">
            <summary>
            Inlines type value instead of pointer handle
            </summary>
        </member>
        <member name="P:NFX.IO.MetaHandle.Handle">
            <summary>
            Returns handle value. This value is invalid if special conditions such as inlining are true
            </summary>
        </member>
        <member name="P:NFX.IO.MetaHandle.IsInlinedString">
            <summary>
            Indicates whether a string instance is inlined in Metadata property
            </summary>
        </member>
        <member name="P:NFX.IO.MetaHandle.IsInlinedValueType">
            <summary>
            Indicates whether a struct (value type) instance is inlined right after this handle and Metadata property contains type
            </summary>
        </member>
        <member name="P:NFX.IO.MetaHandle.IsInlinedRefType">
            <summary>
            Indicates whether a reference (reference type) instance is inlined right after this handle and Metadata property contains type.
            This is used for handling of ref types that are natively supported by streamers
            </summary>
        </member>
        <member name="P:NFX.IO.MetaHandle.IsInlinedTypeValue">
            <summary>
            Indicates whether a reference to TYPE is inlined - that is a Metadata parameter points to the value of type (reference to Type)
            </summary>
        </member>
        <member name="T:NFX.IO.NFXIOException">
            <summary>
            Base exception thrown by the IO-related classes
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.LogServiceDestination">
            <summary>
            Implements a destination that is based on another instance of LogService, which provides asynchronous buffering and failover capabilities.
            </summary>
        </member>
        <member name="T:NFX.Log.MessageFilterExpression">
            <summary>
            Defines an expression used for log message filtering.
            Important: it is not a good practice to create many different scopes as it leads to creation of many assemblies dynamically
            </summary>
        </member>
        <member name="T:NFX.Parsing.CompilingExpressionEvaluator`3">
            <summary>
            Implements an evaluator that compiles all expressions represented by instances of this class in a certain scope into dynamic assemblies.
            Every unique scope name creates a separate assembly.
            The compilation of scope is triggered either by a call to Compile() or first attempt to call Evaluate() on any instance within a scope.
            Once a scope has been compiled, no further allocations in this scoped are allowed, this is because CLR does not allow to unload assemblies dynamically.
            Within an expression context is passed as "ctx" and argument as "arg".
            This class is thread-safe.
            </summary>
        </member>
        <member name="M:NFX.Parsing.CompilingExpressionEvaluator`3.IsScopeAlreadyCompiled(System.String)">
            <summary>
            Indicates whether this scope has already been compiled and no more epressions can be allocated in it
            </summary>
        </member>
        <member name="M:NFX.Parsing.CompilingExpressionEvaluator`3.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Allocates a new expression. This call fails if the scope was already compiled
            </summary>
            <param name="scope">A valid identifier for namespace sub-path like "mycode.test" no leading or trailing "."</param>
            <param name="expression">A C# expression to compile</param>
            <param name="referencedAssemblies"> An enumerable of assemblies that compiler should reference while building scope assembly i.e. "MyCompany.dll"</param>
            <param name="usings">Extra usings i.e. "System.IO", "MyCode.Routines" etc.</param>
        </member>
        <member name="M:NFX.Parsing.CompilingExpressionEvaluator`3.Compile">
            <summary>
            Forces the entire scope compilation now, so no delay is incurred on first call to Evaluate().
            </summary>
        </member>
        <member name="M:NFX.Parsing.CompilingExpressionEvaluator`3.Evaluate(`0,`2)">
            <summary>
            Evaluates expression using supplied arg in a context.
            Context is passed as "ctx" and argument as "arg".
            </summary>
        </member>
        <member name="P:NFX.Parsing.CompilingExpressionEvaluator`3.Scope">
            <summary>
            Returns a scope (similar to compilation unit / assembly) that this expression is in
            </summary>
        </member>
        <member name="P:NFX.Parsing.CompilingExpressionEvaluator`3.Expression">
            <summary>
            Returns an original expression as string that is to be evaluated
            </summary>
        </member>
        <member name="M:NFX.Log.MessageFilterExpression.#ctor(System.String)">
            <summary>
            Creates a new expression in a default logging filter scope.
            This .ctor will fail if at least one expression from this scope has already been compiled
            </summary>
        </member>
        <member name="M:NFX.Log.MessageFilterExpression.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Use this .ctor to specify a different scope name. Every unique scope name gets compiled into a new assembly,
            consequently it is not a good practice to create many different scopes.
            This .ctor will fail if at least one expression from this scope has already been compiled
            </summary>
        </member>
        <member name="T:NFX.Inventorization.SystemTiers">
            <summary>
            Designates system architecture tiers
            </summary>
        </member>
        <member name="T:NFX.Inventorization.SystemConcerns">
            <summary>
            Designates item concerns
            </summary>
        </member>
        <member name="T:NFX.Inventorization.InventoryAttribute">
            <summary>
            Defines an inventory-related set of data which is used by automatic code/component discovery
            such as database schema generation tools and system-global registry servers
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventoryAttribute.Tiers">
            <summary>
            Designates what tier this entry is for
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventoryAttribute.Concerns">
            <summary>
            Indicates what concerns this entry relates to
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventoryAttribute.Technology">
            <summary>
            A type of implementaton that this inventory entry refers to, i.e. "Oracle", "MongoDB", "Riak"
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventoryAttribute.Schema">
            <summary>
            Provides a name of schema for this item, for example [Inventory(Technology="MongoDB", Schema="UserTransactions")]
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventoryAttribute.Tool">
            <summary>
            Provides an optional name of an applicable tool [Inventory(Tool="ErlangModuleGenerator")]
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventoryAttribute.StartDate">
            <summary>
            Provides an optional start date i.e. when this item will start to be used
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventoryAttribute.EndDate">
            <summary>
            Provides an optional end date i.e. when this item will be phased out
            </summary>
        </member>
        <member name="P:NFX.Inventorization.InventoryAttribute.Parameters">
            <summary>
            Parameters for particular inventory entry. This can be used as params for auto-generating tools that scan inventories
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.ConsoleDestination">
            <summary>
            Logs messages in stdio.console
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.ConsoleDestination.LogTimeFormat">
            <summary>
            Time format for log line entries
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.CompositeDestination">
            <summary>
            Provides an abstraction of a wrap around another destinations
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.CompositeDestination.RegisterDestination(NFX.Log.Destinations.Destination)">
            <summary>
            Adds a destination to this wrapper
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.CompositeDestination.UnRegisterDestination(NFX.Log.Destinations.Destination)">
            <summary>
            Removes a destiantion from this wrapper, returns true if destination was found and removed
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.CompositeDestination.Destinations">
            <summary>
            Returns destinations that this destination wraps. This call is thread safe
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.FloodFilter">
            <summary>
            Implements a destination group that stops message flood
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.FloodFilter.#ctor">
            <summary>
            Creates a filter that prevents message flood
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.FloodFilter.#ctor(NFX.Log.Destinations.Destination[])">
            <summary>
            Creates a filter that prevents message flood
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.FloodFilter.#ctor(System.String,NFX.Log.Destinations.Destination[])">
            <summary>
            Creates a filter that prevents message flood
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.FloodFilter.MaxCount">
            <summary>
            Sets how many messages may be batched per interval. If more messages arrive then their data is not going to be logged
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.FloodFilter.MaxTextLength">
            <summary>
            Imposes a limit in character length of combined message test
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.FloodFilter.MessageType">
            <summary>
            Determines the message type for message emitted when flood is detected
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.FloodFilter.MessageTopic">
            <summary>
            Determines the message topic for message emitted when flood is detected
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.FloodFilter.MessageFrom">
            <summary>
            Determines the message from for message emitted when flood is detected
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.FloodFilter.MessageSource">
            <summary>
            Determines the message topic for message emitted when flood is detected
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.SMTPDestination">
            <summary>
            Implements log destination that sends emails
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.SMTPDestination.#ctor">
            <summary>
            Creates a new instance of destination that sends EMails
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.SMTPDestination.#ctor(System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Creates a new instance of destination that sends EMails
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.SyslogDestination">
            <summary>
            Implements destination that sends messages to UNIX syslog using UDP datagrams
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.SyslogDestination.#ctor">
            <summary>
            Creates a new instance of destination that sends messages to .nix SYSLOG
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.SyslogDestination.#ctor(System.String,System.String,System.Int32)">
            <summary>
            Creates a new instance of destination that sends messages to .nix SYSLOG
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.SyslogDestination.Client">
            <summary>
            References the underlying syslog client instance
            </summary>
        </member>
        <member name="T:NFX.Log.Syslog.FacilityLevel">
            <summary>
            Standard SYSLOG severity levels http://en.wikipedia.org/wiki/Syslog
            </summary>
        </member>
        <member name="T:NFX.Log.Syslog.SeverityLevel">
            <summary>
            Standard SYSLOG severity levels http://en.wikipedia.org/wiki/Syslog
            </summary>
        </member>
        <member name="T:NFX.Log.Syslog.SyslogClient">
            <summary>
            Implements SYSLOG UDP client
            </summary>
        </member>
        <member name="T:NFX.Log.Syslog.SyslogMessage">
            <summary>
            Represents a UNIX-standard SYSLOG message
            </summary>
        </member>
        <member name="T:NFX.Parsing.CharCodes">
            <summary>
            Declares common char codes
            </summary>
        </member>
        <member name="T:NFX.ReferenceEqualityComparer`1">
            <summary>
            Checks for reference equality. Use ReferenceEqualityComparer(T).Instance
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.TargetType">
            <summary>
            Specifies a type of target that compiler produces output for
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.NameCaseSensitivity">
            <summary>
            Denotes naming case sensitivity
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.Compiler">
            <summary>
            Represents a compiler that can turn source schema into particular target script/schema, i.e. into database creation script for particular technology
             (i.e. Oracle, MySQL, PostgreSQL, etc..) or some other code/script (i.e. RecordModel classes, JavaScript classes)
            </summary>
        </member>
        <member name="F:NFX.RelationalModel.Compiler.SCRIPT_INCLUDE_SECTION">
            <summary>
            Specifies the name of the file to be included in the output verbatim, i.e.:  script-include="mytypes.txt"{}
            </summary>
        </member>
        <member name="F:NFX.RelationalModel.Compiler.SCRIPT_COMMENT_ATTR">
            <summary>
            Specifies the comment that will be output for decorated entity in the script
            </summary>
        </member>
        <member name="F:NFX.RelationalModel.Compiler.SCRIPT_TEXT_SECTION">
            <summary>
            Specifies the text to be included in the output verbatim, i.e.:  script-text="INSERT INTO TBL_ABC VALUES(1, true, now())"{}
            </summary>
        </member>
        <member name="F:NFX.RelationalModel.Compiler.SCRIPT_OUTPUT_NAME_ATTR">
            <summary>
            Specifies the name of the output that script text has to be placed in
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.Compiler.GetOutputFileSuffix(System.String)">
            <summary>
            Override to provide meaningful extension for particular technology, i.e. SQL
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.Compiler.DoCompile">
            <summary>
            Performs a compilation - this is a root  override-able method where compilation starts
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.Compiler.BuildOutputs(NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Override to perform compilation into output, the base implementation loops over all nodes and interprets
             script includes
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.Compiler.BuildNodeOutput(NFX.Environment.IConfigSectionNode,NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Override to perform custom interpretation per particular compiler target
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.Compiler.IncludeScriptFile(NFX.Environment.IConfigSectionNode,NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Performs a script file include
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.Compiler.IncludeScriptText(NFX.Environment.IConfigSectionNode,NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Performs a verbatim script text include
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.Compiler.EscapeFileName(System.String)">
            <summary>
            Replaces incompatible characters for file names with "_"
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.Name">
            <summary>
            Returns the name of the technology that this compiler targets. i.e. "ORACLE", "RecordModel"
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.Target">
            <summary>
            Returns type of target that this instance produces output for
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.Schema">
            <summary>
            Returns source schema
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.HasCompiled">
            <summary>
            Returns true to indicate that compiler has already processed the source schema
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.CompileException">
            <summary>
            Returns exception that surfaced during compilation, or null if source has not compiled yet or no exception happened.
            This exception is different form CompileErrors because it indicates some un=planned condition that broke the compilation process
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.CompileErrors">
            <summary>
            Returns exception errors that were generated during compilation. This property returns "planned" errors that were caused by input,
             whereas CompileException returns exception that indicates some more drastic abnormality that broke the compilation
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.HasErrors">
            <summary>
            Returns true when this instance did not compile properly
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.NameCaseSensitivity">
            <summary>
            Determines whether output script is case sensitive
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.NameComparison">
            <summary>
            Returns string comparison options for names that depend on target case sensitivity
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.OutputPath">
            <summary>
            Determines where compiled output is placed
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.OutputPrefix">
            <summary>
            Determines the prefix for output names
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Compiler.Outputs.CurrentOrUnspecified">
            <summary>
            Returns last output used or Unspecified output
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.MsSQLServerCompiler">
            <summary>
            Compiles relation schema into Ms SQL Server scripts
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.RDBMSCompiler">
            <summary>
            Compiles schema scripts into RDBMS-family of outputs - the ones that have tables, keys, indexes, constraints etc...
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.CreateDomain(System.String,System.String,NFX.Environment.IConfigNode)">
            <summary>
            Turns domain name into domain instance
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.TransformEntityName(NFX.RelationalModel.RDBMSEntity)">
            <summary>
            Override to map a name from schema into the name that should be used in the output (i.e. real table name)
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.GetQuotedIdentifierName(NFX.RelationalModel.RDBMSEntityType,System.String)">
            <summary>
            Gets quoted name per particular technology
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.GetStatementDelimiterScript(NFX.RelationalModel.RDBMSEntityType,System.Boolean)">
            <summary>
            Override to return statement delimiter script for particular target , i.e. "Go" at the statementend for MsSQL Server T-SQL
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.DoTable(NFX.Environment.IConfigSectionNode,NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Override to compile a RDBMS Table
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.DoTableIndexes(NFX.RelationalModel.RDBMSEntity,NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Override to compile a indexes per table
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.DoColumn(NFX.Environment.IConfigSectionNode,NFX.RelationalModel.RDBMSEntity,System.Text.StringBuilder,System.Boolean@,NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Override to compile a RDBMS Table
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.DoReadPrimaryKeySection(NFX.Environment.IConfigSectionNode,NFX.RelationalModel.RDBMSEntity)">
            <summary>
            Override to read primary key definition form sub-section of table (not column level)
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.DoPrimaryKeys(NFX.RelationalModel.RDBMSEntity,System.Text.StringBuilder,System.Boolean@)">
            <summary>
            Override to output primary keys
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.DoForeignKeys(NFX.RelationalModel.RDBMSEntity,System.Text.StringBuilder,System.Boolean@,NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Override to outpur foreign keys
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.RDBMSCompiler.DoReadIndexSection(NFX.Environment.IConfigSectionNode,NFX.RelationalModel.RDBMSEntity)">
            <summary>
            Override to read primary key definition form sub-section of table (not column level)
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.RDBMSCompiler.DomainSearchPaths">
            <summary>
            Gets/sets ';' separated list of domain search namespaces paths
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.RDBMSCompiler.SeparateIndexes">
            <summary>
            Gets/sets the flag that indicates whether indexes should be written in the separate output from tables
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.RDBMSCompiler.SeparateForeignKeys">
            <summary>
            Gets/sets the flag that indicates whether foreign keys should be written in the separate output from tables.
            Foreign keys get added as constraints under the table when referenced table is already present and this flag is false
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.DataTypes.Domain">
            <summary>
            Represents a domain - a named type
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.DataTypes.Domain.Name">
            <summary>
            Returns the name of this domain, i.e. 'THumanAge', 'TSalary'
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.DataTypes.RDBMSDomain">
            <summary>
            Represents a domain - named type with optional constraints/checks for permitted values
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.DataTypes.RDBMSDomain.GetTypeName(NFX.RelationalModel.RDBMSCompiler)">
            <summary>
            Returns the name of the resulting type that this domain maps to
            </summary>
            <param name="compiler">The context that the result depends on </param>
            <returns>Target type name, i.e. BIGINT, DECIMAL(8,2) etc...</returns>
        </member>
        <member name="M:NFX.RelationalModel.DataTypes.RDBMSDomain.GetColumnRequirement(NFX.RelationalModel.RDBMSCompiler)">
            <summary>
            Returns true to indicate that column of this type is always required
            </summary>
            <param name="compiler">The context that the result depends on </param>
        </member>
        <member name="M:NFX.RelationalModel.DataTypes.RDBMSDomain.TransformColumnName(NFX.RelationalModel.RDBMSCompiler,NFX.RelationalModel.RDBMSEntity)">
            <summary>
            Changes column name, i.e. adds prefix
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.DataTypes.RDBMSDomain.GetColumnAutoGeneratedScript(NFX.RelationalModel.RDBMSCompiler,NFX.RelationalModel.RDBMSEntity,NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Returns script for auto-generated values, may also emit compiler-specific object like sequence or generator
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.DataTypes.RDBMSDomain.GetColumnDefaultScript(NFX.RelationalModel.RDBMSCompiler,NFX.RelationalModel.RDBMSEntity,NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Returns script for default values, may also emit compiler-specific object like sequence or generator or insert rows in some other table
            </summary>
        </member>
        <member name="M:NFX.RelationalModel.DataTypes.RDBMSDomain.GetColumnCheckScript(NFX.RelationalModel.RDBMSCompiler,NFX.RelationalModel.RDBMSEntity,NFX.RelationalModel.Compiler.Outputs)">
            <summary>
            Returns script for check constraint on column level
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.RelationalException">
            <summary>
            Base exception thrown by the Relational-* framework
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.SchemaException">
            <summary>
            Thrown by relational schema
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.CompilerException">
            <summary>
            Thrown by relational schema compiler
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.SchemaCompilationException">
            <summary>
            Thrown by relational schema compiler while processing the source schema
            </summary>
        </member>
        <member name="F:NFX.RelationalModel.SchemaCompilationException.NodePath">
            <summary>
            Returns node that issued compilation error
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.MySQLCompiler">
            <summary>
            Compiles relation schema into MySQL scripts
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.RDBMSEntityType">
            <summary>
            Denotes a type of RDBMS entity
            </summary>
        </member>
        <member name="T:NFX.RelationalModel.Schema">
            <summary>
            Represents an instance of relational schema source
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Schema.SourceScriptRunner">
            <summary>
            Returns script runner used for schema source evaluation. Null returned when no scripts were executed
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Schema.SourceOriginal">
            <summary>
            Returns the source root tree before script was run but all includes processed
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Schema.Source">
            <summary>
            Returns the source root tree after includes were processed and script was run
            </summary>
        </member>
        <member name="P:NFX.RelationalModel.Schema.IncludePaths">
            <summary>
            Returns include paths that are searched for included files
            </summary>
        </member>
        <member name="T:NFX.Scope">
             <summary>
             Helper class to be used in the context of 'using' clause to
             facilitate cleanup on scope exit and performing of other functions
             such as status logging
             </summary>
             <remarks>
             Typical use case:
             <code>
               using(Scope.OnExit(() => Bell.Ring()))
               {
                  ... do something ...
               }
            
               using(Scope.OnExit&lt;bool>(
                             ()  => { var old = Tracing.IsOn; Tracing.Off(); return old; },
                             (b) => Tracing.State(b)))
               {
                  ... do something ...
               }
             </code>
             </remarks>
        </member>
        <member name="T:NFX.EmbeddedResource">
            <summary>
             Fetches resources such as script statement text by scriptName from assembly resource stream.
             Mostly used for SQL and JavaScript but maybe used for any text retrieval.
             This class is 100% safe for multithreading operations.
             Script texts are cached in ram for faster subsequent access.
            </summary>
        </member>
        <member name="M:NFX.EmbeddedResource.GetText(System.Type,System.String)">
            <summary>
            Pass a type and resource path rooted at type's namespace, for example
             given <code> string sql = typeof(SomeType).GetText("SQL.User.Insert.sql");</code>
             If "SomeType" is declared in "TestApp.Types", then statement's resource will have to be embedded under resource named:
              "TestApp.Types.SQL.User.Insert.sql"
            </summary>
        </member>
        <member name="M:NFX.EmbeddedResource.GetBinaryStream(System.Type,System.String)">
            <summary>
            Pass a type and resource path rooted at type's namespace, for example
             given <code> using (var stream = typeof(SomeType).GetBinary("My.Picture.gif")){...}</code>
             If "SomeType" is declared in "TestApp.Types", then statement's resource will have to be embedded under resource named:
              "TestApp.Types.My.Picture.gif"
            </summary>
        </member>
        <member name="M:NFX.EmbeddedResource.GetBinaryContent(System.Type,System.String)">
            <summary>
            Pass a type and resource path rooted at type's namespace, for example
             given <code> using (var stream = typeof(SomeType).GetBinary("My.Picture.gif")){...}</code>
             If "SomeType" is declared in "TestApp.Types", then statement's resource will have to be embedded under resource named:
              "TestApp.Types.My.Picture.gif"
            </summary>
        </member>
        <member name="T:NFX.DisposedObjectException">
            <summary>
            This exception is thrown from DisposableObject.EnsureObjectNotDisposed() method
            </summary>
        </member>
        <member name="T:NFX.Environment.BuildInformation">
            <summary>
            Retrieves build information encapsulated into a module in the form of an embedded resource
            </summary>
        </member>
        <member name="M:NFX.Environment.BuildInformation.#ctor">
            <summary>
            Creates an instance of BuildInformation class for framework
            </summary>
        </member>
        <member name="M:NFX.Environment.BuildInformation.#ctor(System.Reflection.Assembly,System.String,System.Boolean)">
            <summary>
            Creates and instance of BuildInformation class from the specified resource path in particular assembly.
            If assembly is null then BuildInformation for the whole framework is returned.
            If Path is null then the first found BUILD info resource is used from the specified assembly
            </summary>
        </member>
        <member name="P:NFX.Environment.BuildInformation.ForFramework">
            <summary>
            Return framework build information
            </summary>
        </member>
        <member name="P:NFX.Environment.BuildInformation.AssemblyName">
            <summary>
            Rertuns assembly name that this information was obtained from
            </summary>
        </member>
        <member name="P:NFX.Environment.BuildInformation.BuildSeed">
            <summary>
            Returns random number assigned to a build. It is NOT guaranteed to be unique
            </summary>
        </member>
        <member name="P:NFX.Environment.BuildInformation.Computer">
            <summary>
            A name of the computer that performed build
            </summary>
        </member>
        <member name="P:NFX.Environment.BuildInformation.User">
            <summary>
            a name of user that build session was logged under
            </summary>
        </member>
        <member name="P:NFX.Environment.BuildInformation.OS">
            <summary>
            OS name
            </summary>
        </member>
        <member name="P:NFX.Environment.BuildInformation.OSVer">
            <summary>
            OS version name
            </summary>
        </member>
        <member name="P:NFX.Environment.BuildInformation.DateStampUTC">
            <summary>
            Date and time stamp when build was performed
            </summary>
        </member>
        <member name="T:NFX.Environment.CommandArgsConfiguration">
             <summary>
             Provides implementation of configuration based on arguments supplied from command line
              which is "string[]". Arguments start with either "/" or "-" prefix. If any argument is not
              prefixed then it is written as an auto-named attribute node of the root with its value set, otherwise a section (under root) with
               argument's name is created. Any argument may have options. Any option may either consist of name
                or name value pair delimited by "=".
              Argument options are written as attribute nodes of their corresponding sections.
              If option value specified without name (without "=") then option is auto-named
             </summary>
             <example>
              Given command line:
               <code>
               c:\>dosomething.exe "c:\input.file" "d:\output.file" -compress level=100 method=zip -shadow fast -large
               </code>
              The following configuration object will be created from the supplied args:
              <code>
                [args ?1="c:\input.file" ?2="c:\output.file"]
                  [compress level="100" method="zip"]
                  [shadow ?1="fast"]
                  [large]
              </code>
            
              Use args:
              <code>
               var conf = new CmdArgsConfiguration(args);
               var inFile = conf.Root.AttrByIndex(0).ValueAsString(DEFAULT_INPUT_FILE);
               var outFile = conf.Root.AttrByIndex(1).ValueAsString(DEFAULT_OUTPUT_FILE);
               .....
                if (conf.Root["large"].Exists) .......
               .....
               var level = conf.Root["compress"].AttrByName("level").ValueAsInt(DEFAULT_COMPRESSION_LEVEL);
               .....
              </code>
            
             </example>
        </member>
        <member name="M:NFX.Environment.CommandArgsConfiguration.#ctor(System.String[])">
            <summary>
            Creates an instance of the new configuration parsed from command line arguments
            </summary>
        </member>
        <member name="M:NFX.Environment.CommandArgsConfiguration.#ctor(System.String[],System.Boolean)">
            <summary>
            Creates an instance of the new configuration parsed from command line arguments
            </summary>
        </member>
        <member name="P:NFX.Environment.CommandArgsConfiguration.IsReadOnly">
            <summary>
            Indicates whether configuration is readonly or may be modified and saved
            </summary>
        </member>
        <member name="P:NFX.Environment.CommandArgsConfiguration.InhibitSlashArg">
            <summary>
            When true, disregards '/' as an argument delimiter
            </summary>
        </member>
        <member name="P:NFX.Environment.CommandArgsConfiguration.Arguments">
            <summary>
            Returns arguments array that this configuration was parsed from
            </summary>
        </member>
        <member name="T:NFX.Environment.ConfigNode">
            <summary>
            Provides configuration node abstraction for section and attribute nodes. This class is thread-safe
            </summary>
        </member>
        <member name="T:NFX.Environment.IConfigNode">
            <summary>
            Provides read-only configuration node abstraction for section and attribute nodes
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigNode.ValueAsType(System.Type,System.Boolean,System.Boolean)">
            <summary>
            Tries to get value as specified type or throws if it can not be converted
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigNode.IsSameName(NFX.Environment.IConfigNode)">
            <summary>
            Returns true when another node has the same name as this one
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigNode.IsSameName(System.String)">
            <summary>
            Returns true when another name is the same as this node's name
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigNode.Configuration">
            <summary>
            References configuration this node is under
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigNode.Exists">
            <summary>
            Determines whether this node really exists in configuration or is just a sentinel empty node
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigNode.VerbatimValue">
            <summary>
            Returns varbatim (without variable evaluation) node value or null
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigNode.EvaluatedValue">
            <summary>
            Returns null or value of this node with all variables evaluated
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigNode.Value">
            <summary>
            Returns null or value of this node with all variables evaluated
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigNode.Parent">
            <summary>
            References parent node or empty node if this is the top-most node with no parent
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigNode.RootPath">
            <summary>
            Returns a path from root to this node
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigNode.#ctor(NFX.Environment.Configuration,NFX.Environment.ConfigSectionNode,NFX.Environment.IConfigNode)">
            <summary>
            Creates new node by cloning other node from this or another configuration
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigNode.ResetModified">
            <summary>
            Resets modification flag
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigNode.ValueAsType(System.Type,System.Boolean,System.Boolean)">
            <summary>
            Tries to get value as specified type or throws if it can not be converted
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigNode.IsSameName(NFX.Environment.IConfigNode)">
            <summary>
            Returns true when another node has the same name as this one per case-insensitive culture-neutral comparison
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigNode.IsSameName(System.String)">
            <summary>
            Returns true when another name is the same as this node's name per case-insensitive culture-neutral comparison
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigNode.Configuration">
            <summary>
            References configuration this node is under
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigNode.Exists">
            <summary>
            Determines whether this node really exists in configuration or is just a sentinel empty node
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigNode.Name">
            <summary>
            Retrieves node name
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigNode.VerbatimValue">
            <summary>
            Returns verbatim (without variable evaluation) node value or null
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigNode.EvaluatedValue">
            <summary>
            Returns null or value of this node with all variables evaluated
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigNode.Value">
            <summary>
            Retrieves node value or null. The value getter performs evaluation of variables, while setter sets the value verbatim
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigNode.Parent">
            <summary>
            References parent node or Empty if this node has no parent
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigNode.NFX#Environment#IConfigNode#Parent">
            <summary>
            References parent node
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigNode.Modified">
            <summary>
            Indicates whether a node was modified
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigNode.RootPath">
            <summary>
            Returns path from root to this node
            </summary>
        </member>
        <member name="T:NFX.Environment.ConfigSectionNode">
            <summary>
            Represents configuration section node. This class is thread safe
            </summary>
        </member>
        <member name="T:NFX.Environment.IConfigSectionNode">
            <summary>
            Provides read-only configuration section node abstraction
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.AttrByName(System.String,System.Boolean)">
            <summary>
            Returns attribute node by its name or empty attribute if real attribute with such name does not exist
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.AttrByIndex(System.Int32)">
            <summary>
            Returns attribute node by its index or empty attribute if real attribute with such index does not exist
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.Navigate(System.String)">
            <summary>
            Navigates the path and return the appropriate node. Example '!/nfx/logger/destination/$file-name'
            </summary>
            <param name="path">If path starts from '!' then exception will be thrown if such a node does not exist;
             Use '/' as leading char for root,
             '..' for step up,
             '$' for attribute name. Multiple paths may be coalesced using '|' or ';'
            </param>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.NavigateSection(System.String)">
            <summary>
            Navigates the path and return the appropriate section node. Example '!/nfx/logger/destination'
            </summary>
            <param name="path">If path starts from '!' then exception will be thrown if such a section node does not exist;
             Use '/' as leading char for root,
             '..' for step up. Multiple paths may be coalesced using '|' or ';'
            </param>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.EvaluateValueVariables(System.String)">
            <summary>
            Evaluates a value string expanding all variables with var-paths relative to this node.
            Evaluates configuration variables such as "$(varname)" or "$(@varname)". Varnames are paths
            to other config nodes from the same configuration or variable names when prefixed with "~". If varname starts with "@" then it gets combined
             with input as path string. "~" is used to qualify environment vars that get resolved through Configuration.EnvironmentVarResolver
             Example: `....add key="Schema.$(/A/B/C/$attr)" value="$(@~HOME)bin\Transforms\"...`
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.IsSameNameAttr(NFX.Environment.IConfigSectionNode)">
            <summary>
            Returns true when this and another nodes both have attribute "name" and their values are equal per case-insensitive culture-neutral comparison
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.IsSameNameAttr(System.String)">
            <summary>
            Returns true when this node has an attribute called "name" and its value is euqal to the supplied value per case-insensitive culture-neutral comparison
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.ToLaconicString(NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions)">
            <summary>
            Serializes configuration tree rooted at this node into Laconic format and returns it as a string
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.ToJSONDataMap">
            <summary>
            Converts this ConfigSectionNode to JSONDataMap. Contrast with ToConfigurationJSONDataMap
            Be carefull: that this operation can "loose" data from ConfigSectionNode.
            In other words some ConfigSectionNode information can not be reflected in corresponding JSONDataMap, for example
             this method overwrites duplicate key names and does not support section values
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.ToConfigurationJSONDataMap">
            <summary>
            Returns the contents of this node per JSONConfiguration specification. Contrast with ToJSONDataMap
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.ToJSONString(NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Serializes configuration tree rooted at this node into JSON configuration format and returns it as a string
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigSectionNode.AttrsToStringMap(System.Boolean)">
            <summary>
            Returns attribute values as string map
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigSectionNode.HasChildren">
            <summary>
            Indicates whether this node has any child section nodes
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigSectionNode.ChildCount">
            <summary>
            Returns number of child section nodes
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigSectionNode.HasAttributes">
            <summary>
            Indicates whether this node has any associated attributes
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigSectionNode.AttrCount">
            <summary>
            Returns number of child attribute nodes
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigSectionNode.Children">
            <summary>
            Enumerates all child nodes
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigSectionNode.Attributes">
            <summary>
            Enumerates all attribute nodes
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigSectionNode.Item(System.String[])">
            <summary>
            Retrieves section node by names, from left to right until existing node is found.
            If no existing node could be found then empty node instance is returned
            </summary>
        </member>
        <member name="P:NFX.Environment.IConfigSectionNode.Item(System.Int32)">
            <summary>
            Retrieves section node by index or empty node instance if section node with such index could not be found
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.#ctor(NFX.Environment.Configuration,NFX.Environment.ConfigSectionNode,NFX.Environment.IConfigSectionNode)">
            <summary>
            Performs deep clone copy from another node which can be in this or different configuration
            </summary>
        </member>
        <member name="F:NFX.Environment.ConfigSectionNode.m_Script_Statement">
            <summary>
            Internal field used for attaching temporary script state. do not use
            </summary>
        </member>
        <member name="F:NFX.Environment.ConfigSectionNode.m_Script_Bool_Condition_Result">
            <summary>
            Internal field used for attaching temporary script state. do not use
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.Delete">
            <summary>
            Deletes this section from its parent
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.DeleteAllChildren">
            <summary>
            Deletes all child section nodes from this node
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.DeleteAllAttributes">
            <summary>
            Deletes all attribute nodes from this node
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.AddChildNode(System.String,System.String)">
            <summary>
            Adds a new child section node to this node
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.AddChildNode(NFX.Environment.IConfigSectionNode)">
            <summary>
            Adds a new child node into this one deeply cloning nodes data from some other node which may belong to a different conf instance
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.AddChildNodeFromMerge(NFX.Environment.IConfigSectionNode,NFX.Environment.IConfigSectionNode,NFX.Environment.NodeOverrideRules)">
            <summary>
            Adds a new section node to this configuration which is an ordered merge result of two other nodes - base and override.
            </summary>
            <param name="baseNode">A base node that data is defaulted from</param>
            <param name="overrideNode">A node that contains overrides/additions of/to data from base node</param>
            <param name="rules">Rules to use for this merge. Default rules will be used if null is passed</param>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.OverrideBy(NFX.Environment.IConfigSectionNode,NFX.Environment.NodeOverrideRules)">
            <summary>
            Merges another node data by overriding this node's value/attributes/sub nodes according to rules.
            </summary>
            <returns>True when merge match was made</returns>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.MergeAttributes(NFX.Environment.IConfigSectionNode,NFX.Environment.NodeOverrideRules)">
            <summary>
            Merges attributes from another node into this one. Another node may belong to a different configuration instance
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.MergeSections(NFX.Environment.IConfigSectionNode,NFX.Environment.NodeOverrideRules)">
            <summary>
            Merges child sections from another node into this one. Another node may belong to a different configuration instance.
            This method ignores override flags and merges nodes regardless
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.ReplaceBy(NFX.Environment.IConfigSectionNode)">
            <summary>
            Completely replaces this node's attributes, value and children with data from another node
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.AttrByIndex(System.Int32)">
            <summary>
            Returns attribute node by its index or empty attribute if real attribute with such index does not exist
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.ResetModified">
            <summary>
            Resets modification of this an all child nodes
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.Navigate(System.String)">
            <summary>
            Navigates the path and return the appropriate node. Example: '!/nfx/logger/destination/$file-name'
            </summary>
            <param name="path">If path starts from '!' then exception will be thrown if such a node does not exist;
             Use '/' as leading char for root,
             '..' for step up,
             '$' for attribute name,
             [int] for access to subsection or attribute by index,
             section[value] for access using value comparison of named section,
             section[attr=value] for access using value of sections named attr
            Multiple paths may be coalesced  using '|' or ';'
            </param>
            <example>
                Navigate("/vars/[3]"); Navigate("/tables/table[resident]"); Navigate("/vars/var1/$[2]");  Navigate("/tables/table[name=patient]");
            </example>
            <remarks>
              /table[patient]    -   get first section named "table" with value "patient"
              /[3]               -   get 4th child section from the root
              /table/$[2]        -   get 3rd attribute of first section named "table"
              /table[short-name=pat] -  get first section named "table" having attribute named "short-name" equal "pat"
            </remarks>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.NavigateSection(System.String)">
            <summary>
            Navigates the path and return the appropriate section node. Example '!/nfx/logger/destination'
            </summary>
            <param name="path">If path starts from '!' then exception will be thrown if such a section node does not exist;
             Use '/' as leading char for root,
             '..' for step up. Multiple paths may be coalesced using '|' or ';'
            </param>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.EvaluateValueVariables(System.String)">
            <summary>
            Evaluates a value string expanding all variables with var-paths relative to this node.
            Evaluates configuration variables such as "$(varname)" or "$(@varname)". Varnames are paths
            to other config nodes from the same configuration or variable names when prefixed with "~". If varname starts with "@" then it gets combined
             with input as path string. "~" is used to qualify environment vars that get resolved through Configuration.EnvironmentVarResolver
             Example: `....add key="Schema.$(/A/B/C/$attr)" value="$(@~HOME)bin\Transforms\"...`
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.IsSameNameAttr(NFX.Environment.IConfigSectionNode)">
            <summary>
            Returns true when another node has the attribute called 'name' and its value is the same as in this one per case-insensitive culture-neutral comparison
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.IsSameNameAttr(System.String)">
            <summary>
            Returns true when another name is the same as this section "name" attribute per case-insensitive culture-neutral comparison
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.ToLaconicString(NFX.CodeAnalysis.Laconfig.LaconfigWritingOptions)">
            <summary>
            Serializes configuration tree rooted at this node into Laconic format and returns it as a string
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.ToJSONString(NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Serializes configuration tree rooted at this node into JSON configuration format and returns it as a string
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.ProcessIncludePragmas(System.Boolean,System.String)">
            <summary>
            Replaces all include pragmas - sections with specified names ('_include' by default), with pointed to configuration file content
            as obtained via the call to file system specified in every pragma.
            If no FS specified then LocalFileSystem is used. If no file name specified when try to allocate config node provider.
            Returns true if include pragmas were found.
            Note: this method does not process new include pragmas that may have fetched during this call.
            Caution: the file system used in the operation may rely on the App container that may need to be set-up for the call to succeed,
            therefore calling this method before app has activated may fail, in such cases a temp app container may be set to get the config file
             with processed includes, then the result may be passed to the primary app container ctor.
            This call is not logically thread-safe, it must be called from the main thread in the app
            </summary>
            <param name="recurse">True to process inner nodes</param>
            <param name="includePragma">Pragma section name, '_include' by default</param>
            <returns>True if pragmas were found</returns>
            <example>
             nfx
             {
               sectionA{ a=2 b=3}
               _include
               {
                 name=secret // '_include' will be replaced by 'secret' with sub-nodes from referenced file
                 file="/etc/cluster/mysecret.laconf" //would come from local FS
                 required=false //if file is not found then nothing will be included instead of '_include' which will be just removed
               }
               _include
               {
                 // '_include' will be replaced by whatever root section content in the referenced file
                 fs {type="NFX.Web.IO.FileSystem.SVNFileSystem, NFX.Web"}
                 session { server-url="https://myhost.com/mySvnRepo/trunk/configs" user-name="user1" user-password="******"}
               }
             }
            </example>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.AttrsToStringMap(System.Boolean)">
            <summary>
            Returns attribute values as string map
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.ToJSONDataMap">
            <summary>
            Converts this ConfigSectionNode to JSONDataMap. Contrast with ToConfigurationJSONDataMap
            Be carefull: that this operation can "lose" data from ConfigSectionNode.
            In other words some ConfigSectionNode information can not be reflected in corresponding JSONDataMap, for example
             this method overwrites duplicate key names and does not support section values
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigSectionNode.ToConfigurationJSONDataMap">
            <summary>
            Returns this config node as JSON data map suitable for making JSONConfiguration.
            Contrast with ToJSONDataMap
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigSectionNode.HasChildren">
            <summary>
            Indicates whether this node has any child section nodes
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigSectionNode.ChildCount">
            <summary>
            Returns number of child section nodes
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigSectionNode.HasAttributes">
            <summary>
            Indicates whether this node has any associated attributes
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigSectionNode.AttrCount">
            <summary>
            Returns number of child attribute nodes
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigSectionNode.Modified">
            <summary>
            Indicates whether this or any child nodes or attributes were modified
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigSectionNode.Children">
            <summary>
            Enumerates all child nodes
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigSectionNode.Attributes">
            <summary>
            Enumerates all attribute nodes
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigSectionNode.Item(System.String[])">
            <summary>
            Retrieves section node by names, from left to right until existing node is found.
            If no existing node could be found then empty node instance is returned
            </summary>
        </member>
        <member name="P:NFX.Environment.ConfigSectionNode.Item(System.Int32)">
            <summary>
            Retrieves section node by index or empty node instance if section node with such index could not be found
            </summary>
        </member>
        <member name="T:NFX.Environment.ConfigAttrNode">
            <summary>
            Represents an attribute of a attribute node
            </summary>
        </member>
        <member name="T:NFX.Environment.IConfigAttrNode">
            <summary>
            Represents a read-only attribute of a attribute node
            </summary>
        </member>
        <member name="M:NFX.Environment.ConfigAttrNode.Delete">
            <summary>
            Deletes this attribute from its parent
            </summary>
        </member>
        <member name="T:NFX.Environment.FactoryUtils">
            <summary>
            Provides helper methods for dynamic object creation and configuration
            </summary>
        </member>
        <member name="M:NFX.Environment.FactoryUtils.MakeAndConfigure(NFX.Environment.IConfigSectionNode,System.Type,System.Object[])">
            <summary>
            Creates and configures an instance of appropriate configurable object as specified in supplied config node.
            Applies configured behaviours
            </summary>
        </member>
        <member name="M:NFX.Environment.FactoryUtils.MakeAndConfigure``1(NFX.Environment.IConfigSectionNode,System.Type,System.Object[])">
            <summary>
            Creates and configures an instance of appropriate configurable object as specified in supplied config node.
            Applies configured behaviours
            </summary>
        </member>
        <member name="M:NFX.Environment.FactoryUtils.Make``1(NFX.Environment.IConfigSectionNode,System.Type,System.Object[])">
            <summary>
            Creates an instance of appropriate configurable object as specified in supplied config node.
            This function does not configure the instance
            </summary>
        </member>
        <member name="M:NFX.Environment.FactoryUtils.MakeUsingCtor``1(NFX.Environment.IConfigSectionNode,System.String)">
            <summary>
            Invokes a constructor for type feeding it the specified args:
             node{type="NS.Type, Assembly" arg0=1 arg1=true....}
            If the typePattern is passed, then the '*' in pattern is replaced with 'type' attr content.
            This is needed for security, as this method allows to inject any type with any ctor params when typePattern is null
            </summary>
        </member>
        <member name="T:NFX.Environment.IConfigNodeProvider">
            <summary>
            Represents an entity that provides config node. It is primarily used for includes
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigNodeProvider.ProvideConfigNode(System.Object)">
            <summary>
            Returns config node per optional context
            </summary>
        </member>
        <member name="T:NFX.Environment.IConfigSettings">
            <summary>
            Represents an entity that provides a type-safe access to configuration settings that come from Configuration nodes.
            This class obviates the need for navigation between config nodes on every property get and facilitates faster access to some config parameters
            that need to be gotten efficiently, as they are now kept cached in RAM in native format (i.e. DateTime vs. string) as fields.
            Usually classes that implement this interface are singleton and they get registered with the application using IApplication.RegisterConfigSettings()
            method. Warning: the implementation must be thread-safe and allow property getters to keep reading while ConfigChanged() notification happens
            </summary>
        </member>
        <member name="M:NFX.Environment.IConfigSettings.ConfigChanged(NFX.Environment.IConfigSectionNode)">
            <summary>
            Notifies the implementer that underlying source configuration has changed and memory-resident
            fields need to be re-read from config nodes. Usually this method is called by application container
             when instance of this class has been registered with the application using IApplication.RegisterConfigSettings().
            Warning: the implementation must be thread-safe and allow getters to keep reading while notification happens
            </summary>
            <param name="atNode">
            Passes the most top-level node that covers all of the changes that happened in the source config system.
            Usually this is a root config node. The capability of source config change detection on node level is not supported by all providers
            </param>
        </member>
        <member name="T:NFX.Environment.MemoryConfiguration">
            <summary>
            Implements configuration that can not be persisted/loaded anywhere - just stored in memory
            </summary>
        </member>
        <member name="T:NFX.Environment.XMLConfiguration">
            <summary>
            Provides implementation of configuration based on a classic XML content
            </summary>
        </member>
        <member name="M:NFX.Environment.XMLConfiguration.#ctor">
            <summary>
            Creates an instance of a new configuration not bound to any XML file
            </summary>
        </member>
        <member name="M:NFX.Environment.XMLConfiguration.#ctor(System.String)">
            <summary>
            Creates an isntance of the new configuration and reads contents from an XML file
            </summary>
        </member>
        <member name="M:NFX.Environment.XMLConfiguration.CreateFromXML(System.String,System.Boolean)">
            <summary>
            Creates an instance of configuration initialized from XML content passed as string
            </summary>
        </member>
        <member name="M:NFX.Environment.XMLConfiguration.SaveAs(System.String)">
            <summary>
            Saves configuration into a file
            </summary>
        </member>
        <member name="M:NFX.Environment.XMLConfiguration.SaveAs(System.String,System.String)">
            <summary>
            Saves configuration to a file with optional link to XSL file
            </summary>
        </member>
        <member name="M:NFX.Environment.XMLConfiguration.SaveToString(System.String)">
            <summary>
            Saves XML configuration with optional link to XSL file, into string and returns it
            </summary>
        </member>
        <member name="M:NFX.Environment.XMLConfiguration.SaveToXmlDoc(System.String,System.String)">
            <summary>
            Saves XML configuration into stream
            </summary>
        </member>
        <member name="T:NFX.Financial.TimeValue">
            <summary>
            Implements time value financial functions such as: PV, NPV, IRR
            </summary>
        </member>
        <member name="M:NFX.Financial.TimeValue.PV(System.Double,System.Double,System.Int32)">
            <summary>
            Returns present value of amount returned in X number of periods
            at a certain interest rate
            </summary>
            <param name="fv">Future value (returned amount in X periods)</param>
            <param name="intRate">Interest rate per period</param>
            <param name="periods">Period length</param>
            <returns>Present Value</returns>
            <example>
            Assume that A gives $100 cash to B. B returns the same amount to A in 1 year.
            Banks give 5% annual rate, therefore present value of this $100 dollar
            returned is going to be $95.24 - A lost $4.76, because B did not pay any interest and
             A could have deposited $100 in regular bank instead of giving it to B.
            Had A charged B 5% interest rate , A would have made money.
            </example>
        </member>
        <member name="M:NFX.Financial.TimeValue.FV(System.Double,System.Double,System.Int32)">
            <summary>
            Returns future value of presently-valued amount in X number of periods
            at a certain interest rate
            </summary>
            <param name="pv">Present value</param>
            <param name="intRate">Interest rate</param>
            <param name="periods">Period length</param>
            <returns>Future value</returns>
            <example>
            $100 loaned for 1 period at 5% interest per period have future value of $105;
            same amount loaned for 10 periods at the same rate would have future value of $162.89
            </example>
        </member>
        <member name="M:NFX.Financial.TimeValue.NPV(System.Collections.Generic.IEnumerable{System.Double},System.Double)">
            <summary>
            Returns a net present value calculated over series of cashflows
            </summary>
            <param name="cashFlows">A series of net cashflows per period(supplied as a summ of inflows and outflows), usually the first cashflow is an outflow of initial project investment</param>
            <param name="discountRate">Interest rate used for net cashflow discount</param>
            <returns>Net present value</returns>
        </member>
        <member name="M:NFX.Financial.TimeValue.IRR(System.Collections.Generic.IEnumerable{System.Double},System.Double)">
            <summary>
            Calculates the internal rate of return over series of cash flows
            </summary>
        </member>
        <member name="M:NFX.Financial.TimeValue.IRR(System.Double[],System.Double)">
            <summary>
            Calculates the internal rate of return over series of cash flows
            </summary>
        </member>
        <member name="T:NFX.Geometry.MapDirection">
            <summary>
            Map direction enumeration aka. North, South, East, etc...
            </summary>
        </member>
        <member name="F:NFX.Geometry.CartesianUtils.PI_DEGREES">
            <summary>
            Represents count of degrees in PI
            </summary>
        </member>
        <member name="F:NFX.Geometry.CartesianUtils.PI2">
            <summary>
            Pi*2 constant
            </summary>
        </member>
        <member name="F:NFX.Geometry.CartesianUtils.PI_HALF">
            <summary>
            Pi/2 constant
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.ToRad(System.Double)">
            <summary>
            Converts degrees into radians
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.ToDeg(System.Double)">
            <summary>
            Converts radians into degrees
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.Distance(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates distance between two points
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.Distance(System.Drawing.Point,System.Drawing.Point)">
            <summary>
            Calculates distance between two points
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.Distance(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Calculates distance between two points
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.Distance(System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Calculates distance between two points
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.AzimuthRad(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates azimuth for vector in rads
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.AzimuthDeg(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates azimuth for vector in degrees
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.AzimuthOfRadix(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates azimuth for vector in degrees
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.PointToPolarPoint(System.Drawing.Point,System.Drawing.Point)">
            <summary>
            Converts Point to polar coordinate point
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.VectorToPolarPoint(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Converts vector in 'x1, y1, x2, y2' representation to polar coordinate point
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.WrapAngle(System.Double,System.Double)">
            <summary>
            Modifies an angle by delta value ensuring that resulting angle is always between 0 and 2Pi
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.FindRayFromRectangleCenterSideIntersection(System.Drawing.Rectangle,System.Double)">
            <summary>
            Returns a point of intersection between a ray cast from the center of a rectangle
             under certain polar coordinate angle and a rectangle side
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.MapDirectionToAngle(NFX.Geometry.MapDirection)">
            <summary>
            Converts map direction to angular coordinate in radians
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.AngleToMapDirection(System.Double)">
            <summary>
            Converts a radian angular coordinate into map direction
            </summary>
        </member>
        <member name="M:NFX.Geometry.CartesianUtils.CalculatePerimeterViolationArea(System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            Calculates an area of an inner rectangle that violates outside perimeter
            </summary>
        </member>
        <member name="T:NFX.Geometry.PolarPoint">
            <summary>
            Represents a point with polar coordinates
            </summary>
        </member>
        <member name="M:NFX.Geometry.PolarPoint.#ctor(System.Double,System.Double)">
            <summary>
            Initializes polar coordinates
            </summary>
        </member>
        <member name="M:NFX.Geometry.PolarPoint.#ctor(System.Drawing.Point,System.Drawing.Point)">
            <summary>
            Initializes polar coordinates from 2-d cartesian coordinates
            </summary>
        </member>
        <member name="M:NFX.Geometry.PolarPoint.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes polar coordinates from 2-d cartesian coordinates of 'x1, y1, x2, y2' format
            </summary>
        </member>
        <member name="P:NFX.Geometry.PolarPoint.R">
            <summary>
            R coordinate component which is coordinate distance from point of coordinates origin
            </summary>
        </member>
        <member name="P:NFX.Geometry.PolarPoint.Theta">
            <summary>
            Angular azimuth coordinate component. An angle must be between 0 and 2Pi.
            Note: Due to screen Y coordinate going from top to bottom (in usual orientation)
             Theta angle may be reversed, that is - be positive in the lower half coordinate plane.
            Please refer to:
             http://en.wikipedia.org/wiki/Polar_coordinates
            </summary>
        </member>
        <member name="P:NFX.Geometry.PolarPoint.Point">
            <summary>
            Returns polar coordinate converted to 2-d cartesian coordinates.
            Coordinates are relative to 0,0 of the angle base vertex
            </summary>
        </member>
        <member name="T:NFX.Geometry.VectorUtils">
            <summary>
            Provides helper methods dealing with vector graphics
            </summary>
        </member>
        <member name="M:NFX.Geometry.VectorUtils.VectorizeBalloon(System.Drawing.Rectangle,System.Drawing.Point,System.Double)">
            <summary>
            Calculates callout balloon vertexes suitable for curve drawing
            </summary>
            <param name="body">Balloon body coordinates</param>
            <param name="target">A point of balloon leg attachment</param>
            <param name="legSweep">Length of balloon leg attachment breach at balloon body edge, expressed in radians (arc length). A value such as PI/16 yields good results</param>
            <returns>An array of vertex points</returns>
        </member>
        <member name="M:NFX.Geometry.VectorUtils.InflateBalloon(System.Drawing.Rectangle@,System.Drawing.Point@,System.Int32,System.Int32)">
            <summary>
            Inflates balloon body and target point
            </summary>
        </member>
        <member name="M:NFX.Geometry.VectorUtils.InflateBalloon(System.Drawing.Rectangle@,System.Drawing.Point@,System.Int32)">
            <summary>
            Inflates balloon body and target point
            </summary>
        </member>
        <member name="T:NFX.IO.ErrorHandling.CRC32">
            <summary>
            Implements CRC32 checksum algorithm
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.CRC32.ForEncodedString(System.String,System.Text.Encoding)">
            <summary>
            Computes CRC32 for string
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.CRC32.ForString(System.String)">
            <summary>
            Computes CRC32 for binary string representation (in-memory)
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.CRC32.ForBytes(System.Byte[])">
            <summary>
            Computes CRC32 for byte array
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.CRC32.Add(System.Int32)">
            <summary>
            Adds integer value into checksum
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.CRC32.Add(System.Byte[])">
            <summary>
            Adds byte array into checksum
            </summary>
        </member>
        <member name="M:NFX.IO.ErrorHandling.CRC32.Add(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Adds byte array into checksum
            </summary>
        </member>
        <member name="P:NFX.IO.ErrorHandling.CRC32.Value">
            <summary>
            Returns present checksum for the pushed data
            </summary>
        </member>
        <member name="T:NFX.IO.ConsoleUtils">
            <summary>
            Provides various console-helper utilities
            </summary>
        </member>
        <member name="M:NFX.IO.ConsoleUtils.ReadPassword(System.Char)">
            <summary>
            Reads password from console displaying substitute characters instead of real ones
            </summary>
        </member>
        <member name="M:NFX.IO.ConsoleUtils.ReadPasswordToSecureBuffer(System.Char)">
            <summary>
            Reads password from console displaying substitute characters instead of real ones
            into a sealed SecureBuffer
            </summary>
        </member>
        <member name="M:NFX.IO.ConsoleUtils.WriteMarkupContent(System.String)">
            <summary>
            Outputs colored text from content supplied in an HTML-like grammar:
            </summary>
        </member>
        <member name="M:NFX.IO.ConsoleUtils.WriteMarkupContent(System.String,System.Char,System.Char)">
            <summary>
            Outputs colored text from content supplied in an HTML-like grammar
            </summary>
        </member>
        <member name="M:NFX.IO.ConsoleUtils.Error(System.String,System.Int32)">
            <summary>
            Shows message with colored error header
            </summary>
        </member>
        <member name="M:NFX.IO.ConsoleUtils.Warning(System.String,System.Int32)">
            <summary>
            Shows message with colored warning header
            </summary>
        </member>
        <member name="M:NFX.IO.ConsoleUtils.Info(System.String,System.Int32)">
            <summary>
            Shows message with colored info header
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.CSVFileDestination">
            <summary>
            Provides a CSV file storage log destination implementation
            </summary>
        </member>
        <member name="M:NFX.Log.Destinations.CSVFileDestination.DoFormatMessage(NFX.Log.Message)">
            <summary>
            Spools instance data in CSV format for storage in a file destination
            </summary>
        </member>
        <member name="P:NFX.Log.Destinations.CSVFileDestination.LogTimeFormat">
            <summary>
            Sets time formatting for CSV log line
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.MessageFilterHandler">
            <summary>
            Delegate for message filtering
            </summary>
        </member>
        <member name="T:NFX.Log.Destinations.NullDestination">
            <summary>
            Log destination that does not log anything anywhere
            </summary>
        </member>
        <member name="T:NFX.Log.MessageType">
            <summary>
            Stipulates general logging message types like: Info/Warning/Error etc...
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.Debug">
            <summary>
            Used in debugging temp code
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.DebugSQL">
            <summary>
            Emitted by DataStore implementations
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.DebugGlue">
            <summary>
            Emitted by Glue/Net code
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.DebugZ">
            <summary>
            Last debug-related message type for use in debug-related max-level config setting
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.Trace">
            <summary>
            Tracing, no danger to system operation
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.TraceSQL">
            <summary>
            Emitted by DataStore implementations
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.TraceGlue">
            <summary>
            Emitted by Glue/Net code
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.TraceErl">
            <summary>
            Emitted by Erlang code
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.TraceZ">
            <summary>
            Last trace-related message type for use in trace-related max-level config setting
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.PerformanceInstrumentation">
            <summary>
            Performance/Instrumentation-related message
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.Info">
            <summary>
            Informational message, no danger to system operation
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.InfoZ">
            <summary>
            Last info-related message type for use in info-related max-level config setting
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.Aggregate">
            <summary>
            The message instance represents many others - probably aggregated with time multiple records into one
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.SecurityAudit">
            <summary>
            Permission audit, usualy a result of client user action, no danger to system operation
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.Notice">
            <summary>
            SYSLOG.Notice Events that are unusual but not error conditions - might be summarized in an email to developers or admins to spot potential problems - no immediate action required.
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.Warning">
            <summary>
            Caution - inspect and take action.
            SYSLOG.Warning, not an error, but indication that an error will occur if action is not taken, e.g. file system 85% full - each item must be resolved within a given time.
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.Error">
            <summary>
            Recoverable error, system will most-likely continue working normally.
            SYSLOG.Error Non-urgent failures, these should be relayed to developers or admins; each item must be resolved within a given time.
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.Critical">
            <summary>
            SYSLOG.Critical Should be corrected immediately, but indicates failure in a primary system, an example is a loss of a backup ISP connection.
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.CriticalAlert">
            <summary>
            SYSLOG.Alert Should be corrected immediately, therefore notify staff who can fix the problem. An example would be the loss of a primary ISP connection.
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.Emergency">
            <summary>
            Unrecoverable error, system  will most-likely experience major operation disruption.
            SYSLOG.Emergency - A "panic" condition usually affecting multiple apps/servers/sites. At this level it would usually notify all tech staff on call.
            </summary>
        </member>
        <member name="F:NFX.Log.MessageType.CatastrophicError">
            <summary>
            Unrecoverable error, system  will experience major operation disruption.
            SYSLOG.Emergency - A "panic" condition usually affecting multiple apps/servers/sites. At this level it would usually notify all tech staff on call.
            </summary>
        </member>
        <member name="T:NFX.Log.LogService">
            <summary>
            Provides logging services by buffering messages and dispatching them into destinations.
            This is an asynchronous service, meaning that Write(msg) never blocks for long.
            </summary>
        </member>
        <member name="M:NFX.Log.LogService.#ctor">
            <summary>
            Creates a new logging service instance
            </summary>
        </member>
        <member name="M:NFX.Log.LogService.#ctor(NFX.ServiceModel.Service)">
            <summary>
            Creates a new logging service instance
            </summary>
        </member>
        <member name="M:NFX.Log.LogService.DoWrite(NFX.Log.Message,System.Boolean)">
            <summary>
            Writes log message into log
            </summary>
        </member>
        <member name="P:NFX.Log.LogService.WriteInterval">
            <summary>
            Determines how often a log should be written to storage.
            The value of this property must be between 10 and 5000 (milliseconds)
            </summary>
        </member>
        <member name="P:NFX.Log.LogService.FileExtension">
            <summary>
            Extension for log files
            </summary>
        </member>
        <member name="P:NFX.Log.LogService.Reliable">
            <summary>
            Determines whether this service blocks on stop longer until all buffered messages have been tried to be dispatched into all destinations.
            This property is true by default.
            Certain destinations may take considerable time to fail per message (i.e. database connection timeout), consequently buffered messages
             processing may delay service stop significantly if this property is true
            </summary>
        </member>
        <member name="T:NFX.Log.Message">
            <summary>
            Represents a Log message
            </summary>
        </member>
        <member name="M:NFX.Log.Message.#ctor(System.Object,System.String,System.Int32)">
            <summary>
            Creates message with Parameters supplanted with caller file name and line #
            </summary>
        </member>
        <member name="M:NFX.Log.Message.FormatCallerParams(System.Object,System.String,System.Int32)">
            <summary>
            Supplants the from string with caller as JSON string
            </summary>
        </member>
        <member name="P:NFX.Log.Message.Guid">
            <summary>
            Returns global unique identifier for this particular message
            </summary>
        </member>
        <member name="P:NFX.Log.Message.RelatedTo">
            <summary>
            Gets/Sets global unique identifier of a message that this message is related to.
            No referential integrity check is performed
            </summary>
        </member>
        <member name="P:NFX.Log.Message.Type">
            <summary>
            Gets/Sets message type, such as: Info/Warning/Error etc...
            </summary>
        </member>
        <member name="P:NFX.Log.Message.Source">
            <summary>
            Gets/Sets message source line number/tracepoint#, this is used in conjunction with From
            </summary>
        </member>
        <member name="P:NFX.Log.Message.TimeStamp">
            <summary>
            Gets/Sets timestamp when message was generated
            </summary>
        </member>
        <member name="P:NFX.Log.Message.Host">
            <summary>
            Gets/Sets host name that generated the message
            </summary>
        </member>
        <member name="P:NFX.Log.Message.From">
            <summary>
            Gets/Sets logical component ID, such as: class name, method name, process instance, that generated the message.
            This field is used in the scope of Topic
            </summary>
        </member>
        <member name="P:NFX.Log.Message.Topic">
            <summary>
            Gets/Sets a message topic/relation - the name of software concern within the big app, i.e. "Database" or "Security"
            </summary>
        </member>
        <member name="P:NFX.Log.Message.Text">
            <summary>
            Gets/Sets an unstructured message text, the emitting component name must be in From field, not in text.
            Note about logging errors. Use caught exception.ToMessageWithType() method, then attach the caught exception as Exception property
            </summary>
        </member>
        <member name="P:NFX.Log.Message.Parameters">
            <summary>
            Gets/Sets a structured parameter bag, this may be used for additional debug info like source file name, additional context etc.
            </summary>
        </member>
        <member name="P:NFX.Log.Message.Exception">
            <summary>
            Gets/Sets exception associated with message.
            Set this property EVEN IF the name/text of exception is already included in Text as log destinations may elect to dump the whole stack trace
            </summary>
        </member>
        <member name="P:NFX.Log.Message.ArchiveDimensions">
            <summary>
            Gets/Sets archive dimension content for later retrieval of messages by key, i.e. a user ID may be used.
            In most cases JSON or Laconic content is stored, the format depends on a concrete system
            </summary>
        </member>
        <member name="P:NFX.Log.Message.Channel">
            <summary>
            Gets/Sets logical partition for messages. This property is usually used in Archive for splitting destinations
            </summary>
        </member>
        <member name="T:NFX.Log.NOPLog">
            <summary>
            Represents log that does not do anything
            </summary>
        </member>
        <member name="P:NFX.Log.NOPLog.Instance">
            <summary>
            Returns a singlelton instance of the log that does not do anything
            </summary>
        </member>
        <member name="T:NFX.MiscUtils">
            <summary>
            Provides a collection of frequently-used extension methods
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.IsTrue(System.Nullable{System.Boolean},System.Boolean)">
            <summary>
            Tests bool? for being assigned with true
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.NonNull``1(``0,System.Func{System.Exception},System.String)">
            <summary>
            Checks the value for null and throws exception if it is.
            The method is useful for .ctor call chaining to preclude otherwise anonymous NullReferenceException
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.TakeFirstChars(System.String,System.Int32,System.String)">
            <summary>
            Takes first X chars from a string. If string is null returns null. If string does not have enough
            the function returns what the string has
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.StripSimpleHtml(System.String)">
            <summary>
            Strip simple html from string
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToUTF8Bytes(System.String)">
            <summary>
            Encodes string with standart UTF8 encoder
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.FromUTF8Bytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decode string with standart UTF8 decoder
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToSecondsSinceUnixEpochStart(System.DateTime)">
            <summary>
            Gets number of seconds since Unix epoch start (1970/1/1 0:0:0)
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.FromSecondsSinceUnixEpochStart(System.Int64)">
            <summary>
            Gets UTC DateTime from number of seconds since Unix epoch start (1970/1/1 0:0:0)
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.FromSecondsSinceUnixEpochStart(System.UInt64)">
            <summary>
            Gets UTC DateTime from number of seconds since Unix epoch start (1970/1/1 0:0:0)
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.FromMillisecondsSinceUnixEpochStart(System.Int64)">
            <summary>
            Gets UTC DateTime from number of milliseconds since Unix epoch start (1970/1/1 0:0:0)
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.FromMicrosecondsSinceUnixEpochStart(System.Int64)">
            <summary>
            Gets UTC DateTime from number of microseconds since Unix epoch start (1970/1/1 0:0:0)
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.FromMicrosecondsSinceUnixEpochStart(System.UInt64)">
            <summary>
            Gets UTC DateTime from number of microseconds since Unix epoch start (1970/1/1 0:0:0)
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.FromMillisecondsSinceUnixEpochStart(System.UInt64)">
            <summary>
            Gets UTC DateTime from number of milliseconds since Unix epoch start (1970/1/1 0:0:0)
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToMillisecondsSinceUnixEpochStart(System.DateTime)">
            <summary>
            Gets number of milliseconds since Unix epoch start (1970/1/1 0:0:0)
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToMicrosecondsSinceUnixEpochStart(System.DateTime)">
            <summary>
            Gets number of microseconds since Unix epoch start (1970/1/1 0:0:0)
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.RoundToWeekDay(System.DateTime,System.DayOfWeek,System.Boolean)">
            <summary>
            Round date to specific week day
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.RoundToNextWeekDay(System.DateTime,System.DayOfWeek,System.Boolean)">
            <summary>
            Round date to next specific week day
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.Truncate(System.DateTime,System.Int64)">
            <summary>
            Tuncate date to specific resolution
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToMessageWithType(System.Exception)">
            <summary>
            Writes exception message with exception type
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToJSONDataMap(System.Exception,System.Boolean,System.Boolean)">
            <summary>
            If there is error, converts its details to JSOnDataMap
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.FullNestedTypeName(System.Type,System.Boolean)">
            <summary>
            Returns full name of the nested type, for example: System.Namespace.Type+Sub -> Type.Sub
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.FullNameWithExpandedGenericArgs(System.Type,System.Boolean)">
            <summary>
            Returns the full name of the type optionally prefixed with verbatim id specifier '@'.
            The generic arguments ar expanded into their full names i.e.
              List'1[System.Object]  ->  System.Collections.Generic.List&lt;System.Object&gt;
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.DisplayNameWithExpandedGenericArgs(System.Type)">
            <summary>
            Returns the the name of the type with expanded generic argument names.
            This helper is useful for printing class names to logs/messages.
              List'1[System.Object]  ->  List&lt;Object&gt;
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.CapitalizeFirstChar(System.String)">
            <summary>
            Capitalizes first character of string
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.SplitLines(System.String)">
            <summary>
            Splits string into lines using Win or .nix line brakes
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToDescription(System.Reflection.MemberInfo)">
            <summary>
            Returns MemberInfo described as short string
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.IsComponentDesignerHosted(System.ComponentModel.Component)">
            <summary>
            Determines if component is being used within designer
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.EntryExeName(System.Boolean)">
            <summary>
            Returns the name of entry point executable file optionaly with its path
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.Args(System.String,System.Object[])">
            <summary>
            Shortcut helper for string.Format(tpl, params object[] args)
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ArgsTpl(System.String,System.Object)">
            <summary>
            Interprets template of the form:  Some text {@value_name@:C} by replacing with property/field values.
            Note: this function does not recognize escapes for simplicity (as escapes can be replaced by regular strings instead)
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ArgsTpl(System.String,System.Object,System.Boolean@)">
            <summary>
            Interprets template of the form:  Some text {@value_name@:C} by replacing with property/field values.
            Note: this function does not recognize escapes for simplicity (as escapes can be replaced by regular strings instead).
            Matched is set to true if at least one property match was made
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.IPStringToIPEndPoint(System.String)">
            <summary>
            Converts string of format "xx.xx.xx.xx:nnnn" into IPEndPoint.
            DNS names are NOT supported
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToIPEndPoint(System.String,System.Int32)">
            <summary>
            Resolve IP address by Name
            </summary>
            <param name="epoint">An ip address or DNS host name with optional port separated by ':'</param>
            <param name="dfltPort">Port number to use if not supplied in endpoint string</param>
            <returns>IPEndPoint instance or null supplied string could not be parsed</returns>
        </member>
        <member name="M:NFX.MiscUtils.RunAndCompleteProcess(System.String,System.String)">
            <summary>
            Runs specified process and waits for termination returning standard process output.
            This is a blocking call
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.AllFileNamesThatMatch(System.String,System.String,System.Boolean)">
            <summary>
            Walks all file names that match the pattern in a directory
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.AllFileNames(System.String,System.Boolean)">
            <summary>
            Walks all file names in a directory
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToGUID(System.String)">
            <summary>
            Generates GUID based on a string MD5 hash
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToMD5String(System.String)">
            <summary>
            Returns a MD5 hash of a UTF8 string represented as hex string
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToMD5String(System.Byte[])">
            <summary>
            Returns a MD5 hash of a UTF8 string represented as hex string
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToMD5(System.String)">
            <summary>
            Returns a MD5 hash of a UTF8 string represented as byte[]
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToMD5(System.Byte[])">
            <summary>
            Returns a MD5 hash of a byte array
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.IsValidXMLName(System.String)">
            <summary>
            Returns true when supplied name can be used for XML node naming (node names, attribute names)
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.GetHashCodeSenseCase(System.String)">
            <summary>
            Helper function that performs GetHashcode for string using invariant comparison.
            Use this in conjunction with EqualsSenseCase
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.EqualsSenseCase(System.String,System.String)">
            <summary>
            Helper function that performs comparison between strings using invariant comparison.
            Either lhs and rhs can be null.
            Use this in conjunction with GetHashCodeSenseCase
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.GetHashCodeIgnoreCase(System.String)">
            <summary>
            Helper function that performs case-insensitive GetHashcode for string using invariant comparison.
            Use this in conjunction with EqualsIgnoreCase
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.EqualsIgnoreCase(System.String,System.String)">
            <summary>
            Helper function that performs case-insensitive comparison between strings using invariant comparison.
            Either lhs and rhs can be null.
            Use this in conjunction with GetHashCodeIgnoreCase
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.GetHashCodeOrdSenseCase(System.String)">
            <summary>
            Helper function that performs case-insensitive GetHashcode for string using ordinal comparison.
            Use this in conjunction with EqualsOrdSenseCase
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.EqualsOrdSenseCase(System.String,System.String)">
            <summary>
            Helper function that performs case-insensitive comparison between strings using ordinal comparison.
            Either lhs and rhs can be null.
            Use this in conjunction with GetHashCodeOrdSenseCase
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.GetHashCodeOrdIgnoreCase(System.String)">
            <summary>
            Helper function that performs case-insensitive GetHashcode for string using ordinal comparison.
            Use this in conjunction with EqualsOrdIgnoreCase
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.EqualsOrdIgnoreCase(System.String,System.String)">
            <summary>
            Helper function that performs case-insensitive comparison between strings using ordinal comparison.
            Either lhs and rhs can be null.
            Use this in conjunction with GetHashCodeOrdIgnoreCase
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.IsNullOrEmpty(System.String)">
            <summary>
            Helper function that calls string.IsNullOrEmpty()
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.IsNotNullOrEmpty(System.String)">
            <summary>
            Helper function that calls !string.IsNullOrEmpty()
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.IsNullOrWhiteSpace(System.String)">
            <summary>
            Helper function that calls string.IsNullOrWhiteSpace()
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.IsNotNullOrWhiteSpace(System.String)">
            <summary>
            Helper function that calls !string.IsNullOrWhiteSpace()
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.Default(System.String,System.String)">
            <summary>
            Defaults string if it is null or whitespace
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToDumpString(System.Byte[],NFX.DumpFormat,System.Int32,System.Int32,System.Boolean,System.Text.Encoding,System.Int32)">
            <summary>
            Convert a buffer to a printable string
            </summary>
            <param name="buf">Buffer to convert</param>
            <param name="fmt">Dumping format</param>
            <param name="offset">Starting index</param>
            <param name="count">Number of bytes to process (-1 means all bytes in the buffer)</param>
            <param name="eol">If true, terminate with end-of-line</param>
            <param name="encoding">Encoding to use for writing data in Binary format</param>
            <param name="maxLen">Max length of the returned string. Pass 0 for unlimited length</param>
            <returns></returns>
        </member>
        <member name="M:NFX.MiscUtils.ToConfigSections(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Converts dictionary into configuration where every original node gets represented as a sub-section of config's root
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToConfigAttributes(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Converts dictionary into configuration where every original node gets represented as an attribute of config's root
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.EvaluateVarsInXMLConfigScope(System.String,System.String,NFX.Environment.IEnvironmentVariableResolver,NFX.Environment.IMacroRunner)">
            <summary>
             Evaluates variables in a context of optional configuration supplied in XML format
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.EvaluateVarsInDictionaryScope(System.String,System.Collections.Generic.IDictionary{System.String,System.Object},NFX.Environment.IEnvironmentVariableResolver,NFX.Environment.IMacroRunner)">
            <summary>
             Evaluates variables in a context of optional configuration supplied as dictionary which is converted to attributes
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.EvaluateVars(System.String,NFX.Environment.IEnvironmentVariableResolver,NFX.Environment.IMacroRunner)">
            <summary>
             Evaluates variables in a context of optional variable resolver and macro runner
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.EvaluateVarsInConfigScope(System.String,NFX.Environment.Configuration)">
            <summary>
             Evaluates variables in a context of optional configuration supplied as config object
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.Burmatographize(System.String,System.Boolean)">
            <summary>
            Swaps string letters that "obfuscates" string- usefull for generation of keys from strings that have to become non-obvious to user.
            This function does not offer any real protection (as it is easy to decipher the original value), just visual.
            The name comes from non-existing science "Burmatography" used in "Neznaika" kids books
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ToDebugView(System.Linq.Expressions.Expression,System.Int32)">
            <summary>
            Converts expression tree to simple textual form for debugging
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.AppendFormatLine(System.Text.StringBuilder,System.String,System.Object)">
            <summary>
            Appends the string followed by new line and returned by processing a composite format string, which contains zero or more format items, to this instance.
            Each format item is replaced by the string representation of a single argument.
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.AppendFormatLine(System.Text.StringBuilder,System.String,System.Object,System.Object)">
            <summary>
            Appends the string followed by new line and returned by processing a composite format string, which contains zero or more format items, to this instance.
            Each format item is replaced by the string representation of a single argument.
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.AppendFormatLine(System.Text.StringBuilder,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Appends the string followed by new line and returned by processing a composite format string, which contains zero or more format items, to this instance.
            Each format item is replaced by the string representation of a single argument.
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.AppendFormatLine(System.Text.StringBuilder,System.String,System.Object[])">
            <summary>
            Appends the string followed by new line and returned by processing a composite format string, which contains zero or more format items, to this instance.
            Each format item is replaced by the string representation of a single argument.
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.EscapeJSLiteral(System.String)">
            <summary>
            Escapes JS literal, replacing / \ \r \n " ' &lt; &gt; &amp; chars with their hex codes
            </summary>
        </member>
        <member name="M:NFX.MiscUtils.ApproximateTimeDistance(System.DateTime,System.DateTime)">
            <summary>
            Retruns an approximate time distance (timespan) between two dates
            </summary>
        </member>
        <member name="T:NFX.URIUtils">
            <summary>
            URI handling helpers
            </summary>
        </member>
        <member name="M:NFX.URIUtils.JoinPathSegs(System.String[])">
            <summary>
            Joins URI path segments with "/". This function just concats strings, it does not evaluate relative paths etc.
            The first segment may or may not start with '/'
            </summary>
        </member>
        <member name="M:NFX.URIUtils.EscapeURIStringWithPlus(System.String)">
            <summary>
            Performs escaping plus sign in URL into its hex value
            </summary>
        </member>
        <member name="M:NFX.URIUtils.EscapeURIDataStringWithQuotes(System.String)">
            <summary>
            Performs URI.EscapeDataString with additional replacement of " and ' chars with their hex equivalents.
            This method is suitable for escaping client-side intelligent keys that may have single/double quotes
            </summary>
        </member>
        <member name="M:NFX.URIUtils.EscapeAllDataStringChars(System.String)">
            <summary>
            Escapes all chars except latin A..Z, 0..9, and . - _
            This function is based on EscapeDataString but does not depend on .NET 4/4.5 differences encoding ! * ( ) and others...
            </summary>
        </member>
        <member name="T:NFX.DebugAssertionException">
            <summary>
            Thrown by Debug class to indicate assertion failures
            </summary>
        </member>
        <member name="T:NFX.AvermentException">
            <summary>
            Thrown by Aver class to indicate averment failures
            </summary>
        </member>
        <member name="T:NFX.WrappedExceptionData">
            <summary>
            Marshalls exception details
            </summary>
        </member>
        <member name="M:NFX.WrappedExceptionData.#ctor(System.Exception,System.Boolean)">
            <summary>
            Initializes instance form local exception
            </summary>
        </member>
        <member name="P:NFX.WrappedExceptionData.TypeName">
            <summary>
            Returns the name of remote exception type
            </summary>
        </member>
        <member name="P:NFX.WrappedExceptionData.Message">
            <summary>
            Returns the message of remote exception
            </summary>
        </member>
        <member name="P:NFX.WrappedExceptionData.Code">
            <summary>
            Returns the code of remote NFX exception
            </summary>
        </member>
        <member name="P:NFX.WrappedExceptionData.Source">
            <summary>
            Name of the object that caused the error
            </summary>
        </member>
        <member name="P:NFX.WrappedExceptionData.StackTrace">
            <summary>
            Returns stack trace
            </summary>
        </member>
        <member name="P:NFX.WrappedExceptionData.ApplicationName">
            <summary>
            Returns the name of remote application
            </summary>
        </member>
        <member name="P:NFX.WrappedExceptionData.WrappedData">
            <summary>
            Returns wrapped date from IWrappedDataSource
            </summary>
        </member>
        <member name="P:NFX.WrappedExceptionData.InnerException">
            <summary>
            Returns the inner remote exception if any
            </summary>
        </member>
        <member name="T:NFX.WrappedException">
            <summary>
            Represents exception that contains data about causing exception with all of it's chain
            </summary>
        </member>
        <member name="M:NFX.WrappedException.ForException(System.Exception,System.Boolean)">
            <summary>
            Returns an exception wrapped into WrappedException. If the exception is already wrapped, it is returned as-is
            </summary>
        </member>
        <member name="P:NFX.WrappedException.Wrapped">
            <summary>
            Returns wrapped exception data
            </summary>
        </member>
        <member name="T:NFX.OS.ProcessRunner">
            <summary>
            Provides simple process invocation and output capture functionality
            </summary>
        </member>
        <member name="M:NFX.OS.ProcessRunner.Run(System.String,System.String,System.Int32@,System.Boolean@,System.Int32)">
            <summary>
            Invokes a process specified by cmd parameters blocking until process finishes and returns stdout.
            Pass optional timeout parameter that will abort the process execution when exceeded, or zero for unlimited time.
            </summary>
        </member>
        <member name="M:NFX.OS.ProcessRunner.Run(System.String,System.String,System.Boolean@,System.Int32)">
            <summary>
            Invokes a process specified by cmd parameters blocking until process finishes and returns stdout.
            Pass optional timeout parameter that will abort the process execution when exceeded, or zero for unlimited time.
            </summary>
        </member>
        <member name="M:NFX.OS.ProcessRunner.Run(System.String,System.Int32)">
            <summary>
            Invokes a process specified by cmd parameters blocking until process finishes and returns stdout
            Pass optional timeout parameter that will abort the process execution when exceeded, or zero for unlimited time.
            </summary>
        </member>
        <member name="M:NFX.OS.ProcessRunner.Run(System.Int32)">
            <summary>
            Runs process blocking until it finishes, or timeout is exceeded. Pass zero for time-unconstrained execution
            </summary>
        </member>
        <member name="P:NFX.OS.ProcessRunner.ProcessCmd">
            <summary>
            Gets/sets process to run
            </summary>
        </member>
        <member name="P:NFX.OS.ProcessRunner.Arguments">
            <summary>
            Gets/sets process invocation arguments
            </summary>
        </member>
        <member name="P:NFX.OS.ProcessRunner.BufferedOutput">
            <summary>
            Returns buffered process output
            </summary>
        </member>
        <member name="P:NFX.OS.ProcessRunner.ExitCode">
            <summary>
            Returns process last exit code
            </summary>
        </member>
        <member name="P:NFX.OS.ProcessRunner.TimedOutAndKilled">
            <summary>
            Returns process last exit code
            </summary>
        </member>
        <member name="P:NFX.OS.ProcessRunner.ExecutionTimeMs">
            <summary>
            Returns process execution time in milliseconds
            </summary>
        </member>
        <member name="T:NFX.Parsing.DataEntryUtils">
            <summary>
            Provides misc data-entry parsing routines
            </summary>
        </member>
        <member name="M:NFX.Parsing.DataEntryUtils.CheckEMail(System.String)">
            <summary>
            Returns true if the value is a valid non-null/empty email address
            </summary>
        </member>
        <member name="M:NFX.Parsing.DataEntryUtils.CheckTelephone(System.String)">
            <summary>
            Returns true if the value is a valid non-null/empty telephone
            </summary>
        </member>
        <member name="M:NFX.Parsing.DataEntryUtils.CheckScreenName(System.String)">
            <summary>
            Returns true if the value starts from primary language char and contains only those chars separated by one of ['.','-','_'].
            Subsequent separators not to occur more than once and can not be at the very end. This function supports Latin/Cyrrilic char sets
            </summary>
        </member>
        <member name="M:NFX.Parsing.DataEntryUtils.SQLSafeSubstitute(System.String,System.Char)">
            <summary>
            Allows only safe characters and digits replacing characters that may be used in SQL injection.
            This method may be used to generate column names from entity IDs
            </summary>
        </member>
        <member name="M:NFX.Parsing.DataEntryUtils.NormalizeUSPhone(System.String)">
            <summary>
            Normalizes US phone string so it looks like (999) 999-9999x9999.
            </summary>
        </member>
        <member name="T:NFX.Parsing.IdentifierLookup">
            <summary>
            Evaluator class performs math and logical expression parsing and evaluation without allocating .NET compilers
            </summary>
        </member>
        <member name="M:NFX.Parsing.Evaluator.Evaluate(NFX.Parsing.IdentifierLookup)">
            <summary>
            Evaluate expression and return result - either string or numerical value
            </summary>
        </member>
        <member name="M:NFX.Parsing.Evaluator.PrintTree">
            <summary>
            Returns b-tree traversal in a string form
            </summary>
        </member>
        <member name="P:NFX.Parsing.Evaluator.Expression">
            <summary>
            Expression beeing evaluated
            </summary>
        </member>
        <member name="P:NFX.Parsing.Evaluator.NoStringsExpression">
            <summary>
            Expression with all strings replaced with tokens
            </summary>
        </member>
        <member name="P:NFX.Parsing.Evaluator.Root">
            <summary>
            Root node of expression evaluation tree
            </summary>
        </member>
        <member name="E:NFX.Parsing.Evaluator.OnIdentifierLookup">
            <summary>
            Event which is fired upon leaf token resolution during evaluation, used to resolve host variables
            </summary>
        </member>
        <member name="T:NFX.Parsing.Evaluator.Node">
            <summary>
            Node class represents evaluation b-tree element
            </summary>
        </member>
        <member name="P:NFX.Parsing.Evaluator.Node.Expression">
            <summary>
            This node sub-expression
            </summary>
        </member>
        <member name="P:NFX.Parsing.Evaluator.Node.Condition">
            <summary>
            Boolean condition expression (subnode) used for conditional (ternary) operator
            </summary>
        </member>
        <member name="P:NFX.Parsing.Evaluator.Node.Left">
            <summary>
            Left b-tree branch, may be blank (in case of unary operators)
            </summary>
        </member>
        <member name="P:NFX.Parsing.Evaluator.Node.Right">
            <summary>
            Right b-tree branch, used for unary operators
            </summary>
        </member>
        <member name="P:NFX.Parsing.Evaluator.Node.Operator">
            <summary>
            Head operator performed on left and right b-tree branches
            </summary>
        </member>
        <member name="P:NFX.Parsing.Evaluator.Node.Level">
            <summary>
            Node depth level within expression b-tree
            </summary>
        </member>
        <member name="T:NFX.Parsing.JavaScript.Stripper">
            <summary>
            Strips JavaScript content off comments and whitespaces
            </summary>
        </member>
        <member name="T:NFX.Parsing.TokenParser">
            <summary>
            TokenParser class translates tokenized content string to an array list of parsed tokens with attributes
            </summary>
        </member>
        <member name="P:NFX.Parsing.TokenParser.Content">
            <summary>
            Retrieves raw unparsed content
            </summary>
        </member>
        <member name="T:NFX.Parsing.TokenParser.Token">
            <summary> Token class holds parsed token info along with an array of attributes </summary>
        </member>
        <member name="P:NFX.Parsing.TokenParser.Token.Content">
            <summary>
            A string representing whole token body, in between open and close chars
            </summary>
        </member>
        <member name="P:NFX.Parsing.TokenParser.Token.Name">
            <summary>
            A string representing token name - first identifier within token content
            </summary>
        </member>
        <member name="P:NFX.Parsing.TokenParser.Token.IsSimpleText">
            <summary>
            True if a token represents literal text that gets embedded in response as is
            </summary>
        </member>
        <member name="T:NFX.Parsing.TokenParser.Token.Attribute">
            <summary>
            Attribute class represents token's attribute
            </summary>
        </member>
        <member name="P:NFX.Parsing.TokenParser.Token.Attribute.Name">
            <summary>
            Represents token's attribute name
            </summary>
        </member>
        <member name="P:NFX.Parsing.TokenParser.Token.Attribute.Value">
            <summary>
            Represents token's attribute value
            </summary>
        </member>
        <member name="P:NFX.Parsing.TokenParser.Token.Attribute.Index">
            <summary>
            Attribute index (0-based position) within token tag parse order
            </summary>
        </member>
        <member name="P:NFX.Parsing.TokenParser.Token.Attribute.ContentIndex">
            <summary>
            Attribute body index in content string
            </summary>
        </member>
        <member name="P:NFX.Parsing.TokenParser.Token.Attribute.ContentLength">
            <summary>
            Attribute body length in content string
            </summary>
        </member>
        <member name="M:NFX.Parsing.Utils.ParseFieldNameToDescription(System.String,System.Boolean)">
            <summary>
            Parses database field names (column names) and converts parts to human-readable description
             like:
             "FIRST_NAME" -> "First Name",
             "FirstName" -> "First Name",
             "CHART_OF_ACCOUNTS" -> "Chart of Accounts"
            </summary>
        </member>
        <member name="M:NFX.Parsing.Utils.IsURLValid(System.String)">
            <summary>
            Checks URL string for validity
            </summary>
        </member>
        <member name="M:NFX.Parsing.Utils.MakeSentenceLines(System.String)">
            <summary>
            Puts every sentence on a separate line
            </summary>
        </member>
        <member name="M:NFX.Parsing.Utils.CapturePatternMatch(System.String,System.String,System.Char,System.StringComparison)">
            <summary>
            Returns a captured wildcard segment from string. Pattern uses '*' for match capture by default and may contain a single capture
            </summary>
        </member>
        <member name="M:NFX.Parsing.Utils.MatchPattern(System.String,System.String,System.Char,System.Char,System.Boolean)">
            <summary>
            Returns true if supplied string matches pattern that can contain up to one * wildcard and multiple ? wildcards
            </summary>
        </member>
        <member name="T:NFX.DataAccess.CounterDataStoreKey">
            <summary>
            Represents a key (key field) used in databases that identify entities with BIGINT identity/autoinc columns
            </summary>
        </member>
        <member name="T:NFX.DataAccess.NameValueDataStoreKey">
            <summary>
            Defines dictionary of string/object pairs used for key matching, where string dictionary key represents column name
             in storage and value is an object for the key
            </summary>
        </member>
        <member name="T:NFX.DataAccess.KeyViolationKind">
            <summary>
            Specifies the sub-type of key violation
            </summary>
        </member>
        <member name="T:NFX.Security.AccessLevel">
            <summary>
            A level of access granted to user for certain permission, i.e. if (level.Denied).....
            </summary>
        </member>
        <member name="P:NFX.Security.AccessLevel.User">
            <summary>
            Returns user that this access level is for
            </summary>
        </member>
        <member name="P:NFX.Security.AccessLevel.Permission">
            <summary>
            Returns permission that this access level is for
            </summary>
        </member>
        <member name="P:NFX.Security.AccessLevel.Data">
            <summary>
            Returns security data for this level
            </summary>
        </member>
        <member name="P:NFX.Security.AccessLevel.Level">
            <summary>
            Returns security level attribute from Data
            </summary>
        </member>
        <member name="P:NFX.Security.AccessLevel.Denied">
            <summary>
            Indicates whether access is denied
            </summary>
        </member>
        <member name="T:NFX.Security.ConfigSecurityManager">
            <summary>
            Provides security manager implementation that authenticates and authorizes users from configuration
            </summary>
        </member>
        <member name="T:NFX.Security.ISecurityManagerImplementation">
            <summary>
            Represents an implementation of an entity that performs user authentication based on passed credentials and other security-related global tasks
            </summary>
        </member>
        <member name="T:NFX.Security.ISecurityManager">
            <summary>
            Represents an entity that performs user authentication based on passed credentials and other security-related global tasks
            </summary>
        </member>
        <member name="M:NFX.Security.ISecurityManager.Authenticate(NFX.Security.Credentials)">
            <summary>
            Authenticates user by checking the supplied credentials against the
            authentication store that this manager represents.
            If credential are invalid then UserKind.Invalid is returned.
            This method may populate user access rights completely or partially - depending on store implementation.
            If rights are computed on authentication than Authorize() just checks existing in-memory structure, otherwise
             Authorize() may re-fetch permissions from store on every call or cache them for the specified interval in memory
            </summary>
            <param name="credentials">User credentials.
            Particular manager implementation may elect to support multiple credential types, i.e.
            IdPassword, Twitter, Facebook, OAuth, LegacySystemA/B/C etc.
            </param>
            <returns>
            User object. Check User.Status for UserStatus.Invalid flag to see if authentication succeeded
            </returns>
        </member>
        <member name="M:NFX.Security.ISecurityManager.Authenticate(NFX.Security.AuthenticationToken)">
            <summary>
            Authenticates user by checking the supplied token against the
            authentication store that this manager represents.
            If token is invalid then UserKind.Invalid is returned.
            This method may populate user access rights completely or partially - depending on store implementation.
            If rights are computed on authentication than Authorize() just checks existing in-memory structure, otherwise
             Authorize() may re-fetch permissions from store on every call or cache them for the specified interval in memory
            </summary>
            <param name="token">User authentication token </param>
            <returns>
            User object. Check User.Status for UserStatus.Invalid flag to see if authentication succeeded
            </returns>
        </member>
        <member name="M:NFX.Security.ISecurityManager.Authenticate(NFX.Security.User)">
            <summary>
            Authenticates user by checking the supplied user's token against the
            authentication store that this manager represents.
            This method is called by the framework after User object was deserialized and it's Rights need to be re-fetched.
            If token is invalid then UserStatus.Invalid is set.
            This method may populate user access rights completely or partially - depending on store implementation.
            If rights are computed on authentication than Authorize() just checks existing in-memory structure, otherwise
             Authorize() may re-fetch permissions from store on every call or cache them for the specified interval in memory
            </summary>
            <param name="user">User object which is checked and updated</param>
        </member>
        <member name="M:NFX.Security.ISecurityManager.Authorize(NFX.Security.User,NFX.Security.Permission)">
            <summary>
            Authorizes user by finding appropriate access level to permission by supplied path.
            Depending on particular implementation, rights may be fully or partially cached in memory.
            Note: this authorization call returns AccessLevel object that may contain a complex data structure.
            The final assertion of user's ability to perform a certain action is encapsulated in Permission.Check() method.
            Call Permission.AuthorizeAndGuardAction(MemberInfo, ISession) to guard classes and methods from unauthorized access
            </summary>
            <param name="user">A user to perform authorization for</param>
            <param name="permission">An instance of permission to get</param>
            <returns>AccessLevel granted to specified permission</returns>
        </member>
        <member name="M:NFX.Security.ISecurityManager.GetUserLogArchiveDimensions(NFX.Security.IIdentityDescriptor)">
            <summary>
            Extracts values for archive dimensions to store the log message for the specified user descriptor.
            Depending on the system descriptor represents an entity that describes user (e.g. User, UserInfo, etc.).
            The method only fills the fields specific to user identity
            </summary>
        </member>
        <member name="M:NFX.Security.ISecurityManager.LogSecurityMessage(NFX.Security.SecurityLogAction,NFX.Log.Message,NFX.Security.IIdentityDescriptor)">
            <summary>
            Logs security-related message
            </summary>
            <param name="action">Action that was performed</param>
            <param name="msg">A message to log</param>
            <param name="identity">If msg.ArchiveDim is not set, sets to  GetUserLogArchiveDimensions(user | currentCallContext)</param>
        </member>
        <member name="P:NFX.Security.ISecurityManager.PasswordManager">
            <summary>
            References an entity that manages passwords such as: computes and verified hash tokens
            and provides password strength verification
            </summary>
        </member>
        <member name="P:NFX.Security.ISecurityManagerImplementation.LogMask">
            <summary>
            Defines what events ehould be logged by the system
            </summary>
        </member>
        <member name="P:NFX.Security.ISecurityManagerImplementation.LogLevel">
            <summary>
            Defines the level above which the messages are logged
            </summary>
        </member>
        <member name="M:NFX.Security.ConfigSecurityManager.#ctor">
            <summary>
            Constructs security manager that authenticates users listed in application configuration
            </summary>
        </member>
        <member name="M:NFX.Security.ConfigSecurityManager.#ctor(System.Object)">
            <summary>
            Constructs security manager that authenticates users listed in the supplied configuration section
            </summary>
        </member>
        <member name="P:NFX.Security.ConfigSecurityManager.Config">
            <summary>
            Returns config node that this instance is configured from.
            If null is returned then manager performs authentication from application configuration
            </summary>
        </member>
        <member name="T:NFX.Security.AuthenticationToken">
            <summary>
            Represents security provider-internal ID that SecurityManager assigns into User object on authentication.
            These tokens can be used in place of Credentials to re-authenticate users or to requery user rights.
            External parties should never be supplied with this struct as it is backend-internal
            </summary>
        </member>
        <member name="P:NFX.Security.AuthenticationToken.Realm">
            <summary>
            Provides information about back-end security source (realm) that perfomed authentication, i.e. LDAP instance, Database name etc...
            </summary>
        </member>
        <member name="P:NFX.Security.AuthenticationToken.Data">
            <summary>
            Provides provider-specific key/id that uniquely identifies the user in the realm
            </summary>
        </member>
        <member name="T:NFX.Security.BlankCredentials">
            <summary>
            Represents credentials that are absent. This is a singleton class
            </summary>
        </member>
        <member name="P:NFX.Security.BlankCredentials.Instance">
            <summary>
            Singleton instance of blank credentials
            </summary>
        </member>
        <member name="T:NFX.Security.IStringRepresentableCredentials">
            <summary>
            Denotes credentials that can be represented as a string that can be used for example in Authorization header
            </summary>
        </member>
        <member name="T:NFX.Security.IdentityType">
            <summary>
            Denotes types of identities: Users, Groups etc.
            </summary>
        </member>
        <member name="F:NFX.Security.IdentityType.User">
            <summary>Identity of particular system User</summary>
        </member>
        <member name="F:NFX.Security.IdentityType.Group">
            <summary>Identity of group of users</summary>
        </member>
        <member name="F:NFX.Security.IdentityType.Process">
            <summary>Identity of system component such as Process</summary>
        </member>
        <member name="F:NFX.Security.IdentityType.Business">
            <summary>Identity of business entity such as vendor, bank etc.</summary>
        </member>
        <member name="T:NFX.Security.UserStatus">
            <summary>
            User status enumeration -  super-permission levels
            </summary>
        </member>
        <member name="F:NFX.Security.UserStatus.Invalid">
            <summary>
            Invalid user, not authenticated and not authorized
            </summary>
        </member>
        <member name="F:NFX.Security.UserStatus.User">
            <summary>
            The lowest level of a user, bound by permissions inside their domain and domain section (such as facility)
            </summary>
        </member>
        <member name="F:NFX.Security.UserStatus.Administrator">
            <summary>
            Administrators may run administration console, but always bound by their domain
            </summary>
        </member>
        <member name="F:NFX.Security.UserStatus.System">
            <summary>
            Cross domain user, all restrictions are lifted
            </summary>
        </member>
        <member name="T:NFX.Security.SecurityLogMask">
            <summary>
            Defines what actions should be logged by the system
            </summary>
        </member>
        <member name="T:NFX.Security.SecurityLogAction">
            <summary>
            Denotes security actions
            </summary>
        </member>
        <member name="T:NFX.Security.SecurityException">
            <summary>
            Base exception thrown by the Security framework
            </summary>
        </member>
        <member name="T:NFX.Security.ISecurityException">
            <summary>
            Marker interface for security exceptions
            </summary>
        </member>
        <member name="T:NFX.Security.AuthorizationException">
            <summary>
            Base exception thrown by the security framework
            </summary>
        </member>
        <member name="T:NFX.Security.IDPasswordCredentials">
            <summary>
            Represents simple ID/password textual credentials.
            Note: The password is stored as plain text
            </summary>
        </member>
        <member name="M:NFX.Security.IDPasswordCredentials.PlainPasswordToSecureBuffer(System.String)">
            <summary>
            Obtains an unsecure string password as SecureBuffer.
            Note: The IDPasswordCredentials class is purposely designed to store password as plain text.
            This is needed for simple cases and HTTP application where login credentials are posted via plain text anyway
            </summary>
        </member>
        <member name="M:NFX.Security.IDPasswordCredentials.FromBasicAuth(System.String)">
            <summary>
            Creates IDPass credentials from base64 encoded auth header content as provided by RepresentAsString() method.
            Returns null if the content is unparsable
            </summary>
        </member>
        <member name="M:NFX.Security.IDPasswordCredentials.#ctor(NFX.Environment.IConfigSectionNode)">
            <summary>
            Warning: storing plain credentials in config file is not secure. Use this method for the most simplistic cases
            like unit testing
            </summary>
        </member>
        <member name="M:NFX.Security.IDPasswordCredentials.Forget">
            <summary>
            Deletes sensitive password information.
            This method is mostly used on client (vs. server) to prevent process memory-inspection attack.
            Its is usually called right after Login() was called.
            Implementers may consider forcing post-factum GC.Collect() on all generations to make sure that orphaned
            memory buff with sensitive information, that remains in RAM even after all references are killed, gets
            compacted. This class implementation DOES NOT call Gc.Collect();
            </summary>
        </member>
        <member name="P:NFX.Security.IDPasswordCredentials.SecurePassword">
            <summary>
            Obtains an unsecure string password as SecureBuffer.
            Note: The IDPasswordCredentials class is purposely designed to store password as plain text.
            This is needed for simple cases and HTTP application where login credentials are posted via plain text anyway
            </summary>
        </member>
        <member name="T:NFX.Security.NOPSecurityManager">
            <summary>
            Provides security manager implementation that does nothing and always returns fake user instance
            </summary>
        </member>
        <member name="T:NFX.Security.GetSessionFunc">
            <summary>
            Invoked by permission checker to get session
            </summary>
        </member>
        <member name="T:NFX.Security.Permission">
             <summary>
             Represents a general permission abstraction - where permission type represents the path/name of the permission
              in User's rights and .ctor takes specific parameters to check while authorizing user.
              Permission-derived class represents a certain permission type, whereas its instance is a check for particular desired level.
              To authorize certain actions, one creates an instance of Permission-derived class passing in its .ctor required
               access levels, then calls a Check() method that returns true if action is authorized.
            
             This scheme provides a great deal of flexibility, i.e. for very complex security cases developers may inherit leaf-level permissions from intermediate ones
               that have logic tied to session-level variables, this way user's access may vary by permission/session state, i.e. a user may have
                "Patient.Master" level 4 access in database "A", while having acess denied to the same named permission in database "B".
             User's database, or system instance is a flag in user-session context
             </summary>
        </member>
        <member name="M:NFX.Security.Permission.AuthorizeAction(System.Reflection.MemberInfo,NFX.ApplicationModel.ISession,NFX.Security.GetSessionFunc)">
            <summary>
            Checks the action represented by MemberInfo by checking the permission-derived attributes and returns false if
            any of authorization attributes do not pass
            </summary>
        </member>
        <member name="M:NFX.Security.Permission.FindAuthorizationFailingPermission(System.Reflection.MemberInfo,NFX.ApplicationModel.ISession,NFX.Security.GetSessionFunc)">
            <summary>
            Checks the action represented by MemberInfo by checking the permission-derived attributes and returns false if
            any of authorization attributes do not pass
            </summary>
        </member>
        <member name="M:NFX.Security.Permission.AuthorizeAndGuardAction(System.Reflection.MemberInfo,NFX.ApplicationModel.ISession,NFX.Security.GetSessionFunc)">
            <summary>
            Guards the action represented by MemberInfo by checking the permission-derived attributes and throwing exception if
            any of authorization attributes do not pass
            </summary>
        </member>
        <member name="M:NFX.Security.Permission.AuthorizeAndGuardAction(System.Collections.Generic.IEnumerable{NFX.Security.Permission},System.String,NFX.ApplicationModel.ISession,NFX.Security.GetSessionFunc)">
            <summary>
            Guards the action represented by enumerable of permissions by checking all permissions and throwing exception if
            any of authorization attributes do not pass
            </summary>
        </member>
        <member name="M:NFX.Security.Permission.MultipleFromConf(NFX.Environment.IConfigSectionNode,System.String,System.String)">
            <summary>
            Makes multiple permissions from conf node
            </summary>
        </member>
        <member name="M:NFX.Security.Permission.#ctor(System.Int32)">
            <summary>
            Creates the check instance against the minimum access level for this permission
            </summary>
        </member>
        <member name="M:NFX.Security.Permission.Check(NFX.Security.User)">
            <summary>
            Shortcut method that creates a temp/mock BaseSession object thus checking permission in mock BaseSession context
            </summary>
        </member>
        <member name="M:NFX.Security.Permission.Check(NFX.ApplicationModel.ISession)">
            <summary>
            Checks the permission for requested action as specified in particular permission .ctor.
            The check is performed in the scope of supplied session, or if no session was supplied then
             current execution context session is assumed
            </summary>
            <returns>True when action is authorized, false otherwise</returns>
        </member>
        <member name="M:NFX.Security.Permission.DoCheckAccessLevel(NFX.ApplicationModel.ISession,NFX.Security.AccessLevel)">
            <summary>
            Override to perform access level checks per user's AccessLevel instance.
            True if  accessLevel satisfies permission requirements.
            The default implementation checks the access.Level
            </summary>
        </member>
        <member name="P:NFX.Security.Permission.Name">
            <summary>
            Returns the permission name - the last segment of the path
            </summary>
        </member>
        <member name="P:NFX.Security.Permission.Description">
            <summary>
            Returns the permission description - base implementation returns permission name
            </summary>
        </member>
        <member name="P:NFX.Security.Permission.Path">
            <summary>
            Returns a top-rooted path to this permission (without name)
            </summary>
        </member>
        <member name="P:NFX.Security.Permission.FullPath">
            <summary>
            Returns full permission path - a concatenation of its path and name
            </summary>
        </member>
        <member name="P:NFX.Security.Permission.Level">
            <summary>
            Specifies the minimum access level for the permission check to pass
            </summary>
        </member>
        <member name="T:NFX.Security.TypedPermission">
            <summary>
            A general ancestor for all typed permissions - the ones declared in code
            </summary>
        </member>
        <member name="M:NFX.Security.TypedPermission.#ctor(System.Int32)">
            <summary>
            Creates the check instance against the minimum access level for this typed permission
            </summary>
        </member>
        <member name="T:NFX.Security.AdHocPermission">
            <summary>
            Represents a permission check instance which is a-typical and is based on string arguments
            </summary>
        </member>
        <member name="P:NFX.Security.AdHocPermission.Name">
            <summary>
            Returns the permission name - the last segment of the path
            </summary>
        </member>
        <member name="P:NFX.Security.AdHocPermission.Path">
            <summary>
            Returns a top-rooted path to this permission (without name)
            </summary>
        </member>
        <member name="T:NFX.Security.Rights">
            <summary>
            User rights contains data about access levels to permissions in the system.
            Use Configuration internally to keep the data organized in hierarchical navigable structure.
            Configuration also allows to cross-link permission levels using vars and make acess level
             dependent on settings on a particular machine using environmental vars
            </summary>
        </member>
        <member name="P:NFX.Security.Rights.None">
            <summary>
            An instance that signifies an absence of any rights at all - complete access denied
            </summary>
        </member>
        <member name="T:NFX.Security.IIdentityDescriptor">
            <summary>
            Marker interface denoting entities that represents information about users
            depending on the particular security system implementation
            </summary>
        </member>
        <member name="P:NFX.Security.IIdentityDescriptor.IdentityDescriptorID">
            <summary>
            Represents identity of the descriptor such as User.ID, User.GDID etc.
            Specifics depend on the system
            </summary>
        </member>
        <member name="P:NFX.Security.IIdentityDescriptor.IdentityDescriptorName">
            <summary>
            Provides descriptor name such as User.Name, User.ScreenName etc.
            </summary>
        </member>
        <member name="P:NFX.Security.IIdentityDescriptor.IdentityDescriptorType">
            <summary>
            Denotes types of identities: Users, Groups etc.
            </summary>
        </member>
        <member name="T:NFX.Security.UserIdentityDescriptor">
            <summary>
            Represents information about user identity
            </summary>
        </member>
        <member name="T:NFX.Security.User">
            <summary>
            Provides base user functionality. Particular security manager implementations may return users derived from this class
            </summary>
        </member>
        <member name="M:NFX.Security.User.Invalidate">
            <summary>
            Makes user invalid
            </summary>
        </member>
        <member name="M:NFX.Security.User.___update_status(NFX.Security.UserStatus,System.String,System.String,NFX.Security.Rights)">
            <summary>
            Framework-internal. Do not call
            </summary>
        </member>
        <member name="M:NFX.Security.User.IsInRole(System.String)">
            <summary>
            Determines whether the current principal belongs to the specified role.
            This method implements IPrincipal and has little application in NFX framework context
            as NFX permissions are more granular than just boolean. This method really checks user kind (User/Admin/Sys).
            Confusion comes from the fact that what Microsoft calls role really is just a single named permission -
             a role is a named permission set in NFX.
            </summary>
        </member>
        <member name="P:NFX.Security.User.Fake">
            <summary>
            Returns default instance of the fake user that has no rights
            </summary>
        </member>
        <member name="P:NFX.Security.User.StatusTimeStampUTC">
            <summary>
            Captures timestamp when this user was set to current status (created/set rights)
            Security managers may elect to reftech user rights after some period
            </summary>
        </member>
        <member name="P:NFX.Security.User.Rights">
            <summary>
            Returns data bag that contains user rights. This is a framework-only internal property
             which should not be used by application developers. This bag may get populated fully-or-partially
              by ISecurityManager implementation. Use User[permission] indexer or Application.SecurityManager.Authorize()
               to obtain AccessLevel
            </summary>
        </member>
        <member name="P:NFX.Security.User.Item(NFX.Security.Permission)">
            <summary>
            Authorizes user to specified permission.
            Note: this authorization call returns AccessLevel object that may contain a complex data structure.
            The final assertion of user's ability to perform a certain action is encapsulated in Permission.Check() method.
            Call Permission.AuthorizeAndGuardAction(MemberInfo, ISession) to guard classes and methods from unauthorized access
            </summary>
        </member>
        <member name="P:NFX.Security.User.AuthenticationType">
            <summary>
            Implementation of IIdentity interface
            </summary>
        </member>
        <member name="P:NFX.Security.User.IsAuthenticated">
            <summary>
            Implementation of IIdentity interface. Checks to see if user is not in invalid status
            </summary>
        </member>
        <member name="P:NFX.Security.User.Identity">
            <summary>
            Implementation of IPrincipal interface
            </summary>
        </member>
        <member name="T:NFX.IO.SlimReader">
            <summary>
            Reads primitives and other supported types from Slim-format stream. Use factory method of SlimFormat instance to create a new instance of SlimReader class
            </summary>
        </member>
        <member name="P:NFX.IO.SlimReader.Format">
            <summary>
            Returns SlimFormat that this reader implements
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONException">
            <summary>
            Base exception thrown by the JSON serialization format
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONSerializationException">
            <summary>
            Base exception thrown by the JSON when serializing objects
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONDeserializationException">
            <summary>
            Base exception thrown by the JSON when deserializing objects
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONDynamicObjectKind">
            <summary>
            Specifies what kind the dynamic object is - map or array
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONDynamicObject">
            <summary>
            Implements a JSON dynamic object that shapes itself at runtime
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONDynamicObject.#ctor(NFX.Serialization.JSON.JSONDynamicObjectKind,System.Boolean)">
            <summary>
            Creates a dynamic wrapper around existing array or map. Optionally specifies map key case sensitivity
            </summary>
        </member>
        <member name="P:NFX.Serialization.JSON.JSONDynamicObject.Data">
            <summary>
            Returns the underlying JSON data
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONReader">
            <summary>
            Provides deserialization functionality from JSON format
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONReader.ToRowset(System.String,System.Boolean,System.Boolean)">
            <summary>
            Deserializes into Rowset or Table from JSOnDataMap, as serialized by RowsedBase.WriteAsJSON()
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONReader.ToRowset(NFX.Serialization.JSON.JSONDataMap,System.Boolean,System.Boolean)">
            <summary>
            Deserializes into Rowset or Table from JSONDataMap, as serialized by RowsedBase.WriteAsJSON()
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONReader.ToRow(System.Type,NFX.Serialization.JSON.JSONDataMap,System.Boolean,System.Nullable{NFX.Serialization.JSON.JSONReader.NameBinding})">
            <summary>
            Converts JSONMap into typed row of the requested type.
            The requested type must be derived from NFX.DataAccess.CRUD.TypedRow.
            The extra data found in JSON map will be placed in AmorphousData dictionary if the row implemets IAmorphousData, discarded otherwise.
            Note: This method provides "the best match" and does not guarantee that all data will/can be converted from JSON, i.e.
             it can only convert one dimensional arrays and Lists of either primitive or TypeRow-derived entries
            </summary>
            <param name="type">TypedRow subtype to convert into</param>
            <param name="jsonMap">JSON data to convert into row</param>
            <param name="fromUI">When true indicates that data came from UI, hence NonUI-marked fields should be skipped. True by default</param>
            <param name="nameBinding">Used for backend name matching or null (any target)</param>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONReader.ToRow``1(NFX.Serialization.JSON.JSONDataMap,System.Boolean,System.Nullable{NFX.Serialization.JSON.JSONReader.NameBinding})">
            <summary>
            Generic version of ToRow(Type, JSONDataMap, bool)/>
            </summary>
            <typeparam name="T">TypedRow</typeparam>
        </member>
        <member name="M:NFX.Serialization.JSON.JSONReader.ToRow(NFX.DataAccess.CRUD.Row,NFX.Serialization.JSON.JSONDataMap,System.Boolean,System.Nullable{NFX.Serialization.JSON.JSONReader.NameBinding})">
            <summary>
            Converts JSONMap into supplied row instance.
            The extra data found in JSON map will be placed in AmorphousData dictionary if the row implemets IAmorphousData, discarded otherwise.
            Note: This method provides "the best match" and does not guarantee that all data will/can be converted from JSON, i.e.
             it can only convert one dimensional arrays and Lists of either primitive or TypeRow-derived entries
            </summary>
            <param name="row">Row instance to convert into</param>
            <param name="jsonMap">JSON data to convert into row</param>
            <param name="fromUI">When true indicates that data came from UI, hence NonUI-marked fields should be skipped. True by default</param>
            <param name="nameBinding">Used for backend name matching or null (any target)</param>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONReader.NameBinding">
            <summary>
            Specifies how reader should mathc JSON to row field property member or backend names
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONSerializationPurpose">
            <summary>
            Specifies the purpose of JSON serialization so the level of detail may be dynamically adjusted.
            Depending on this parameter IJSONWritable implementors may include additional details
            that are otherwise not needed
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONSerializationPurpose.UIFeed">
            <summary>
            UI Interface feeding - include only the data needed to show to the user
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONSerializationPurpose.Marshalling">
            <summary>
            Include as much data as possible for remote object reconstruction
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.JSONWritingOptions">
            <summary>
            Specifies how JSON should be written as text. Use JSONWritingOptions.Compact or JSONWritingOptions.PrettyPrint
             static properties for typical options
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.NLSMapLanguageISO">
            <summary>
            Specifies language ISO code (3 chars) that is used (when set) by the NLSMap class,
            so only entries for that particular language are included. When NLSMap contains entries for more than 1 language,
            but user needs only one entry received for his/her selected language, this option can be set, then NLSMap will only inline
            Name:Descr pair for that language. If a map does not contain an entry for the reequested lang then NLSMapLanguageISODefault
            will be tried
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.NLSMapLanguageISODefault">
            <summary>
            Specified language ISO default for NLSMap lookup, "eng" is used for default
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.IndentWidth">
            <summary>
            Specifies character width of single indent level
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.SpaceSymbols">
            <summary>
            Indicates whether a space must be placed right after the symbol, such as coma in array declaration or colon in member declaration for
             better readability
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.ObjectLineBreak">
            <summary>
            Specifies whether objects need to be separated by line brakes for better readability
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.MemberLineBreak">
            <summary>
            Specifies whether every object member must be placed on a separate line for better readability
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.ASCIITarget">
            <summary>
            Specifies whether the target of serialization only deals with ASCII characeters,
            so any non-ASCII character with code above 127 must be escaped with unicode escape sequence
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.ISODates">
            <summary>
            Specifies whether DateTime must be encoded using ISO8601 format that look like "2011-03-18T14:25:00Z",
            otherwise dates are encoded using "new Date(milliseconds_since_unix_epoch)" which is technically not a valid JSON, however
             most JSON parsers understand it very well
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.MaxNestingLevel">
            <summary>
            Sets a limit of object nesting, i.e. for recursive graph depth. Default is 0xff
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.RowsAsMap">
            <summary>
            When true, writes every row as a map {FieldName: FieldValue,...} instead of array of values
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.RowsetMetadata">
            <summary>
            When true, writes rowset metadata (i.e. schema, instance id etc.)
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.Purpose">
            <summary>
            Specifies the purpose of JSON serialization so the level of detail may be dynamically adjusted.
            Depending on this parameter IJSONWritable implementors may include additional details
            that are otherwise not needed
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.MapSkipNulls">
            <summary>
            If true, then does not write map keys which are null
            </summary>
        </member>
        <member name="F:NFX.Serialization.JSON.JSONWritingOptions.RowMapTargetName">
            <summary>
            When set, specifies the target name for Row's fields when they are written as map
            </summary>
        </member>
        <member name="P:NFX.Serialization.JSON.JSONWritingOptions.Compact">
            <summary>
            Writes JSON without line breaks between members and no indenting. Suitable for data transmission
            </summary>
        </member>
        <member name="P:NFX.Serialization.JSON.JSONWritingOptions.CompactRowsAsMap">
            <summary>
            Writes JSON without line breaks between members and no indenting writing rows as maps(key:values) instead of arrays. Suitable for data transmission
            </summary>
        </member>
        <member name="P:NFX.Serialization.JSON.JSONWritingOptions.CompactASCII">
            <summary>
            Writes JSON without line breaks between members and no indenting escaping any characters
             with codes above 127 suitable for ASCII transmission
            </summary>
        </member>
        <member name="P:NFX.Serialization.JSON.JSONWritingOptions.PrettyPrint">
            <summary>
            Writes JSON suitable for printing/screen display
            </summary>
        </member>
        <member name="P:NFX.Serialization.JSON.JSONWritingOptions.PrettyPrintASCII">
            <summary>
            Writes JSON suitable for printing/screen display
             with codes above 127 suitable for ASCII transmission
            </summary>
        </member>
        <member name="P:NFX.Serialization.JSON.JSONWritingOptions.PrettyPrintRowsAsMap">
            <summary>
            Writes JSON suitable for printing/screen display writing rows as maps(key:values) instead of arrays
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.NLSMap">
            <summary>
            Represents a JSON-serializable structure that keys [N]ame and [D]escription on lang ISO.
            It respects JSONWritingOptions.NLSMapLanguageISO and NLSMapLanguageISODefault
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.NLSMap.#ctor(System.String)">
            <summary>
            Makes NLSMap out of JSON string: {eng: {n: 'Cucumber',d: 'It is green'}, deu: {n='Gurke',d='Es ist grün'}}
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.NLSMap.#ctor(NFX.Environment.IConfigSectionNode)">
            <summary>
            Makes NLSMap out of conf node: eng{n='Cucumber' d='It is green'} deu{n='Gurke' d='Es ist grün'}
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.NLSMap.OverrideBy(NFX.Serialization.JSON.NLSMap)">
            <summary>
            Takes entries from this instance and overides them by ISO keys from another instance returning the new instance
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.NLSMap.Get(NFX.Serialization.JSON.NLSMap.GetParts,System.String,System.String,System.String)">
            <summary>
            Tries to get the specified part(s) from the map defaulting to another lang if requested lang is not found.
            Returns null if nothing is found
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.NLSMap.TryGet(System.String,System.String@,NFX.Serialization.JSON.NLSMap.GetParts,System.String,System.String,System.String)">
            <summary>
            Tries to get the specified part(s) from the JSON content that represents map defaulting to another lang if requested lang is not found.
            Returns null if nothing is found
            </summary>
        </member>
        <member name="M:NFX.Serialization.JSON.NLSMap.WriteAsJSON(System.IO.TextWriter,System.Int32,NFX.Serialization.JSON.JSONWritingOptions)">
            <summary>
            Writes NLSMap either as a dict or as a {n:"", d: ""} pair as Options.NLSMapLanguageISO filter dictates
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.NLSMap.Builder">
            <summary>
            Facilitates the population of NLSMap from code
            </summary>
        </member>
        <member name="P:NFX.Serialization.JSON.NLSMap.Builder.Map">
            <summary>
            Returns the built map
            </summary>
        </member>
        <member name="T:NFX.Serialization.JSON.NLSMap.NDPair">
            <summary>
            Localized Name:Description pair
            </summary>
        </member>
        <member name="T:NFX.Serialization.MSBinaryFormatter">
            <summary>
            Implements ISerializer with Ms BinaryFormatter
            </summary>
        </member>
        <member name="T:NFX.Serialization.ISerializer">
            <summary>
            Describes an entity that can serialize and deserialize objects
            </summary>
        </member>
        <member name="P:NFX.Serialization.ISerializer.IsThreadSafe">
            <summary>
            Indicates whether Serialize/Deserialize may be called by multiple threads at the same time
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.CustomTypedEntry">
            <summary>
            Used in custom data bags to specify the type of the object contained in Data property if it is intended to be re-interpreted
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.CompositeCustomData">
            <summary>
            Represents a composite (non primitive) data stored in Portable Object Document.
            This data is obtained from native types using ISerializable interface or running PortableObjectDocumentTransform attribute.
            This class is NOT used for native types that perform default reflection-based serialization,
             for that CompositeReflectedData is used
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.CompositeData">
            <summary>
            Represents a composite (non primitive) data stored in Portable Object Document.
            This data is obtained from native types either automatically using reflection or
             from types that perform custom serialization using ISerializable interface
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.CompositeData.Document">
            <summary>
            Returns document instance that contains this type
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.CompositeData.ExistingReference">
            <summary>
            Returns true when this instance contains a reference to existing object
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.CompositeData.ExistingReferenceIndex">
            <summary>
            Returns either an index that is less than 0 or and index to an existing object which is >=0
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.CompositeData.Referenced">
            <summary>
            Returns another composite data that is referenced, if nothing is referenced, returns null
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.CompositeData.Type">
            <summary>
            Returns type of this data
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.CompositeCustomData.CustomData">
            <summary>
            Returns custom data that this instance contains, or null if this instance is a reference to another object
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.CompositeReflectedData">
            <summary>
            Represents a composite (non primitive) data stored in Portable Object Document.
            This data is obtained from native types automatically using reflection.
            This class is NOT used for native types that perform custom serialization using ISerializable interface,
             for that CompositeCustomData is used
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.CompositeReflectedData.FieldData">
            <summary>
            Returns field data that this instance contains, or null if this instance is a reference to another object
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.CompositeArrayData">
            <summary>
            Represents a composite (non primitive) array data stored in Portable Object Document.
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.CompositeArrayData.ArrayData">
            <summary>
            Returns field data that this instance contains, or null if this instance is a reference to another object
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.CompositeArrayData.ArrayDims">
            <summary>
            Returns array dimensions
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.PODException">
            <summary>
            Base exception thrown by the Portable Object Document serialization format
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.PODSerializationException">
            <summary>
            Base exception thrown by the PortableObjectDocument when serializing objects into document
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.PODDeserializationException">
            <summary>
            Base exception thrown by the PortableObjectDocument when deserializing original objects
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.ReadingStrategy">
            <summary>
            Represents logic that resolves POD data types and field layouts to CLR types/layouts.
            Extend this type and pass its instance into PortableObjectDocument.ToOriginalObject(ReadingStrategy)
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.ReadingStrategy.ResolveType(NFX.Serialization.POD.MetaType)">
            <summary>
            Resolves a MetaType instance from a particular document into CLR Type, i.e. an obsolete class named "ABC" may be resolved into
             newer class "ABCX"
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.ReadingStrategy.ConstructObject(NFX.Serialization.POD.CompositeData)">
            <summary>
            Constructs object out of CompositeData. This implementation calls ResolveType then tries to invoke attribute constructor first
            then create instance using default ctor
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.ReadingStrategy.MakeNewObjectInstanceUsingDefaultCtor(System.Type)">
            <summary>
            Creates an object using its default .ctor. This implementation uses "magic" to create uninit buffer first
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.ReadingStrategy.MakeNewArrayInstance(NFX.Serialization.POD.CompositeArrayData)">
            <summary>
            Creates an array instance described by the CompositeArrayData instance
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.ReadingStrategy.CompositeToNative(NFX.Serialization.POD.CompositeData)">
            <summary>
            Resolves composite data into CLR object
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.ReadingStrategy.SetFieldData(System.Object,System.Reflection.FieldInfo,NFX.Serialization.POD.CompositeReflectedData,NFX.Serialization.POD.MetaComplexType.MetaField)">
            <summary>
            Performs the assignment of portable data into native field
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.ReadingStrategy.ResolveField(System.Type,NFX.Serialization.POD.MetaComplexType.MetaField)">
            <summary>
            Resolves a meta field definition into actual native field. Returns null wen resolution is not possible and field should be skipped
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.ReadingStrategy.DeserializeSerializationInfo(System.Type,NFX.Serialization.POD.CompositeCustomData,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Performs deserialization of SerializationInfo from CompositeCustomData bag
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.ReadingStrategy.Default">
            <summary>
            Returns an instance of default strategy
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.PortableObjectDocumentSerializationTransform">
            <summary>
            Represents an entity that knows how to transform/apply CLR data types to PortableObjectDocument
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocumentSerializationTransform.SerializeCustomObjectData(NFX.Serialization.POD.PortableObjectDocument,System.Object,System.Collections.Generic.Dictionary{System.String,NFX.Serialization.POD.CustomTypedEntry})">
            <summary>
            Override to provide custome seriallization of type marked with this attribute into custom name/value bag
            </summary>
            <param name="document">Document context that this operation executes under</param>
            <param name="source">Source native data to serialize / populate data from</param>
            <param name="data">Name/value bag to write data into</param>
        </member>
        <member name="T:NFX.Serialization.POD.PortableObjectDocumentDeserializationTransform">
            <summary>
            Represents an entity that knows how to transform/apply CLR data types from PortableObjectDocument
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocumentDeserializationTransform.ConstructObjectInstance(NFX.Serialization.POD.CompositeData)">
            <summary>
            Override to construct new object instance from CompositeData.
            Return null to let the default implementatiom/ctor be invoked by the framework
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocumentDeserializationTransform.DeserializeFromCompositeCustomData(System.Object,NFX.Serialization.POD.CompositeCustomData)">
            <summary>
            Handles the deserialization of the object instance from CompoisteCustomData bag. Returns true to indicate that
             deserialization was handled completely here and default framework implementation should not be called
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocumentDeserializationTransform.DeserializeFromCompositeReflectedData(System.Object,NFX.Serialization.POD.CompositeReflectedData)">
            <summary>
            Handles the deserialization of the object instance from CompoisteReflectedData. Returns a set of fields that were handles by this implementation
             so that framework code can skip them. Return null or empty set when method is not implemented
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocumentDeserializationTransform.SetFieldValue(NFX.Serialization.POD.ReadingStrategy,System.Object,System.Reflection.FieldInfo,NFX.Serialization.POD.CompositeReflectedData,NFX.Serialization.POD.MetaComplexType.MetaField)">
            <summary>
            Handles the assignemnt from ReflectedData into CLR fieldInfo. Override to make conversions, i.e. string to bool, int to string etc...
            Return true to indicate that default framework implementation should not be called
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocumentDeserializationTransform.ResolveField(System.Type,NFX.Serialization.POD.MetaComplexType.MetaField)">
            <summary>
            Resolves a meta field definition into actual native field. Returns null wen resolution is not possible and field should be skipped
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.MetaType">
            <summary>
            Provides information about data types stored in Portable Object Document
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.MetaType.GetExistingOrNewMetaTypeIndex(NFX.Serialization.POD.PortableObjectDocument,System.Type)">
            <summary>
            Obtains new or existing instance of MetaType that represents a Type in the document instance
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.MetaType.Document">
            <summary>
            Returns document instance that contains this type
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.MetaType.Name">
            <summary>
            Returns Type.Name
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.MetaType.Namespace">
            <summary>
            Returns Type.Namespace
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.MetaType.AssemblyQualifiedName">
            <summary>
            Returns Type.AssemblyQualifiedName
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.MetaPrimitiveType">
            <summary>
            Represents primitive built-in types in the framework that are stored in Portable Object Document
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.MetaComplexType">
            <summary>
            Represents information about the composite type of data that is stored in Portable Object Document
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.MetaComplexType.BuildInfo">
            <summary>
            Returns assembly build information
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.MetaComplexType.ArrayRank">
            <summary>
            Returns number of dimensions for arrays
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.MetaComplexType.ArrayElementTypeIndex">
            <summary>
            Returns index of the meta type of array element
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.MetaComplexType.ArrayElementType">
            <summary>
            Returns MetaType of array element
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.MetaComplexType.FieldCount">
            <summary>
            Returns the serializable field count described by this type
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.MetaComplexType.MetaField">
            <summary>
            Represents an information about a field of same type
            </summary>
        </member>
        <member name="T:NFX.Serialization.POD.PortableObjectDocument">
            <summary>
            Represents an graph of arbitrary CLR objects as a graph of well known POD-objects which are based on primitive-only types.
            This class acts as a Document-Object-Model container that hosts comlex CLR types that may change their structure
             but need to be deserialized even if deserialization is partial / requires transform
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocument.#ctor(System.Object,System.Nullable{System.DateTime},System.String)">
            <summary>
            Creates a new instance of object document from the graph of arbitrary CLR objects serializing them into well-known POD object types
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocument.ToOriginalObject(NFX.Serialization.POD.ReadingStrategy)">
            <summary>
            Deserializes PortableObjectDocument into original graph of arbitrary CLR objects trying to preserve/convert as much data as possible
             using optionally supplied strategy
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocument.GetExistingOrNewMetaTypeIndex(System.Type)">
            <summary>
            Obtains new or existing index of MetaType that represents a Type in this document instance.
            If this document instance already has this type registered, then existing index is returned, otherwise
             the new MetaType instance that represents the supplied CLR Type is created and registered under the document-unique index
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocument.GetExistingOrNewMetaType(System.Type)">
            <summary>
            Obtains new or existing MetaType instance that represents a Type in this document instance.
            If this document instance already has this type registered, then existing MetaType instance is returned, otherwise
             the new MetaType instance that represents the supplied CLR Type is created and registered under the document-unique index
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocument.GetMetaTypeFromIndex(System.Int32)">
            <summary>
            Returns MetaType by index
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocument.NativeDataToPortableData(System.Object)">
            <summary>
            Transforms a native value, such as object, primitive, struct etc.. into a value that can be stored in the PortableObjectDocument.
            The complex types are stored as CompositeData, primitives are stored as-is (boxed)
            </summary>
        </member>
        <member name="M:NFX.Serialization.POD.PortableObjectDocument.PortableDataToNativeData(NFX.Serialization.POD.ReadingStrategy,System.Object)">
            <summary>
            Transforms a portable data value, such as object, primitive, struct etc.. into a CLR
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.PortableObjectDocument.BuildInformation">
            <summary>
            Returns build information for framework that contains the PortableObjectDocuemnt type
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.PortableObjectDocument.CreationDate">
            <summary>
            Returns timestamp when this doc was created
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.PortableObjectDocument.Notes">
            <summary>
            Returns notes supplied when document was created
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.PortableObjectDocument.MetaTypes">
            <summary>
            Returns meta types that this document contains
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.PortableObjectDocument.Root">
            <summary>
            Returns graph root potable object that this document represents, not a native object
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.PortableObjectDocument.RootMetaTypeIndex">
            <summary>
            Returns graph root object meta type index, if root data is null then 0 is returned which is an index of MetaCompositeType(Object) type
            </summary>
        </member>
        <member name="P:NFX.Serialization.POD.PortableObjectDocument.RootMetaType">
            <summary>
            Returns graph root object meta type index, if root is null them MetaCompositeType(Object) is returned
            </summary>
        </member>
        <member name="T:NFX.Serialization.Arow.DataType">
            <summary>
            Denotes types that Arow directly supports. Complex object are serialized as POD
            </summary>
        </member>
        <member name="T:NFX.Serialization.SerializationUtils">
            <summary>
            Provides misc serialization-related functions that are really low-level and not intended to be used by developers.
            Methods are thread-safe
            </summary>
        </member>
        <member name="M:NFX.Serialization.SerializationUtils.GetISerializableCtorInfo(System.Type)">
            <summary>
            Returns .ctor(SerializationInfo, StreamingContext) that complies with ISerializable concept, or null.
            </summary>
        </member>
        <member name="M:NFX.Serialization.SerializationUtils.MakeNewObjectInstance(System.Type)">
            <summary>
            Create new object instance for type, calling default ctor
            </summary>
        </member>
        <member name="M:NFX.Serialization.SerializationUtils.GetSerializableFields(System.Type)">
            <summary>
            Gets all serializable fields for type in parent->child declaraion order, sub-ordered by case
             within the segment
            </summary>
        </member>
        <member name="M:NFX.Serialization.SerializationUtils.FindSerializationAttributedMethods(System.Type,System.Type)">
            <summary>
            Finds methods decorated by [On(De)Seriali(zing/zed)]
            </summary>
            <param name="t">A type whose methods to search</param>
            <param name="atype">Attribute type to search</param>
            <returns>List(MethodInfo) that qualifies or NULL if none found</returns>
        </member>
        <member name="M:NFX.Serialization.SerializationUtils.InvokeSerializationAttributedMethods(System.Collections.Generic.List{System.Reflection.MethodInfo},System.Object,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Calls method in the list that was returned by a call to FindSerializationAttributedMethods
            </summary>
            <param name="methods">list that was returned by a call to FindSerializationAttributedMethods</param>
            <param name="instance">Instance to invoke mathods on</param>
            <param name="streamingContext">Streaming Context</param>
        </member>
        <member name="M:NFX.Serialization.SerializationUtils.WalkArrayWrite(System.Array,System.Action{System.Object})">
            <summary>
            Performs an action on each element of a possibly mutidimensional array
            </summary>
        </member>
        <member name="M:NFX.Serialization.SerializationUtils.WalkArrayRead``1(System.Array,System.Func{``0})">
            <summary>
            Performs an action on each element of a possibly mutidimensional array
            </summary>
        </member>
        <member name="M:NFX.Serialization.SerializationUtils.GetNodeByPath(NFX.Serialization.JSON.JSONDataMap,System.String[])">
            <summary>
            Navigates through JSON datamap by subsequent node names.
            </summary>
            <returns>
            null if navigation path is not exists.
            JSONDataMap if navigation ends up with non-leaf node.
            object if navigation ends up with leaf node.</returns>
        </member>
        <member name="F:NFX.Serialization.Slim.Arrays.MAX_DIM_COUNT">
            <summary>
            Maximum number of supported array dimensions.
            Used for possible stream corruption detection
            </summary>
        </member>
        <member name="F:NFX.Serialization.Slim.Arrays.MAX_ELM_COUNT">
            <summary>
            Maximum number of elements in any array.
            Used for possible stream corruption detection
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.SlimDeserializationCtorSkipAttribute">
            <summary>
            When set on a parameterless constructor, instructs the Slim serializer not to invoke
             the ctor() on deserialization
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.SlimSerializationProhibitedAttribute">
            <summary>
            When set fails an attempt to serialize the decorated type
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.TypeRegistryMode">
            <summary>
            Denotes modes of handling type registry by Slim serializer
            </summary>
        </member>
        <member name="F:NFX.Serialization.Slim.TypeRegistryMode.PerCall">
            <summary>
            Type registry object is created for every Serialize/Deserialize call only
            cloning global types. This is the default mode which is thread-safe(many threads can call Serialize/Deserialize at the same time)
            </summary>
        </member>
        <member name="F:NFX.Serialization.Slim.TypeRegistryMode.Batch">
            <summary>
            Type registry object is cloned from global types only once and it is retained after making calls.
            This is not a thread-safe mode, so only one thread may call Serialize/Deserialize at a time.
            This mode is beneficial for cases when many object instances of various types need to be transmitted
            so repeating their type names in every Ser/Deser is not efficient. In batch mode the type name is
             written/read to/from stream only once, then type handles are transmitted instead thus saving space and
             extra allocations
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.ISlimSerializer">
            <summary>
            Marker interface for formats based on Slim algorithm family
            </summary>
        </member>
        <member name="M:NFX.Serialization.Slim.ISlimSerializer.ResetCallBatch">
            <summary>
            Resets type registry state to initial state (which is based on global types) for TypeMode = "Batch",
            otherwise does nothing
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.ISlimSerializer.TypeMode">
            <summary>
            Gets/sets how serializer handles type information between calls to Serialize/Deserialize.
            This property itself is not thread-safe, that is - it should be only set once by control/initiating thread
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.ISlimSerializer.BatchTypesAdded">
            <summary>
            Returns true if last call to Serialize or Deserialize in batch mode added more types to type registry.
            This call is only valid in TypeMode = "Batch" and is inherently not thread-safe
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.PODSlimSerializer">
            <summary>
            Serializes CLR object graphs using PortableObjectDocument container and Slim binary serialization algorithm.
            This class is far less performant than SlimSerializer, however it serializes types using document model that
             allows to transform/change data during serialization/deserialization.
            This class is needed for upgrades, when object metadata may change but need to be read (maybe partially) back into the new type structure
            </summary>
        </member>
        <member name="M:NFX.Serialization.Slim.PODSlimSerializer.NFX#Serialization#Slim#ISlimSerializer#ResetCallBatch">
            <summary>
            This method does nothig in this class
            </summary>
        </member>
        <member name="M:NFX.Serialization.Slim.PODSlimSerializer.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Serializes a graph of arbitrary CLR objects into stream using PortableObjectDocument container
            </summary>
            <param name="stream">Target stream</param>
            <param name="root">CLR object graph</param>
        </member>
        <member name="M:NFX.Serialization.Slim.PODSlimSerializer.Serialize(System.IO.Stream,System.Object,System.Nullable{System.DateTime},System.String)">
            <summary>
            Serializes a graph of arbitrary CLR objects into stream using PortableObjectDocument container,
             optionally taking document creation attributes
            </summary>
            <param name="stream">Target stream</param>
            <param name="root">CLR object graph</param>
            <param name="documentCreationDate">Optional document creation attribute</param>
            <param name="documentNotes">Optional document creation attribute</param>
        </member>
        <member name="M:NFX.Serialization.Slim.PODSlimSerializer.Deserialize(System.IO.Stream,NFX.Serialization.POD.ReadingStrategy)">
            <summary>
            Desirializes a graph of arbitrary CLR objects that was serialized before
            </summary>
            <param name="stream">Source data stream in Slim binary format</param>
            <param name="readingStrategy">Optional reading strategy</param>
            <returns>CLR object graph which is deserialized from possibly transformed PortableObjectDocument container</returns>
        </member>
        <member name="M:NFX.Serialization.Slim.PODSlimSerializer.Deserialize(System.IO.Stream)">
            <summary>
            Desirializes a graph of arbitrary CLR objects that was serialized before
            </summary>
            <param name="stream">Source data stream in Slim binary format</param>
            <returns>CLR object graph which is deserialized from possibly transformed PortableObjectDocument container</returns>
        </member>
        <member name="M:NFX.Serialization.Slim.PODSlimSerializer.DeserializeDocument(System.IO.Stream)">
            <summary>
            Deserializes a PortableObjectDocument container instance
            </summary>
            <param name="stream">Source data stream in Slim binary format</param>
            <returns>PortableObjectDocument instance</returns>
        </member>
        <member name="P:NFX.Serialization.Slim.PODSlimSerializer.NFX#Serialization#Slim#ISlimSerializer#TypeMode">
            <summary>
            This serializer always uses "PerCall" setting. Setting this property has no effect
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.PODSlimSerializer.NFX#Serialization#ISerializer#IsThreadSafe">
            <summary>
            This serializer is thread-safe
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.PODSlimSerializer.NFX#Serialization#Slim#ISlimSerializer#BatchTypesAdded">
            <summary>
            Not supported here
            </summary>
        </member>
        <member name="M:NFX.Serialization.Slim.RefPool.GetHandle(System.Object,NFX.Serialization.Slim.TypeRegistry,NFX.IO.SlimFormat,System.Type@)">
            <summary>
            Emits MetaHandle that contains type handle for reference handle only when this referenced is added to pool for the first time.
            Emits inlined string for strings and inlined value types for boxed objects.
            Emits additional array dimensions info for array refernces who's types are emitted for the first time
            </summary>
        </member>
        <member name="M:NFX.Serialization.Slim.RefPool.HandleToReference(NFX.IO.MetaHandle,NFX.Serialization.Slim.TypeRegistry,NFX.IO.SlimFormat,NFX.IO.SlimReader)">
            <summary>
            Returns object reference for supplied metahandle
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.SlimSerializer">
            <summary>
            Implements Slim serialization algorithm that relies on an injectable SlimFormat-derivative (through .ctor) paremeter.
            This class was designed for highly-efficient serialization of types without versioning.
            SlimSerializer supports a concept of "known types" that save space by not emitting their names into stream.
            Performance note:
            This serializer yields on average 1/4 serialization and 1/2 deserialization times while compared to BinaryFormatter.
            Serialization of Record-instances usually takes 1/6 of BinaryFormatter time.
            Format takes 1/10 space for records and 1/2 for general object graphs.
            Such performance is achieved because of dynamic compilation of type-specific serialization/deserialization methods.
            This type is thread-safe for serializations/deserializations when TypeMode is set to "PerCall"
            </summary>
        </member>
        <member name="F:NFX.Serialization.Slim.SlimSerializer.Owner">
            <summary>
            Associates arbitrary owner object with this instance. Slim serializer does not use this field internally for any purpose
            </summary>
        </member>
        <member name="M:NFX.Serialization.Slim.SlimSerializer.ResetCallBatch">
            <summary>
            Resets type registry to initial state (which is based on global types) for TypeMode = "Batch",
            otherwise does nothing. This method is not thread-safe
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.SlimSerializer.TypeMode">
            <summary>
            Gets/sets how serializer handles type information between calls to Serialize/Deserialize.
            Setting this to "Batch" makes this serializer instance not thread-safe for calling Serialize/Deserialize.
            This property itself is not thread-safe, that is - it should be only set once by control/initiating thread
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.SlimSerializer.IsThreadSafe">
            <summary>
            Returns true when TypeMode is "PerCall"
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.SlimSerializer.BatchTypesAdded">
            <summary>
            Returns true if last call to Serialize or Deserialize in batch mode added more types to type registry.
            This call is only valid in TypeMode = "Batch" and is inherently not thread-safe
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.SlimSerializer.BatchTypeRegistry">
            <summary>
            ADVANCED FEATURE! Developers do not use.
            Returns type registry used in batch.
            This call is only valid in TypeMode = "Batch" and is inherently not thread-safe.
            Be careful not to mutate the returned object
            </summary>
        </member>
        <member name="T:NFX.IO.SlimWriter">
            <summary>
            Writes primitives and other supported types to Slim-format stream. Use factory method of SlimFormat instance to create a new instance of SlimWriter class
            </summary>
        </member>
        <member name="P:NFX.IO.SlimWriter.Format">
            <summary>
            Returns SlimFormat that this writer implements
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.SlimException">
            <summary>
            Base exception thrown by the Slim serialization format
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.SlimSerializationException">
            <summary>
            Base exception thrown by the Slim when serializing objects
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.SlimDeserializationException">
            <summary>
            Base exception thrown by the Slim when deserializing objects
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.SlimInvalidTypeHandleException">
            <summary>
            Thrown by type registry when supplied type handle is invalid/not found
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.SlimSerializationProhibitedException">
            <summary>
            Thrown when a type is decoreted with SlimSerializationProhibitedAttribute
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.TypeRegistry">
            <summary>
            Provides a registry of types, types that do not need to be described in a serialization stream
            </summary>
        </member>
        <member name="F:NFX.Serialization.Slim.TypeRegistry.NULL_HANDLE">
            <summary>
            Denotes a special type which is object==null
            </summary>
        </member>
        <member name="M:NFX.Serialization.Slim.TypeRegistry.#ctor(System.Collections.Generic.IEnumerable{System.Type}[])">
            <summary>
            Initializes TypeRegistry with types from other sources
            </summary>
        </member>
        <member name="M:NFX.Serialization.Slim.TypeRegistry.Add(System.Type)">
            <summary>
            Adds the type if it not already in registry and returns true
            </summary>
        </member>
        <member name="M:NFX.Serialization.Slim.TypeRegistry.GetTypeHandleAsString(System.Type)">
            <summary>
            Returns a string with the type index formatted as handle if type exists in registry, or fully qualified type name otherwise
            </summary>
        </member>
        <member name="M:NFX.Serialization.Slim.TypeRegistry.GetTypeHandle(System.Type)">
            <summary>
            Returns a VarIntStr with the type index formatted as handle if type exists in registry, or fully qualified type name otherwise
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.GlueProtocolTypes">
            <summary>
            Returns Glue protocol specific types
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.DataAccessCRUDTypes">
            <summary>
            Returns common types for DataAccess.CRUD
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.CommonCollectionTypes">
            <summary>
            Returns frequently-used generic collections
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.BoxedCommonTypes">
            <summary>
            Returns common primitive types - use when much boxing is expected
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.BoxedCommonNullableTypes">
            <summary>
            Returns common nullable types - use when much boxing is expected
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.PODTypes">
            <summary>
            Returns PortableObjectDocument types
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.Count">
            <summary>
            How many items in the registry
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.CSum">
            <summary>
            Returns quick checksum of type registry contents.
            It is updated when new types get added into the registry
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.Item(NFX.IO.VarIntStr)">
            <summary>
            Returns type by handle i.e. VarIntStr(1) or VarIntStr("full name"). Throws in case of error
            </summary>
        </member>
        <member name="P:NFX.Serialization.Slim.TypeRegistry.Item(System.String)">
            <summary>
            Returns type by handle i.e. '$11' or full name. Throws in case of error
            </summary>
        </member>
        <member name="T:NFX.Serialization.Slim.TypeDescriptor">
            <summary>
            Type descriptor dynamicaly compiles serialization/deserialization expressions for a particular type
            </summary>
        </member>
        <member name="T:NFX.Serialization.SerializationOperation">
            <summary>
            Denotes ser/deser operations
            </summary>
        </member>
        <member name="F:NFX.Serialization.SerializationOperation.Serializing">
            <summary>
            Serializing object to stream
            </summary>
        </member>
        <member name="F:NFX.Serialization.SerializationOperation.Deserializing">
            <summary>
            Deserializing object from stream
            </summary>
        </member>
        <member name="T:NFX.Serialization.IDisposableSerializer">
            <summary>
            Describes an entity that can serialize and deserialize objects and can be disposed
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.ChildService">
            <summary>
            Child service entry as managed by CompositeServiceHost class
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.CompositeServiceHost">
            <summary>
            Represents a service that contains other child services.
            Start/Stop commands translate into child sub-commands.
            This class is used to host other services in various job/background process hosts
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.CompositeServiceHost.RegisterService(NFX.ServiceModel.Service,System.Int32,System.Boolean)">
            <summary>
            Returns true if child service was registered, false if it was already registered prior tp this call.
            The method may only be called on stopped (this) service
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.CompositeServiceHost.UnregisterService(NFX.ServiceModel.Service)">
            <summary>
            Returns true if child service was unregistered, false if it did not exist.
            The method may only be called on stopped (this) service
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.CompositeServiceHost.ChildServices">
            <summary>
            Returns service registry where services can be looked-up by name
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.CompositeServiceHost.OrderedChildServices">
            <summary>
            Returns services ordered by their order property
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.SvcHostException">
             <summary>
            Thrown by CompositeServiceHost
             </summary>
        </member>
        <member name="T:NFX.ServiceModel.ControlStatus">
            <summary>
            Stipulates control phase statuses like: Active/Inactive etc...
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.ApplicationDontAutoStartServiceAttribute">
            <summary>
            Designates service-derivative classes that should NOT be auto-started by the app container
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.IWorkItem`1">
            <summary>
            Defines a base for items executable by WorkQueue
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.IWorkItem`1.PerformWork(`0)">
            <summary>
            Invoked on an item to perform actual work. For example: repaint grid from changed data source, refresh file, send email etc...
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.IWorkItem`1.WorkSucceeded">
            <summary>
            Invoked after successfull work execution - when no exception happened
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.IWorkItem`1.WorkFailed(System.Boolean,System.Exception)">
            <summary>
            Invoked when either work execution or work success method threw an exception and did not succeed
            </summary>
            <param name="workPerformed">When true indicates that PerformWork() worked without exception but exception happened later</param>
            <param name="error">Exception instance</param>
        </member>
        <member name="T:NFX.ServiceModel.WorkItemAggregationIntervalKind">
            <summary>
            Defines how intervals should be handled. Sliding means that every time message is posted into in queue
             interval starts to count from scratch, periodic counts from the first message post
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.IAggregatableWorkItem">
            <summary>
            Represents an item that may be posted into WorkItemAggregatorService queue
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.WorkItemAggregatorService`1">
            <summary>
            Aggregates same/equal (as defined by item's IAggregatableWorkItem.AggregationKey) work items posted into queue to limit
             the penetration of duplicate work items in destination queue
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.IWorkQueue`1">
            <summary>
            Defines contract for work queue that work items can be posted to
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.IWorkQueue`1.PostItem(NFX.ServiceModel.IWorkItem{`0})">
            <summary>
            Posts work item into the queue in natural queue order (at the end of the queue)
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.WorkItemAggregatorService`1.PostItem(NFX.ServiceModel.IWorkItem{`0})">
            <summary>
            Posts work item in the service. This item may not be posted into destination if the same item was already recently posted
             into destination queue, however if no same work item will come within timeout, then this item will eventually post
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.WorkItemAggregatorService`1.DestinationQueue">
            <summary>
            Returns the destination queue
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.WorkItemAggregatorService`1.DestinationPostInterval">
            <summary>
            Defines an interval measured in milliseconds for posting into destination queue
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.WorkQueue`1">
            <summary>
            Maintains a queue of pending work - every WorkItem posting in the queue will be executed by the host of the queue.
            WorkQueues are useful for coordination of complex data/event flows in multi-threaded/service applications
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.WorkQueue`1.#ctor(`0)">
            <summary>
            Creates an instance of work queue in particular context
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.WorkQueue`1.#ctor(`0,NFX.ServiceModel.PostItemFilter{`0})">
            <summary>
            Creates an instance of work queue in particular context
             with specific woprk item post filter
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.WorkQueue`1.PostItem(NFX.ServiceModel.IWorkItem{`0})">
            <summary>
            Posts work item into the queue in natural queue order (at the end of the queue)
            </summary>
        </member>
        <member name="M:NFX.ServiceModel.WorkQueue`1.FetchDueItem">
            <summary>
            Takes due item off the queue without executing it and returns it, or returns null when queue is empty.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NFX.ServiceModel.WorkQueue`1.ProcessDueItem">
            <summary>
            Processes item in normal queue order (the item that is due to be processed). Returns true when there was an item in the queue.
            This method does not leak exceptions from work performance unless they are re-thrown by particular work item WorkFailed(error)
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.WorkQueue`1.Context">
            <summary>
            Returns context that work is processed in
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.WorkQueue`1.PendingCount">
            <summary>
            Returns pending number of work items
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.WorkQueue`1.ProcessedSuccessCount">
            <summary>
            Returns total number of work items processed without errors by this queue since its creation
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.WorkQueue`1.ProcessedFailureCount">
            <summary>
            Returns total number of work items processed with errors by this queue since its creation
            </summary>
        </member>
        <member name="P:NFX.ServiceModel.WorkQueue`1.ProcessedTotalCount">
            <summary>
            Returns total number of work items processed with or without errors by this queue since its creation
            </summary>
        </member>
        <member name="T:NFX.ServiceModel.PostItemFilter`1">
            <summary>
            A filter delegate that gets called within PostItem before adding work to this queue.
            This is useful for re-routing work to some other queue/s when needed.
            Return null if work item is going to be processed by some other queue that this delegate should post into.
            Keep in mind that this delegate is invoked by posters thread
            </summary>
        </member>
        <member name="T:NFX.Standards.BISAC">
            <summary>
            Book Industry Subject and Category (BISAC) Subject Headings
            </summary>
        </member>
        <member name="T:NFX.Standards.Countries_ISO3166_1">
            <summary>
            Performs mapping and normalization of ISO country codes between 2 and 3 digit form,
            for examle 'US' and 'USA'
            </summary>
        </member>
        <member name="T:NFX.Standards.Distance">
            <summary>
            Represents length distance with unit type.
            All operations are done with presision of 1 micrometer (10^(-3) mm)
            </summary>
        </member>
        <member name="T:NFX.Standards.Weight">
            <summary>
            Represents weight with unit type.
            All operations are done with presision of 1 milligramm
            </summary>
        </member>
        <member name="T:NFX.StringConsts">
            <summary>
            A dictionary of framework text messages.
            Localization may be done in this class in future
            </summary>
        </member>
        <member name="T:NFX.StringValueConversion">
            <summary>
            Provides extension methods for converting string values to different scalar types
            </summary>
        </member>
        <member name="M:NFX.StringValueConversion.AsStringWhenNullOrEmpty(System.String,System.String)">
            <summary>
            Used by env var macros evaluator do not remove
            </summary>
        </member>
        <member name="M:NFX.StringValueConversion.AsString(System.String,System.String)">
            <summary>
            Used by env var macros evaluator do not remove
            </summary>
        </member>
        <member name="M:NFX.StringValueConversion.AsType(System.String,System.Type,System.Boolean)">
            <summary>
            Tries to get a string value as specified type.
            When 'strict=false', tries to do some inference like return "true" for numbers that dont equal to zero etc.
            When 'strict=true' throws an exception if deterministic conversion is not possible
            </summary>
        </member>
        <member name="M:NFX.TaskUtils.OnOk(System.Threading.Tasks.Task,System.Action,System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Chains task 'first' with 'next' if first is completed, not cancelled and not faulted.
            Returns task that completes when 'next' completes
            </summary>
        </member>
        <member name="M:NFX.TaskUtils.OnOk``1(System.Threading.Tasks.Task{``0},System.Action{``0},System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Chains task 'first' with 'next' passing result of 'first' to 'next' if first is completed, not cancelled and not faulted.
            Returns task that completes when 'next' completes
            </summary>
        </member>
        <member name="M:NFX.TaskUtils.OnOk``1(System.Threading.Tasks.Task{``0},System.Func{``0,System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Chains task 'first' with task returned by 'next' passing result of 'first' to 'next' if first is completed, not cancelled and not faulted.
            Returns task that completes after task returned by 'next' completes
            </summary>
        </member>
        <member name="M:NFX.TaskUtils.OnOk``1(System.Threading.Tasks.Task,System.Func{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Chains task 'first' with task returned by 'next' if first is completed, not cancelled and not faulted.
            Returns task that completes after task returned by 'next' completes with result from 'next' task
            </summary>
        </member>
        <member name="M:NFX.TaskUtils.OnOk``2(System.Threading.Tasks.Task{``0},System.Func{``0,System.Threading.Tasks.Task{``1}},System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Chains task 'first' with task returned by 'next' passing result of 'first' to 'next' if first is completed, not cancelled and not faulted.
            Returns task that completes after task returned by 'next' completes with result from 'next' task
            </summary>
        </member>
        <member name="M:NFX.TaskUtils.OnError(System.Threading.Tasks.Task,System.Action)">
            <summary>
            Registers action executed if task was faulted or cancelled
            </summary>
        </member>
        <member name="M:NFX.TaskUtils.OnOkOrError(System.Threading.Tasks.Task,System.Action{System.Threading.Tasks.Task})">
            <summary>
            Registers action executed disregarding task state
            </summary>
        </member>
        <member name="M:NFX.TaskUtils.OnOkOrError``1(System.Threading.Tasks.Task{``0},System.Action{System.Threading.Tasks.Task})">
            <summary>
            Registers action executed disregarding task state
            </summary>
        </member>
        <member name="M:NFX.TaskUtils.AsCompletedTask(System.Action)">
            <summary>
            Non-generic version of <see cref="M:NFX.TaskUtils.AsCompletedTask``1(System.Func{``0})"/>
            </summary>
            <remarks>
            Because there is no non-generic <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> version
            generic version typed by <see cref="T:System.Object"/> is used (<see cref="T:System.Threading.Tasks.Task`1"/> inherits from <see cref="T:System.Threading.Tasks.Task"/>)
            </remarks>
        </member>
        <member name="M:NFX.TaskUtils.AsCompletedTask``1(System.Func{``0})">
            <summary>
            Returns task completed from a synchronous functor
            </summary>
        </member>
        <member name="M:NFX.TaskUtils.AssignWorkSegment(System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Returns the count of items in work segment along with the start index of the first item to be processed
            by a particular worker in the worker set
            </summary>
            <param name="totalItemCount">Total item count in the set processed by all workers</param>
            <param name="totalWorkerCount">Total number of workers int the set operating over the totalItemCount</param>
            <param name="thisWorkerIndex">The index of THIS worker in the whole worker set</param>
            <param name="startIndex">Returns the index of the first item in the assigned segment</param>
            <returns>The count of items in the assigned segment</returns>
        </member>
        <member name="T:NFX.Templatization.NHTCompiler">
            <summary>
            Compiles templates based of text files that use C# language syntax,
            First compiles by the TextJSTemplateCompiler then by the TextCSTemplateCompiler
            </summary>
        </member>
        <member name="T:NFX.Templatization.TextCSTemplateCompiler">
             <summary>
             Compiles templates based of text files that use C# language syntax
             </summary>
             <example>
             <code>
              #&lt;conf&gt;
               &lt;compiler base-class-name="NFX.Web.Templatization.SimpleWebTemplate"
                         namespace="TestWebApp.Templates"
                         abstract="true"
                         summary="Test master page"
                /&gt;
             #&lt;/conf&gt;
             #[class]
            
                 public string Title { get {return "aaaaa"; } }
            
            
                 protected abstract void renderHeader();
                 protected abstract void renderBody(bool showDetails);
                 protected abstract void renderFooter();
            
            
             #[render]
             &lt;html&gt;
              &lt;head&gt;
                &lt;title&gt;?[Title]&lt;/title&gt;
              &lt;/head&gt;
              &lt;body&gt;
            
               &lt;h1&gt;This is Header&lt;/h1&gt;
                @[renderHeader();]
            
               &lt;h1&gt;This is Body&lt;/h1&gt;
                @[renderBody(true);]
               &lt;p&gt;This is in master page&lt;/p&gt;
            
               &lt;h1&gt;This is Footer&lt;/h1&gt;
                @[renderFooter();]
            
              &lt;/body&gt;
             &lt;/html&gt;
             </code>
             </example>
        </member>
        <member name="T:NFX.Templatization.TemplateCompiler">
            <summary>
            Represents abstraction of template compilers. This class is not thread-safe
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.EnsureNotCompiled">
            <summary>
            Throws an exception if this instance has already been compiled
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.Compile">
            <summary>
            Performs compilation if it has not already been performed
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.IncludeTemplateSource(NFX.Templatization.ITemplateSource)">
            <summary>
            Includes template source into compilation
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.ExcludeTemplateSource(NFX.Templatization.ITemplateSource)">
            <summary>
            Exclude template source from compilation
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.ReferenceAssembly(System.String)">
            <summary>
            References assembly by its name if it is already not referenced
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.UnReferenceAssembly(System.String)">
            <summary>
            Removes assembly reference by its name if it was already referenced
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.GenerateUniqueName">
            <summary>
            Generates unique identifier suitable for use in code per compiler instance
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.DoBeforeCompileTemplateSources">
            <summary>
            Override to transform compile units before compilation starts
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.DoCompileTemplateSource(NFX.Templatization.CompileUnit)">
            <summary>
            Override to perform code generation from template source into code
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.DoCompileCode">
            <summary>
            Override to perform compilation of code into assembly
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.DoConfigure(NFX.Environment.IConfigSectionNode)">
            <summary>
            Override to perform custom configuration
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateCompiler.RegisterDefaultUsings(System.Collections.Generic.HashSet{System.String})">
            <summary>
            Override to provide default using clauses
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.LanguageName">
            <summary>
            Gets the name of the language that this compiler supports, i.e. "C#"
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.LanguageSourceFileExtension">
            <summary>
            Gets the name of the language source code file extension that this compiler supports, i.e. ".cs"
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.Compiled">
            <summary>
            Indicates whether this instance was compiled
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.Options">
            <summary>
            Config options section used for compilation
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.Assembly">
            <summary>
            Returns compiled assembly or null if only source have been compiled when CompileCode=false;
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.ReferencedAssemblies">
            <summary>
            Returns referenced assemblies
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.ReferencedAssembliesSearchPath">
            <summary>
            Gets/sets path for referenced assemblies that do not have a path in their names
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.AssemblyFileName">
            <summary>
            Gets/sets filename for assembly, if null then assembly is created in-memory only
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.CompileCode">
            <summary>
            Indicates whether language compilation should be performed and Assembly be built
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.BaseTypeName">
            <summary>
            Sets the name of base type that templates inherit from.
            This type must directly or indirectly inherit from Template
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.Namespace">
            <summary>
            Sets the name of namespace that classes compiled into
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.Item(NFX.Templatization.ITemplateSource)">
            <summary>
            Returns a compile unit by template source or throws if it does not exist
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.HasErrors">
            <summary>
            Indicates whether some units have template compilation errors or code compiler errors exist
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.CodeCompilerErrors">
            <summary>
            Returns code compilation errors
            </summary>
        </member>
        <member name="P:NFX.Templatization.TemplateCompiler.CompileUnitsWithErrors">
            <summary>
            Returns compile units that have errors
            </summary>
        </member>
        <member name="T:NFX.Templatization.ITemplateSource">
            <summary>
            Describes an entity that provides source for template
            </summary>
        </member>
        <member name="M:NFX.Templatization.ITemplateSource.GetSourceContent">
            <summary>
            Returns template source content
            </summary>
        </member>
        <member name="M:NFX.Templatization.ITemplateSource.InferClassName">
            <summary>
            Tries to suggest a class name for this content or null
            </summary>
        </member>
        <member name="M:NFX.Templatization.ITemplateSource.GetName(System.Int32)">
            <summary>
            Gets printable source name
            </summary>
        </member>
        <member name="M:NFX.Templatization.ITemplateSource.GetRelativeContent(System.String)">
            <summary>
            Returns content relative to this one or null if not supported
            </summary>
        </member>
        <member name="T:NFX.Templatization.ITemplateSource`1">
            <summary>
            Describes an entity that provides source for templates
            </summary>
        </member>
        <member name="M:NFX.Templatization.ITemplateSource`1.GetSourceContent">
            <summary>
            Returns template source content
            </summary>
        </member>
        <member name="M:NFX.Templatization.ITemplateSource`1.GetRelativeContent(System.String)">
            <summary>
            Returns content relative to this one or null if not supported
            </summary>
        </member>
        <member name="T:NFX.Templatization.FileTemplateStringContentSource">
            <summary>
            Represents a string template source that comes from a file
            </summary>
        </member>
        <member name="M:NFX.Templatization.FileTemplateStringContentSource.InferClassName">
            <summary>
            Returns the name of template class inferred from file name
            </summary>
        </member>
        <member name="M:NFX.Templatization.FileTemplateStringContentSource.GetName(System.Int32)">
            <summary>
            Gets printable source name
            </summary>
        </member>
        <member name="T:NFX.Templatization.TemplateStringContentSource">
            <summary>
            Represents a string template source that comes from a string
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateStringContentSource.InferClassName">
            <summary>
            Returns null as class name can not be inferred from string
            </summary>
        </member>
        <member name="M:NFX.Templatization.TemplateStringContentSource.GetName(System.Int32)">
            <summary>
            Gets printable source name
            </summary>
        </member>
        <member name="T:NFX.Templatization.IRenderingTarget">
            <summary>
            Defines an entity that a template can be rendered into.
            Templates are not necessarily text-based, consequently data is supplied as objects
            </summary>
        </member>
        <member name="M:NFX.Templatization.IRenderingTarget.Encode(System.Object)">
            <summary>
            Encodes an object per underlying target specification. For example, a Http-related target may
             encode strings using HttpEncoder. If particular target does not support encoding then this method should just return the argument unmodified
            </summary>
        </member>
        <member name="M:NFX.Templatization.IRenderingTarget.Write(System.Object)">
            <summary>
            Writes a generic object into target. Templates are not necessarily text-based, consequently this method takes an object argument
            </summary>
        </member>
        <member name="M:NFX.Templatization.IRenderingTarget.Flush">
            <summary>
            Flushes writes into underlying target implementation. If target does not support buffering then this call does nothing
            </summary>
        </member>
        <member name="T:NFX.Templatization.TemplatizationException">
            <summary>
            Base exception thrown by the templatization-related functionality
            </summary>
        </member>
        <member name="T:NFX.Templatization.TemplateCompilerException">
            <summary>
            Base exception thrown by the template compilers
            </summary>
        </member>
        <member name="T:NFX.Templatization.TemplateParseException">
            <summary>
            Indicates template source parsing exception
            </summary>
        </member>
        <member name="T:NFX.Templatization.TemplateCodeCompilerException">
            <summary>
            Thrown by  template code compilers
            </summary>
        </member>
        <member name="T:NFX.Templatization.CompileUnit">
            <summary>
            Represents a compilation unit which is compiled by TemplateCompiler.
            Use TemplateCompiler.IncludeTemplateSource() method or pass sources to .ctor
            </summary>
        </member>
        <member name="P:NFX.Templatization.CompileUnit.TemplateSource">
            <summary>
            References original template source such as a string for text-based templates or an image
            </summary>
        </member>
        <member name="P:NFX.Templatization.CompileUnit.CompiledSource">
            <summary>
            Returns source code in a language that particular TemplateCompiler derivative supports.
            Use TemplateCompiler.LanguageName to determine language polymorphicaly
            </summary>
        </member>
        <member name="P:NFX.Templatization.CompileUnit.CompiledTemplateType">
            <summary>
            Returns CLR type that compiler produced IF language source compilation was performed
            </summary>
        </member>
        <member name="P:NFX.Templatization.CompileUnit.CompiledTemplateTypeName">
            <summary>
            Returns fully-qualified CLR type name that compiler produced
            </summary>
        </member>
        <member name="P:NFX.Templatization.CompileUnit.CompilationException">
            <summary>
            Returns an exception that was thrown during compilation
            </summary>
        </member>
        <member name="T:NFX.Templatization.CompileUnits">
            <summary>
            Represents a bag of compile units
            </summary>
        </member>
        <member name="T:NFX.Templatization.StringRenderingTarget">
            <summary>
            Renders templates into string
            </summary>
        </member>
        <member name="M:NFX.Templatization.StringRenderingTarget.ToString">
            <summary>
            Returns what has been written
            </summary>
        </member>
        <member name="P:NFX.Templatization.StringRenderingTarget.Value">
            <summary>
            Returns what has been written
            </summary>
        </member>
        <member name="T:NFX.Templatization.ITemplate">
            <summary>
            A general template interface.
            A template is a class that gets instantiated at some point to Render() its content into IRenderingTarget instance.
            Templates are not necessarily text-based, i.e. they can be image-based or based on various kinds of binary files
            </summary>
        </member>
        <member name="M:NFX.Templatization.ITemplate.Render(NFX.Templatization.IRenderingTarget,System.Object)">
            <summary>
            Renders template by generating content into target
            </summary>
            <param name="target">A target that rendering is done into</param>
            <param name="renderingContext">A context object for this rendering call</param>
        </member>
        <member name="P:NFX.Templatization.ITemplate.Context">
            <summary>
            Custom context for the lifetime of this template
            </summary>
        </member>
        <member name="P:NFX.Templatization.ITemplate.CanReuseInstance">
            <summary>
            Indicates whether an instance of template class may be reused for invocation of Render() more than once (possibly with different rendering target and/or rendering context)
            </summary>
        </member>
        <member name="T:NFX.Templatization.Template`3">
            <summary>
            A general ancestor for any template. All templates derive from this class directly or indirectly.
            A template is a class that gets instantiated at some point to Render() its content into IRenderingTarget instance.
            Templates are not necessarily text-based, i.e. they can be image-based or based on various kinds of binary files
            </summary>
        </member>
        <member name="M:NFX.Templatization.Template`3.Render(`1,`2)">
            <summary>
            Renders template by generating content into target
            </summary>
            <param name="target">A target to render output into</param>
            <param name="renderingContext">A context object for this rendering call</param>
        </member>
        <member name="M:NFX.Templatization.Template`3.BindGlobalContexts(`0)">
            <summary>
            Infrastructure. Sets Context property. Normally this method should never be called by developers
            </summary>
        </member>
        <member name="M:NFX.Templatization.Template`3.DoContextBinding">
            <summary>
            Infrastructure. Override to perform extra steps after Context property gets set.
            Normally this method should never be called by developers
            </summary>
        </member>
        <member name="M:NFX.Templatization.Template`3.DoPreRender">
            <summary>
            Performs pre-rendering actions
            </summary>
        </member>
        <member name="M:NFX.Templatization.Template`3.DoRender">
            <summary>
            Performs actual rendering
            </summary>
        </member>
        <member name="M:NFX.Templatization.Template`3.DoPostRender(System.Exception)">
            <summary>
            Performs post-rendering actions. Return true to rethrow error
            </summary>
        </member>
        <member name="P:NFX.Templatization.Template`3.Context">
            <summary>
            Custom context for the lifetime of this template
            </summary>
        </member>
        <member name="P:NFX.Templatization.Template`3.Target">
            <summary>
            Returns thread-local target which is specific for this call to Render()
            </summary>
        </member>
        <member name="P:NFX.Templatization.Template`3.RenderingContext">
            <summary>
            Returns thread-local rendering context which is specific for this call to Render()
            </summary>
        </member>
        <member name="P:NFX.Templatization.Template`3.CanReuseInstance">
            <summary>
            Indicates whether an instance of template class may be reused for invocation of Render() more than once (possibly with different rendering target and/or rendering context)
            </summary>
        </member>
        <member name="T:NFX.Aver">
            <summary>
            Provides basic averments for test construction. May call Aver.Fail(msg) manually
            </summary>
        </member>
        <member name="M:NFX.Aver.Fail(System.String,System.String)">
            <summary>
            Fails averment by throwing AvermentException
            </summary>
        </member>
        <member name="M:NFX.Aver.AreObjectEqualTest(System.Object,System.Object)">
            <summary>
            Test for equality via object.Equals()only disregarding all other possible equality comparers like IEquatable etc...
            </summary>
        </member>
        <member name="M:NFX.Aver.AreObjectsEqual(System.Object,System.Object,System.String)">
            <summary>
            Test for equality via object.Equals()only disregarding all other possible equality comparers like IEquatable etc...
            </summary>
        </member>
        <member name="M:NFX.Aver.AreObjectsNotEqual(System.Object,System.Object,System.String)">
            <summary>
            Test for inequality via object.Equals()only disregarding all other possible equality comparers like IEquatable etc...
            </summary>
        </member>
        <member name="T:NFX.Templatization.TextJSTemplateCompiler">
            <summary>
            Compiles templates based of text files that use js language syntax,
            compiles config to inline function
            </summary>
            <example>
              argument[0] - root container 'id' or 'node'
              argument[1] - context for variable evaluation
              <code>
              function() {
                /*** #preprocessor_directive#
                {
                  tag-name="inner text"
                  property-name="property value"
                  evaluted-property-name="@prop@ evaluated property"
                  on-event="function() { click(); }"
                }
                ***/
              }
              </code>
            </example>
        </member>
        <member name="T:NFX.Throttling.NOPThrottle">
            <summary>
            No operation throttle
            </summary>
        </member>
        <member name="T:NFX.Throttling.Throttle">
            <summary>
            Base class defining throttle interface
            </summary>
        </member>
        <member name="M:NFX.Throttling.IThrottle.Try">
            <summary>
            Checks whether the current throttle rate limit has not been reached
            per one unit of measurement.  This method is usually used to throttle based
            on pass count
            </summary>
        </member>
        <member name="M:NFX.Throttling.IThrottle.Try(System.Double)">
            <summary>
            Checks whether the current throttle rate limit has not been reached
            for the provided value.  This method is usually used to throttle based
            on values like financial amounts, data volumes, user counts, etc.
            </summary>
        </member>
        <member name="M:NFX.Throttling.IThrottle.Reset">
            <summary>
            Reset the internal state of the throttle
            </summary>
        </member>
        <member name="M:NFX.Throttling.IThrottle.Register(NFX.Throttling.IThrottling)">
            <summary>
            Register this instance with throttling container
            </summary>
        </member>
        <member name="M:NFX.Throttling.IThrottle.Unregister">
            <summary>
            Unregister this instance from throttling container
            </summary>
        </member>
        <member name="P:NFX.Throttling.IThrottle.Name">
            <summary>
            Returns the unique name of this instance
            </summary>
        </member>
        <member name="P:NFX.Throttling.IThrottle.Unit">
            <summary>
            Returns the name of unit of measurement for this instance
            </summary>
        </member>
        <member name="M:NFX.Throttling.Throttle.#ctor(System.String,System.String)">
            <summary>
            Constructor that identifies throttle by name, and optionally defines the
            unit of measurement for this throttle instance
            </summary>
        </member>
        <member name="M:NFX.Throttling.Throttle.Try">
            <summary>
            Checks whether the current throttle rate limit has not been reached
            per one unit of measurement.  This method is usually used to throttle based
            on pass count
            </summary>
        </member>
        <member name="M:NFX.Throttling.Throttle.Try(System.Double)">
            <summary>
            Checks whether the current throttle rate limit has not been reached
            for the provided value.  This method is usually used to throttle based
            on values like financial amounts, data volumes, user counts, etc.
            </summary>
        </member>
        <member name="M:NFX.Throttling.Throttle.Reset">
            <summary>
            Reset the internal state of the throttle
            </summary>
        </member>
        <member name="M:NFX.Throttling.Throttle.Register(NFX.Throttling.IThrottling)">
            <summary>
            Register this instance with throttling container
            </summary>
        </member>
        <member name="M:NFX.Throttling.Throttle.Unregister">
            <summary>
            Unregister this instance from throttling container
            </summary>
        </member>
        <member name="M:NFX.Throttling.Throttle.Try(System.DateTime,System.Double)">
            <summary>
            Update current throttle timestamp
            </summary>
        </member>
        <member name="P:NFX.Throttling.Throttle.Throttling">
            <summary>
            References the Throttling that this instance is registered with
            </summary>
        </member>
        <member name="P:NFX.Throttling.Throttle.Name">
            <summary>
            Returns the unique name of this instance
            </summary>
        </member>
        <member name="P:NFX.Throttling.Throttle.Unit">
            <summary>
            Returns the name of unit of measurement for this instance
            </summary>
        </member>
        <member name="M:NFX.Throttling.NOPThrottle.Try">
            <summary>
            Checks whether the current throttle rate limit has not been reached
            per one unit of measurement.  This method is usually used to throttle based
            on pass count
            </summary>
        </member>
        <member name="M:NFX.Throttling.NOPThrottle.Try(System.Double)">
            <summary>
            Checks whether the current throttle rate limit has not been reached
            for the provided value.  This method is usually used to throttle based
            on values like financial amounts, data volumes, user counts, etc.
            </summary>
        </member>
        <member name="M:NFX.Throttling.NOPThrottle.Reset">
            <summary>
            Reset the internal state of the throttle
            </summary>
        </member>
        <member name="M:NFX.Throttling.NOPThrottle.Try(System.DateTime,System.Double)">
            <summary>
            Update current throttle timestamp
            </summary>
        </member>
        <member name="P:NFX.Throttling.NOPThrottle.Instance">
            <summary>
            Returns a singlelton instance of the NOPThrottle
            </summary>
        </member>
        <member name="T:NFX.Throttling.IThrottling">
            <summary>
            Defines throttling interface to be implemented by the throttling service
            </summary>
        </member>
        <member name="M:NFX.Throttling.IThrottling.RegisterThrottle(NFX.Throttling.Throttle)">
            <summary>
            Register a throttle with this throttling container
            </summary>
        </member>
        <member name="M:NFX.Throttling.IThrottling.UnregisterThrottle(NFX.Throttling.Throttle)">
            <summary>
            Unregister a throttle from this throttling container
            </summary>
            <returns>True if throttle was successfully unregistered</returns>
        </member>
        <member name="P:NFX.Throttling.IThrottling.Enabled">
            <summary>
            Turns throttling functionality on/off
            </summary>
        </member>
        <member name="P:NFX.Throttling.IThrottling.Item(System.String)">
            <summary>
            Get a throttle by name
            </summary>
        </member>
        <member name="T:NFX.Throttling.IThrottlingImplementation">
            <summary>
            Interface implementing configurable and disposable throttling functionaliry
            </summary>
        </member>
        <member name="T:NFX.Throttling.NOPThrottling">
            <summary>
            Represents throttling implementation that does nothing and
            always returns NOPThrottle
            </summary>
        </member>
        <member name="T:NFX.Throttling.TimeSpacingThrottle">
            <summary>
            Throttle based on space reservation in time. It allows at most Limit
            calls of Try() function per Interval. The calls are assumed to be
            equally spaced within the Interval
            </summary>
        </member>
        <member name="M:NFX.Throttling.TimeSpacingThrottle.#ctor(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name of this instance</param>
            <param name="throttleLimit">Throttling limit per throttleInterval</param>
            <param name="throttleInterval">Throttling interval in number of seconds</param>
            <param name="unit">Unit of measurement</param>
        </member>
        <member name="M:NFX.Throttling.TimeSpacingThrottle.Reset">
            <summary>
            Reset the internal state of the throttling strategy
            </summary>
        </member>
        <member name="M:NFX.Throttling.TimeSpacingThrottle.Try(System.DateTime,System.Double)">
            <summary>
            Try to reserve a value of units assuming given time.
            </summary>
            <param name="time">Monotonically increasing time value</param>
            <param name="value">The value of timeslots needed to reserve</param>
            <returns>True if reservation is successful</returns>
        </member>
        <member name="P:NFX.Throttling.TimeSpacingThrottle.Limit">
            <summary>
            Return throttle limit over Interval
            </summary>
        </member>
        <member name="P:NFX.Throttling.TimeSpacingThrottle.Interval">
            <summary>
            Return throttling interval in seconds
            </summary>
        </member>
        <member name="T:NFX.Throttling.SlidingWindowThrottle">
            <summary>
            Efficiently calculates the throttling rate over a number of seconds.
            The algorithm implements a variation of token bucket algorithm that
            doesn't require to add tokens to the bucket on a timer but rather it
            maintains a cirtular buffer of tokens with resolution of 1/BucketsPerSec.
            The Add() function is used to add items to a bucket
            associated with the timestamp passed as the first argument to the
            function. The Sum() returns the total number of
            items over the given interval of seconds. The items automatically expire
            when the time moves on the successive invocations of the Add() method.
            </summary>
        </member>
        <member name="M:NFX.Throttling.SlidingWindowThrottle.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name of this instance</param>
            <param name="throttleLimit">Throttling limit per throttleInterval</param>
            <param name="throttleInterval">Throttling interval in number of seconds</param>
            <param name="bucketsPerSecond">Number of buckets per second to calculate internal running sum.
            The greater the value the more precise the avg calculation is and the longer it takes to
            calculate</param>
            <param name="unit">Unit of measurement</param>
        </member>
        <member name="M:NFX.Throttling.SlidingWindowThrottle.Reset">
            <summary>
            Reset the internal state of the throttling strategy
            </summary>
        </member>
        <member name="M:NFX.Throttling.SlidingWindowThrottle.ToString(System.DateTime)">
            <summary>
            Dump the internal state to string
            </summary>
            <param name="time">Time for which to dump internal state to string</param>
        </member>
        <member name="M:NFX.Throttling.SlidingWindowThrottle.Try(System.DateTime,System.Double)">
            <summary>
            Add value to the bucket associated with time
            </summary>
            <param name="time">Monotonically increasing time value</param>
            <param name="value">The value to add to the bucket associated with time</param>
            <returns>Current running sum</returns>
        </member>
        <member name="P:NFX.Throttling.SlidingWindowThrottle.Limit">
            <summary>
            Return throttle limit over Interval
            </summary>
        </member>
        <member name="P:NFX.Throttling.SlidingWindowThrottle.Interval">
            <summary>
            Return throttling interval in seconds
            </summary>
        </member>
        <member name="P:NFX.Throttling.SlidingWindowThrottle.BucketsPerSec">
            <summary>
            Number of measurement buckets per second. The greater the number
            the more accurate throttle rate is calculated and the slower the
            calculation gets
            </summary>
        </member>
        <member name="P:NFX.Throttling.SlidingWindowThrottle.Sum">
            <summary>
            Return current running sum over the throttling interval
            </summary>
        </member>
        <member name="P:NFX.Throttling.SlidingWindowThrottle.Avg">
            <summary>
            Return current running average over the throttling interval
            </summary>
        </member>
        <member name="T:NFX.Throttling.ThrottlingService">
            <summary>
            A service that maintains throttling components in an application and
            allows to turn on/off global throttling functionality
            </summary>
        </member>
        <member name="M:NFX.Throttling.ThrottlingService.Get``1(System.String)">
            <summary>
            Resolve a typed throttle by name
            </summary>
        </member>
        <member name="M:NFX.Throttling.ThrottlingService.RegisterThrottle(NFX.Throttling.Throttle)">
            <summary>
            Register a throttle with this throttling container
            </summary>
        </member>
        <member name="M:NFX.Throttling.ThrottlingService.UnregisterThrottle(NFX.Throttling.Throttle)">
            <summary>
            Unregister a throttle from this throttling container
            </summary>
            <returns>True if throttle was successfully unregistered</returns>
        </member>
        <member name="P:NFX.Throttling.ThrottlingService.Item(System.String)">
            <summary>
            Resolve a throttle instance by name
            </summary>
        </member>
        <member name="T:NFX.Time.DaysOfWeek">
            <summary>
            Days of week bitmask enumeration
            </summary>
        </member>
        <member name="T:NFX.Time.DefaultTimeSource">
            <summary>
            Provides default time source implementation which is build on DateTime local class
            </summary>
        </member>
        <member name="T:NFX.Time.ITimeSourceImplementation">
            <summary>
            Denotes an implementation for an app-global time source - an entity that supplies time in this application instance
            </summary>
        </member>
        <member name="T:NFX.Time.ITimeSource">
            <summary>
            Denotes app-global time source - an entity that supplies time in this application instance
            </summary>
        </member>
        <member name="P:NFX.Time.ITimeSource.Now">
            <summary>
            Returns local time stamp, Alias to this.LocalizedTime
            </summary>
        </member>
        <member name="P:NFX.Time.ITimeSource.UTCNow">
            <summary>
            Returns current UTC time stamp
            </summary>
        </member>
        <member name="M:NFX.Time.DefaultTimeSource.UniversalTimeToLocalizedTime(System.DateTime)">
            <summary>
            Converts universal time to local time as of TimeLocation property
            </summary>
        </member>
        <member name="M:NFX.Time.DefaultTimeSource.LocalizedTimeToUniversalTime(System.DateTime)">
            <summary>
            Converts localized time to UTC time as of TimeLocation property
            </summary>
        </member>
        <member name="P:NFX.Time.DefaultTimeSource.Instance">
            <summary>
            Returns a singleton DefaultTimeSource instance
            </summary>
        </member>
        <member name="P:NFX.Time.DefaultTimeSource.LocalizedTime">
            <summary>
            Returns current time localized per TimeLocation
            </summary>
        </member>
        <member name="T:NFX.Time.EventStatus">
            <summary>
            Denotes statuses that events get transitioned through
            </summary>
        </member>
        <member name="T:NFX.Time.EventBodyAsyncModel">
            <summary>
            Defines event body execution asynchrony model
            </summary>
        </member>
        <member name="F:NFX.Time.EventBodyAsyncModel.AsyncTask">
            <summary>
            The body should be called as a short-lived (less than 1 sec) task
            </summary>
        </member>
        <member name="F:NFX.Time.EventBodyAsyncModel.LongRunningAsyncTask">
            <summary>
            The body should be called as a long-runnig task. The system may dedicate it a thread.
            Use this ONLY for events that fire infrequently (i.e. once every X minutes+) and take long time to execute (seconds+)
            </summary>
        </member>
        <member name="F:NFX.Time.EventBodyAsyncModel.Sync">
            <summary>
            ADVANCED FEATURE. Run task synchronously on the timer thread.
            Use this option ONLY if the task body is very short (less than 10 ms).
            In most cases do not use this option as event body blocks the whole global application timer thread
            </summary>
        </member>
        <member name="T:NFX.Time.IEventHandler">
            <summary>
            Represents an entity that can handle events.
            This type is used to implement event handlers that get injected via config
            </summary>
        </member>
        <member name="T:NFX.Time.TimerEvent">
            <summary>
            Delegate type for events that get called when timer fires
            </summary>
        </member>
        <member name="T:NFX.Time.TimerEventStatusChange">
            <summary>
            Delegate type for events that get called when timer event status changes
            </summary>
        </member>
        <member name="T:NFX.Time.TimerEventDefinitionChange">
            <summary>
            Delegate type for events that get called when one of timer event definition parameters changes
            </summary>
        </member>
        <member name="T:NFX.Time.EventTimer">
            <summary>
            Provides default implementation for IEventTimer
            </summary>
        </member>
        <member name="T:NFX.Time.IEventTimerImplementation">
            <summary>
            Denotes an implementation for an app-global event timer - an entity that fires requested events
            </summary>
        </member>
        <member name="T:NFX.Time.IEventTimer">
            <summary>
            Denotes a contract for an app-global event timer - an entity that fires requested events
            </summary>
        </member>
        <member name="P:NFX.Time.IEventTimer.ResolutionMs">
            <summary>
            Gets the granularity of event firing resolution
            </summary>
        </member>
        <member name="P:NFX.Time.IEventTimer.Events">
            <summary>
            Lists all events in the instance
            </summary>
        </member>
        <member name="M:NFX.Time.IEventTimerImplementation.__InternalRegisterEvent(NFX.Time.Event)">
            <summary>
            Internall call, developers - do not call
            </summary>
        </member>
        <member name="M:NFX.Time.IEventTimerImplementation.__InternalUnRegisterEvent(NFX.Time.Event)">
            <summary>
            Internall call, developers - do not call
            </summary>
        </member>
        <member name="P:NFX.Time.EventTimer.ResolutionMs">
            <summary>
            Timer resolution in milliseconds
            </summary>
        </member>
        <member name="P:NFX.Time.EventTimer.Events">
            <summary>
            Lists all events in the instance
            </summary>
        </member>
        <member name="T:NFX.Time.TimeException">
            <summary>
            Base exception thrown by the Time framework
            </summary>
        </member>
        <member name="T:NFX.Time.NOPEventTimer">
            <summary>
            Normally this class should never be used as the dafult EventTimer is always present instead of nop
            </summary>
        </member>
        <member name="T:NFX.Time.TimeLocation">
            <summary>
            Data about location where time is measured relative to UTC
            </summary>
        </member>
        <member name="M:NFX.Time.TimeLocation.#ctor(System.Boolean)">
            <summary>
            Creates instance that uses entity's parent settings. May use TimeLocation.Parent static instance instead
            </summary>
        </member>
        <member name="P:NFX.Time.TimeLocation.Parent">
            <summary>
            Returns a singleton instance of timelocation which uses parent setting
            </summary>
        </member>
        <member name="P:NFX.Time.TimeLocation.UTC">
            <summary>
            Returns a singleton instance of UTC timelocation (zero offset from UTC)
            </summary>
        </member>
        <member name="P:NFX.Time.TimeLocation.UTCOffset">
            <summary>
            Returns UTC offset
            </summary>
        </member>
        <member name="P:NFX.Time.TimeLocation.Description">
            <summary>
            Location description
            </summary>
        </member>
        <member name="P:NFX.Time.TimeLocation.UseParentSetting">
            <summary>
            Returns true when entity's parent settings should be used
            </summary>
        </member>
        <member name="P:NFX.Time.TimeLocation.Immutable">
            <summary>
            Returns true to indicate that the instance can not be mutated with Configure() or property sets
            </summary>
        </member>
        <member name="M:NFX.IntMath.Align8(System.Int32)">
            <summary>
            Returns argument increased to the nearest number divisible by 8
            </summary>
        </member>
        <member name="M:NFX.IntMath.Align16(System.Int32)">
            <summary>
            Returns argument increased to the nearest number divisible by 16
            </summary>
        </member>
        <member name="M:NFX.IntMath.Align8(System.Int64)">
            <summary>
            Returns argument increased to the nearest number divisible by 8
            </summary>
        </member>
        <member name="M:NFX.IntMath.Align16(System.Int64)">
            <summary>
            Returns argument increased to the nearest number divisible by 16
            </summary>
        </member>
        <member name="M:NFX.IntMath.IsPrime(System.Int32)">
            <summary>
            Tests if the number is prime
            </summary>
        </member>
        <member name="M:NFX.IntMath.GetAdjacentPrimeNumberLessThanOrEqualTo(System.Int32)">
            <summary>
            Gets adjacent prime number which is less than or equal to the specified number. Arguments less than 3 yield 2;
            </summary>
        </member>
        <member name="M:NFX.IntMath.GetPrimeCapacityOfAtLeast(System.Int32)">
            <summary>
            Gets the capacity of at least or larger larger than the specified number. For numbers &lt;= 16300007 the function uses lookup table for speed
            </summary>
        </member>
        <member name="M:NFX.IntMath.GetCapacityFactoredToPrime(System.Int32,System.Double)">
            <summary>
            Increases a capacity to a prime number by the factor. Both numbers must be positive
            </summary>
        </member>
        <member name="M:NFX.IntMath.ChangeByRndPct(System.Int32,System.Single)">
            <summary>
            Changes the number by a random margin of up to the specified pct
            </summary>
        </member>
        <member name="M:NFX.IntMath.ChangeByRndPct(System.Int64,System.Single)">
            <summary>
            Changes the number by a random margin of up to the specified pct
            </summary>
        </member>
    </members>
</doc>
